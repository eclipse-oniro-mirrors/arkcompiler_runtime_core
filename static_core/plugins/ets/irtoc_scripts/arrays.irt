# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

include_relative '../../../irtoc/scripts/common.irt'
include_relative '../../../irtoc/scripts/array_helpers.irt'

module EtsConstants
  MAX_ALLOWED_INVALIDATING_CARDS = "2"
end

class SynchronizationType
  :Sync
  :Async
  :AsyncManual
  :Hybrid
end

scoped_macro(:post_inter_region_barrier) do |data, size|
  addr_first := Cast(data).ptr
  addr_last := SubI(Add(addr_first.ptr, Cast(size.u32).word).ptr).Imm(1).ptr

  min_addr := LoadI(%tr).Imm(Constants::TLS_CARD_TABLE_MIN_ADDR_OFFSET).word
  addr_first_word := Bitcast(addr_first).word
  first_card_offset := ShrI(Sub(addr_first_word, min_addr).word).Imm(Constants::CARD_TABLE_CARD_BITS).word
  addr_last_word := Bitcast(addr_last).word
  last_card_offset := ShrI(Sub(addr_last_word, min_addr).word).Imm(Constants::CARD_TABLE_CARD_BITS).word
  cards := Sub(last_card_offset, first_card_offset).word

  # If the fist and the last addresses belong to different cards, we need to invalidate two subsequent cards.
  # Invariant: size <= (1 << CARD_TABLE_CARD_BITS), but no one guarantees addr_first_word is aligned at card size.
  if defines.DEBUG
    If(cards, Cast(EtsConstants::MAX_ALLOWED_INVALIDATING_CARDS).word).AE.Unlikely {
      Intrinsic(:UNREACHABLE).Terminator.void
    }
  end

  If(cards, Cast(1).word).EQ.Unlikely {
    # `addr_second` here is a pointer to the slot just at the start of the 2nd card. A slot just at the start
    # of a card must be aligned at card size.
    addr_second := Add(ShlI(last_card_offset).Imm(Constants::CARD_TABLE_CARD_BITS).word, min_addr).word
    addr_second_ref := Cast(addr_second).SrcType(Options.arch_64_bits? ? "DataType::UINT64" :
        "DataType::UINT32").ref_uint
    if defines.DEBUG
      If(AndI(addr_second_ref).Imm(Constants::CARD_ALIGNMENT_MASK).ref_uint, 0).NE.Unlikely {
        Intrinsic(:UNREACHABLE).Terminator.void
      }
    end
    LiveOut(addr_second_ref).DstReg(regmap[:arg0]).ref_uint
    ep_offset = get_entrypoint_offset("POST_INTER_REGION_BARRIER_TWO_CARDS_SLOW")
    Intrinsic(:TAIL_CALL).AddImm(ep_offset).MethodAsImm("PostInterRegionBarrierTwoCardsSlow").Terminator.void
  }

  addr_first_ref := Cast(Bitcast(addr_first).SrcType("DataType::POINTER").word).SrcType(Options.arch_64_bits? ?
      "DataType::UINT64" : "DataType::UINT32").ref_uint
  LiveOut(addr_first_ref).DstReg(regmap[:arg0]).ref_uint
  ep_offset = get_entrypoint_offset("POST_INTER_REGION_BARRIER_SLOW")
  Intrinsic(:TAIL_CALL).AddImm(ep_offset).MethodAsImm("PostInterRegionBarrierSlow").Terminator.void
end # post_inter_region_barrier

scoped_macro(:post_inter_generational_barrier) do |obj|
  min_addr := LoadI(%tr).Imm(Constants::TLS_CARD_TABLE_MIN_ADDR_OFFSET).word
  cards := LoadI(%tr).Imm(Constants::TLS_CARD_TABLE_ADDR_OFFSET).ptr

  # GCGenBarrierSet just ignores the offset to the data and count and works with the dst object only.
  mem_word := Bitcast(obj).word
  card_offset := ShrI(Sub(mem_word, min_addr).word).Imm(Constants::CARD_TABLE_CARD_BITS).word
  card := Add(cards, card_offset).ptr
  StoreI(card, Constants::CARD_DIRTY_VALUE).Imm(Constants::CARD_VALUE_OFFSET).u8
end # post_inter_generational_barrier

def GenerateArrayFastCopyToRef(sync_type)
  function("ArrayFastCopyToRef#{sync_type}".to_sym,
          params: {src_obj: 'ref', dst_obj: 'ref', dst_start: 'u32', src_start: 'u32', src_end: 'u32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

    if sync_type == :Hybrid && !defines.ARK_HYBRID
      ReturnVoid().void
      next
    end

    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).Terminator.void
      next
    end

    len := Sub(src_end, src_start).u32
    # if len <= 0 then do nothing
    If(len, 0).BE.Unlikely.b {
      Goto(:Done)
    }

    src_from_bytes := ShlI(src_start).Imm(EtsConstants::LOG2_BYTES_PER_OBJ_PTR).u32
    dst_from_bytes := ShlI(dst_start).Imm(EtsConstants::LOG2_BYTES_PER_OBJ_PTR).u32

    src_data := AddI(Cast(src_obj).ptr).Imm(Constants::ARRAY_DATA_OFFSET).ptr
    src_data := Add(src_data, Cast(src_from_bytes).word).ptr

    dst_data := AddI(Cast(dst_obj).ptr).Imm(Constants::ARRAY_DATA_OFFSET).ptr
    dst_data := Add(dst_data, Cast(dst_from_bytes).word).ptr

    # if src_data == dst_data then do nothing
    If(src_data, dst_data).EQ.Unlikely.b {
      Goto(:Done)
    }

    # start copying
    len_bytes := ShlI(len).Imm(EtsConstants::LOG2_BYTES_PER_OBJ_PTR).u32

    src_offset1 := Cast(0).u32
    dst_offset1 := Cast(0).u32
  Label(:Loop)
    src_offset := Phi(src_offset1, src_offset2).u32
    dst_offset := Phi(dst_offset1, dst_offset2).u32
    If(src_offset, len_bytes).AE.Unlikely {
      Goto(:LoopDone)
    }

    elem := Load(src_data, src_offset).ref
    Store(dst_data, dst_offset, elem).SetNeedBarrier(sync_type == :Hybrid).ref

    src_offset2 := AddI(src_offset).Imm(EtsConstants::OBJ_PTR_SIZE).u32
    dst_offset2 := AddI(dst_offset).Imm(EtsConstants::OBJ_PTR_SIZE).u32
    Goto(:Loop)
  Label(:LoopDone)
    if sync_type == :Async
      post_inter_region_barrier(dst_data, len_bytes)
    elsif sync_type == :AsyncManual
      dst_obj_ptr := Cast(dst_obj).ptr
      post_inter_generational_barrier(dst_obj_ptr)
    end
  Label(:Done)
    ReturnVoid().void
  }
end

GenerateArrayFastCopyToRef(:Sync)
GenerateArrayFastCopyToRef(:Async)
GenerateArrayFastCopyToRef(:AsyncManual)
GenerateArrayFastCopyToRef(:Hybrid)
