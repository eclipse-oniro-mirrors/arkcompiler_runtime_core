# Copyright (c) 2021-2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module EtsConstants
    CORO_NULL_VALUE_OFFSET = "cross_values::GetEtsCoroutineNullValueOffset(graph->GetArch())"
    ESCOMPAT_ARRAY_DATA_OFFSET = "cross_values::GetEscompatArrayBufferOffset(graph->GetArch())"
    ESCOMPAT_ARRAY_ACTUAL_LENGTH_OFFSET = "cross_values::GetEscompatArrayActualLengthOffset(graph->GetArch())"
    BOX_PRIMITIVE_VALUE_OFFSET = "cross_values::GetEtsBoxPrimitiveValueOffset(graph->GetArch())"
    TYPED_ARRAY_BUFFER_OFFSET = "cross_values::GetTypedArrayBufferOffset(graph->GetArch())"
    TYPED_ARRAY_BYTE_OFFSET_OFFSET = "cross_values::GetTypedArrayByteOffsetOffset(graph->GetArch())"
    TYPED_UNSIGNED_ARRAY_BUFFER_OFFSET = "cross_values::GetTypedUnsignedArrayBufferOffset(graph->GetArch())"
    TYPED_UNSIGNED_ARRAY_BYTE_OFFSET_OFFSET = "cross_values::GetTypedUnsignedArrayByteOffsetOffset(graph->GetArch())"
    ARRAY_BUFFER_DATA_OFFSET = "cross_values::GetArrayBufferDataOffset(graph->GetArch())"
    CORO_LOCAL_STORAGE_OFFSET = "cross_values::GetEtsCoroutineLocalStorageOffset(graph->GetArch())"

    ETS_CLASS_RUNTIME_CLASS_OFFSET = "cross_values::GetEtsClassRuntimeClassOffset(graph->GetArch())"
    ETS_CLASS_FLAGS_OFFSET = "cross_values::GetEtsClassFlagsOffset(graph->GetArch())"
    ETS_CLASS_FLAGS_FROM_RUNTIME_CLASS_OFFSET = "(-" + ETS_CLASS_RUNTIME_CLASS_OFFSET + "+" + ETS_CLASS_FLAGS_OFFSET + ")"
    ETS_CLASS_IS_BIG_INT_FLAG = "cross_values::GetEtsClassIsBigIntFlag(graph->GetArch())"
    ETS_CLASS_BOXED_TYPE_FIELD_START = "cross_values::GetEtsClassBoxedTypeFieldStart(graph->GetArch())"
    ETS_CLASS_BOXED_TYPE_FIELD_SIZE = "cross_values::GetEtsClassBoxedTypeFieldSize(graph->GetArch())"
    ETS_CLASS_BOXED_TYPE_FIELD_MASK = "(((1LLU << " + ETS_CLASS_BOXED_TYPE_FIELD_SIZE + ") - 1) << " + ETS_CLASS_BOXED_TYPE_FIELD_START + ")"
    ETS_CLASS_BOXED_TYPE_INT_MASK_VALUE = "(cross_values::GetEtsClassBoxedTypeIntMaskValue(graph->GetArch()) << " + ETS_CLASS_BOXED_TYPE_FIELD_START + ")"
    ETS_CLASS_BOXED_TYPE_DOUBLE_MASK_VALUE = "(cross_values::GetEtsClassBoxedTypeDoubleMaskValue(graph->GetArch()) << " + ETS_CLASS_BOXED_TYPE_FIELD_START + ")"

    OBJ_PTR_SIZE = "ark::OBJECT_POINTER_SIZE"
    LOG2_BYTES_PER_OBJ_PTR = "2" # object pointer has a size of 4 bytes on each supported platform

    FLOAT32_NAN = "0x7fc00000"
    FLOAT64_NAN = "0x7ff8000000000000"
    FLOAT64_INF = "0x7ff0000000000000"
    FLOAT64_MINUS_INF = "0xfff0000000000000"
end

scoped_macro(:getBoxedType) do |flags|
  AndI(flags).Imm(EtsConstants::ETS_CLASS_BOXED_TYPE_FIELD_MASK).u32
end

scoped_macro(:isBigIntType) do |flags|
  AndI(flags).Imm(EtsConstants::ETS_CLASS_IS_BIG_INT_FLAG).u32
end

macro(:ets_nullvalue) do
  LoadI(%tr).Imm(EtsConstants::CORO_NULL_VALUE_OFFSET).ref
end

###
# Resolves a value of type 'ref_uint' stored in the memory by address 'base + offset', where 'offset` is an immediate
# value, and returns it as a pointer. See also the 'ark::ObjectPointerType' alias and the 'ark::ObjectPointer' class.
#
macro(:get_object_pointer_imm) do |base, offset|
  # Cast makes no problem when panda's codegen is in use but leads to an ill-formed 'addrspacecast i32 to ptr'
  # instruction when the LLVM codegen is used. 'Bitcast' is lowered to the expected instruction 'inttoptr i32 to ptr'.
  Bitcast(Cast(LoadI(base).Imm(offset).ref_uint).word).ptr
end

###
# Resolves a value of type 'ref_uint' stored in the memory by address 'base + offset', and returns it as a pointer.
# See also the 'ark::ObjectPointerType' alias and the 'ark::ObjectPointer' class.
#
macro(:get_object_pointer) do |base, offset|
  Bitcast(Cast(Load(Cast(base).ptr, Cast(offset).word).ref_uint).word).ptr
end
