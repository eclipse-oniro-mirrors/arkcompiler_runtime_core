# Copyright (c) 2021-2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module EtsConstants
    CORO_NULL_VALUE_OFFSET = "cross_values::GetEtsCoroutineNullValueOffset(graph->GetArch())"
    CORO_LOCAL_STORAGE_OFFSET = "cross_values::GetEtsCoroutineLocalStorageOffset(graph->GetArch())"
    ESCOMPAT_ARRAY_DATA_OFFSET = "cross_values::GetEscompatArrayBufferOffset(graph->GetArch())"
    ESCOMPAT_ARRAY_ACTUAL_LENGTH_OFFSET = "cross_values::GetEscompatArrayActualLengthOffset(graph->GetArch())"
    BOX_PRIMITIVE_VALUE_OFFSET = "cross_values::GetEtsBoxPrimitiveValueOffset(graph->GetArch())"
    TYPED_ARRAY_BUFFER_OFFSET = "cross_values::GetTypedArrayBufferOffset(graph->GetArch())"
    TYPED_ARRAY_BYTE_OFFSET_OFFSET = "cross_values::GetTypedArrayByteOffsetOffset(graph->GetArch())"
    TYPED_UNSIGNED_ARRAY_BUFFER_OFFSET = "cross_values::GetTypedUnsignedArrayBufferOffset(graph->GetArch())"
    TYPED_UNSIGNED_ARRAY_BYTE_OFFSET_OFFSET = "cross_values::GetTypedUnsignedArrayByteOffsetOffset(graph->GetArch())"
    ARRAY_BUFFER_DATA_OFFSET = "cross_values::GetArrayBufferDataOffset(graph->GetArch())"

    ETS_CLASS_RUNTIME_CLASS_OFFSET = "cross_values::GetEtsClassRuntimeClassOffset(graph->GetArch())"
    ETS_CLASS_FLAGS_OFFSET = "cross_values::GetEtsClassFlagsOffset(graph->GetArch())"
    ETS_CLASS_FLAGS_FROM_RUNTIME_CLASS_OFFSET = "(-" + ETS_CLASS_RUNTIME_CLASS_OFFSET + "+" + ETS_CLASS_FLAGS_OFFSET + ")"
    ETS_CLASS_IS_BIG_INT_FLAG = "cross_values::GetEtsClassIsBigIntFlag(graph->GetArch())"
    ETS_CLASS_BOXED_TYPE_FIELD_START = "cross_values::GetEtsClassBoxedTypeFieldStart(graph->GetArch())"
    ETS_CLASS_BOXED_TYPE_FIELD_SIZE = "cross_values::GetEtsClassBoxedTypeFieldSize(graph->GetArch())"
    ETS_CLASS_BOXED_TYPE_FIELD_MASK = "(((1LLU << " + ETS_CLASS_BOXED_TYPE_FIELD_SIZE + ") - 1) << " + ETS_CLASS_BOXED_TYPE_FIELD_START + ")"
    ETS_CLASS_BOXED_TYPE_INT_MASK_VALUE = "(cross_values::GetEtsClassBoxedTypeIntMaskValue(graph->GetArch()) << " + ETS_CLASS_BOXED_TYPE_FIELD_START + ")"
    ETS_CLASS_BOXED_TYPE_DOUBLE_MASK_VALUE = "(cross_values::GetEtsClassBoxedTypeDoubleMaskValue(graph->GetArch()) << " + ETS_CLASS_BOXED_TYPE_FIELD_START + ")"

    OBJ_PTR_SIZE = "ark::OBJECT_POINTER_SIZE"
    OBJ_PTR_LOG2_SIZE = "ark::OBJECT_POINTER_LOG2_SIZE"

    FLOAT32_NAN = "0x7fc00000"
    FLOAT64_NAN = "0x7ff8000000000000"
    FLOAT64_INF = "0x7ff0000000000000"
    FLOAT64_MINUS_INF = "0xfff0000000000000"

    MAX_ALLOWED_INVALIDATING_CARDS = "2"
end

scoped_macro(:getBoxedType) do |flags|
  AndI(flags).Imm(EtsConstants::ETS_CLASS_BOXED_TYPE_FIELD_MASK).u32
end

scoped_macro(:isBigIntType) do |flags|
  AndI(flags).Imm(EtsConstants::ETS_CLASS_IS_BIG_INT_FLAG).u32
end

macro(:ets_nullvalue) do
  LoadI(%tr).Imm(EtsConstants::CORO_NULL_VALUE_OFFSET).ref
end

###
# Resolves a value of type 'ref' stored in the memory by address 'base + offset', where 'offset` is an immediate
# value, and returns it as a pointer. See also the 'ark::ObjectPointerType' alias and the 'ark::ObjectPointer' class.
#
macro(:get_object_pointer_imm) do |base, offset|
  Cast(LoadI(base).Imm(offset).ref).ptr
end

###
# Resolves a value of type 'ref' stored in the memory by address 'base + offset', and returns it as a pointer.
# See also the 'ark::ObjectPointerType' alias and the 'ark::ObjectPointer' class.
#
macro(:get_object_pointer) do |base, offset|
  Cast(Load(base, Cast(offset).word).ref).ptr
end

###
# Load an address value (as `ref_uint`) from the EtsPlatformTypes storage. The deserved address must be stored
# in the platform types by offset `offset`.
#
macro(:get_platform_type_ref_uint) do |offset|
  ptypes := LoadI(%tr).Imm(EtsConstants::CORO_LOCAL_STORAGE_OFFSET).ptr
  LoadI(ptypes).Imm(offset).ref_uint
end

###
# Load a reference from the EtsPlatformTypes storage. The deserved reference must be stored
# in the platform types by offset `offset`.
#
macro(:get_platform_type_ref) do |offset|
  ptypes := LoadI(%tr).Imm(EtsConstants::CORO_LOCAL_STORAGE_OFFSET).ptr
  LoadI(ptypes).Imm(offset).ref
end

scoped_macro(:post_inter_region_barrier) do |data, size|
  addr_first := Cast(data).ptr
  addr_last := SubI(Add(addr_first.ptr, Cast(size.u32).word).ptr).Imm(1).ptr

  min_addr := LoadI(%tr).Imm(Constants::TLS_CARD_TABLE_MIN_ADDR_OFFSET).word
  addr_first_word := Bitcast(addr_first).word
  first_card_offset := ShrI(Sub(addr_first_word, min_addr).word).Imm(Constants::CARD_TABLE_CARD_BITS).word
  addr_last_word := Bitcast(addr_last).word
  last_card_offset := ShrI(Sub(addr_last_word, min_addr).word).Imm(Constants::CARD_TABLE_CARD_BITS).word
  cards := Sub(last_card_offset, first_card_offset).word

  # If the fist and the last addresses belong to different cards, we need to invalidate two subsequent cards.
  # Invariant: size <= (1 << CARD_TABLE_CARD_BITS), but no one guarantees addr_first_word is aligned at card size.
  if defines.DEBUG
    If(cards, Cast(EtsConstants::MAX_ALLOWED_INVALIDATING_CARDS).word).AE.Unlikely {
      Intrinsic(:UNREACHABLE).Terminator.void
    }
  end

  If(cards, Cast(1).word).EQ.Unlikely {
    # `addr_second` here is a pointer to the slot just at the start of the 2nd card. A slot just at the start
    # of a card must be aligned at card size.
    addr_second := Add(ShlI(last_card_offset).Imm(Constants::CARD_TABLE_CARD_BITS).word, min_addr).word
    addr_second_ref := Cast(addr_second).SrcType(Options.arch_64_bits? ? "DataType::UINT64" :
        "DataType::UINT32").ref_uint
    if defines.DEBUG
      If(AndI(addr_second_ref).Imm(Constants::CARD_ALIGNMENT_MASK).ref_uint, 0).NE.Unlikely {
        Intrinsic(:UNREACHABLE).Terminator.void
      }
    end
    LiveOut(addr_second_ref).DstReg(regmap[:arg0]).ref_uint
    ep_offset = get_entrypoint_offset("POST_INTER_REGION_BARRIER_TWO_CARDS_SLOW")
    Intrinsic(:TAIL_CALL).AddImm(ep_offset).MethodAsImm("PostInterRegionBarrierTwoCardsSlow").Terminator.void
  }

  addr_first_ref := Cast(Bitcast(addr_first).SrcType("DataType::POINTER").word).SrcType(Options.arch_64_bits? ?
      "DataType::UINT64" : "DataType::UINT32").ref_uint
  LiveOut(addr_first_ref).DstReg(regmap[:arg0]).ref_uint
  ep_offset = get_entrypoint_offset("POST_INTER_REGION_BARRIER_SLOW")
  Intrinsic(:TAIL_CALL).AddImm(ep_offset).MethodAsImm("PostInterRegionBarrierSlow").Terminator.void
end # post_inter_region_barrier

scoped_macro(:post_inter_generational_barrier) do |obj|
  min_addr := LoadI(%tr).Imm(Constants::TLS_CARD_TABLE_MIN_ADDR_OFFSET).word
  cards := LoadI(%tr).Imm(Constants::TLS_CARD_TABLE_ADDR_OFFSET).ptr

  # GCGenBarrierSet just ignores the offset to the data and count and works with the dst object only.
  mem_word := Bitcast(obj).word
  card_offset := ShrI(Sub(mem_word, min_addr).word).Imm(Constants::CARD_TABLE_CARD_BITS).word
  card := Add(cards, card_offset).ptr
  StoreI(card, Constants::CARD_DIRTY_VALUE).Imm(Constants::CARD_VALUE_OFFSET).u8
end # post_inter_generational_barrier
