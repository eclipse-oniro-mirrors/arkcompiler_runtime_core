# plugin typed_arrays
# Copyright (c) 2024 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

include_relative 'common.irt'
include_relative '../../../irtoc/scripts/common.irt'

def GenerateTypedArrayFillInternal(name, prefix, type, scale)
    function("#{name}ArrayFillInternalFastPath".to_sym,
            params: {arr: 'ref', val: type, startPos: 'i32', endPos: 'i32'},
            regmap: $full_regmap,
            regalloc_set: $panda_mask,
            mode: [:FastPath]) {

        if Options.arch == :arm32
            Intrinsic(:UNREACHABLE).Terminator.void
            next
        end
        buffer := LoadI(arr).Imm(EtsConstants::TYPED_ARRAY_BUFFER_OFFSET).ref
        bufferData := LoadI(buffer).Imm(EtsConstants::ARRAY_BUFFER_DATA_OFFSET).ref
        If(bufferData, 0).EQ.Unlikely {
          Goto(:SlowPathEntrypoint)
        }
        byteOffsetF64 := LoadI(arr).Imm(EtsConstants::TYPED_ARRAY_BYTE_OFFSET_OFFSET).f64
        byteOffset := Cast(byteOffsetF64).i32
        arrayDataOffset := AddI(byteOffset).Imm(Constants::ARRAY_DATA_OFFSET).i32
        offset0 := Add(arrayDataOffset, ShlI(startPos).Imm(scale).i32).i32
        offsetEnd := Add(arrayDataOffset, ShlI(endPos).Imm(scale).i32).i32

      Label(:Loop)
        offset := Phi(offset0, offset1).u32
        If(offset, offsetEnd).GE {
            Goto(:End)
        }
        Store(bufferData, offset, val).send(type)
        offset1 := AddI(offset).Imm(1 << scale).i32
        Goto(:Loop)

      Label(:End)
        ReturnVoid().void
      Label(:SlowPathEntrypoint)
        ep_offset = get_entrypoint_offset("#{prefix}_ARRAY_FILL_INTERNAL_USUAL")
        Intrinsic(:SLOW_PATH_ENTRY, arr, val, startPos, endPos).AddImm(ep_offset).MethodAsImm("#{name}ArrayFillInternalUsualBridge").Terminator.void
        Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
    }
end

GenerateTypedArrayFillInternal('Int8', 'INT8', 'i8', 0)
GenerateTypedArrayFillInternal('Int16', 'INT16', 'i16', 1)
GenerateTypedArrayFillInternal('Int32', 'INT32', 'i32', 2)
GenerateTypedArrayFillInternal('BigInt64', 'BIG_INT64', 'i64', 3)
GenerateTypedArrayFillInternal('Float32', 'FLOAT32', 'i32', 2)
GenerateTypedArrayFillInternal('Float64', 'FLOAT64', 'i64', 3)

def GenerateTypedUnsignedArrayFillInternal(name, prefix, inType, outType, scale)
    function("#{name}ArrayFillInternalFastPath".to_sym,
            params: {arr: 'ref', val: inType, startPos: 'i32', endPos: 'i32'},
            regmap: $full_regmap,
            regalloc_set: $panda_mask,
            mode: [:FastPath]) {

        if Options.arch == :arm32
            Intrinsic(:UNREACHABLE).Terminator.void
            next
        end
        buffer := LoadI(arr).Imm(EtsConstants::TYPED_UNSIGNED_ARRAY_BUFFER_OFFSET).ref
        bufferData := LoadI(buffer).Imm(EtsConstants::ARRAY_BUFFER_DATA_OFFSET).ref
        If(bufferData, 0).EQ.Unlikely {
          Goto(:SlowPathEntrypoint)
        }
        byteOffset := LoadI(arr).Imm(EtsConstants::TYPED_ARRAY_BYTE_OFFSET_OFFSET).i32
        arrayDataOffset := AddI(byteOffset).Imm(Constants::ARRAY_DATA_OFFSET).i32
        offset0 := Add(arrayDataOffset, ShlI(startPos).Imm(scale).i32).i32
        offsetEnd := Add(arrayDataOffset, ShlI(endPos).Imm(scale).i32).i32

      Label(:Loop)
        offset := Phi(offset0, offset1).u32
        If(offset, offsetEnd).GE {
            Goto(:End)
        }
        Store(bufferData, offset, val).send(outType)
        offset1 := AddI(offset).Imm(1 << scale).i32
        Goto(:Loop)

      Label(:End)
        ReturnVoid().void
      Label(:SlowPathEntrypoint)
        ep_offset = get_entrypoint_offset("#{prefix}_ARRAY_FILL_INTERNAL_USUAL")
        Intrinsic(:SLOW_PATH_ENTRY, arr, val, startPos, endPos).AddImm(ep_offset).MethodAsImm("#{name}ArrayFillInternalUsualBridge").Terminator.void
        Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
    }
end

GenerateTypedUnsignedArrayFillInternal('UInt8Clamped', 'U_INT8', 'i32', 'u8', 0)
GenerateTypedUnsignedArrayFillInternal('UInt8', 'U_INT8', 'i32', 'u8', 0)
GenerateTypedUnsignedArrayFillInternal('UInt16', 'U_INT16', 'i32', 'u16', 1)
GenerateTypedUnsignedArrayFillInternal('UInt32', 'U_INT32', 'i64', 'u32', 2)
GenerateTypedUnsignedArrayFillInternal('BigUInt64', 'BIG_U_INT64', 'i64', 'u64', 3)
