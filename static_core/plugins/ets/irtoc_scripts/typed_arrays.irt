# plugin typed_arrays
# Copyright (c) 2024-2026 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

include_relative 'common.irt'
include_relative '../../../irtoc/scripts/common.irt'
include_relative '../../../irtoc/scripts/string_helpers.irt'
include_relative '../../../irtoc/scripts/array_helpers.irt'

module Constants
  ARRAY_BUFFER_CLASS_SIZE = "cross_values::GetArrayBufferClassSize(GetArch())"
  ARRAY_BUFFER_BYTE_LENGTH_OFFSET =  "cross_values::GetArrayBufferByteLengthOffset(GetArch())"
  ARRAY_BUFFER_DATA_OFFSET = "cross_values::GetArrayBufferDataOffset(GetArch())"

  TYPED_UNSIGNED_ARRAY_BYTES_PER_ELEMENT_OFFSET = "cross_values::GetTypedUnsignedArrayBytesPerElementOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_BYTE_OFFSET_OFFSET = "cross_values::GetTypedUnsignedArrayByteOffsetOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_BYTE_LENGTH_OFFSET = "cross_values::GetTypedUnsignedArrayByteLengthOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_LENGTH_INT_OFFSET = "cross_values::GetTypedUnsignedArrayLengthIntOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_LENGTH_OFFSET = "cross_values::GetTypedUnsignedArrayLengthOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_CLASS_SIZE = "cross_values::GetTypedUnsignedArrayClassSize(GetArch())"
  TYPED_UNSIGNED_ARRAY_BUFFER_OFFSET = "cross_values::GetTypedUnsignedArrayBufferOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_CLASS_SIZE_WITH_ALIGNMENT = "cross_values::GetTypedUnsignedArrayClassSize(GetArch()) + TLAB_ALIGNMENT - 1"

  TYPED_ARRAY_BYTES_PER_ELEMENT_OFFSET = "cross_values::GetTypedArrayBytesPerElementOffset(GetArch())"
  TYPED_ARRAY_BYTE_OFFSET_OFFSET = "cross_values::GetTypedArrayByteOffsetOffset(GetArch())"
  TYPED_ARRAY_BYTE_LENGTH_OFFSET = "cross_values::GetTypedArrayByteLengthOffset(GetArch())"
  TYPED_ARRAY_LENGTH_INT_OFFSET = "cross_values::GetTypedArrayLengthIntOffset(GetArch())"
  TYPED_ARRAY_LENGTH_OFFSET = "cross_values::GetTypedArrayLengthOffset(GetArch())"
  TYPED_ARRAY_CLASS_SIZE = "cross_values::GetTypedArrayClassSize(GetArch())"
  TYPED_ARRAY_BUFFER_OFFSET = "cross_values::GetTypedArrayBufferOffset(GetArch())"
  TYPED_ARRAY_CLASS_SIZE_WITH_ALIGNMENT = "cross_values::GetTypedArrayClassSize(GetArch()) + TLAB_ALIGNMENT - 1"

  ETS_BIG_INT_BYTES_OFFSET = "cross_values::GetEtsBigIntBytesOffset(GetArch())"
  ETS_BIG_INT_SIGN_OFFSET = "cross_values::GetEtsBigIntSignOffset(GetArch())"
  ETS_BIG_INT_TO_LONG_SHIFT = "static_cast<uint64_t>(32U)"
  ETS_BIG_INT_TO_LONG_MASK = "((uint64_t{1U} << uint64_t{32U}) - uint64_t{1U})"
  LOG2_BYTES_PER_I32 = "2"
end

def GenerateTypedArrayFillInternal(name, prefix, type, outType, scale, cgmode)
    signed = (['i8', 'i16', 'i32', 'i64', 'f32', 'f64'].include?(outType) ? true : false)
    suffix = (cgmode == :NativePlus ? 'NativePlus' : '')
    function("#{name}ArrayFillInternal#{suffix}".to_sym,
            params: {arr: 'ref', val: type, startPos: 'i32', endPos: 'i32'},
            regmap: $full_regmap,
            regalloc_set: $panda_mask,
            mode: [cgmode]) {

        if Options.arch == :arm32
            Intrinsic(:UNREACHABLE).Terminator.void
            next
        end
        if signed
          buffer := LoadI(arr).Imm(Constants::TYPED_ARRAY_BUFFER_OFFSET).ref
        else
          buffer := LoadI(arr).Imm(Constants::TYPED_UNSIGNED_ARRAY_BUFFER_OFFSET).ref
        end
        bufferData := LoadI(buffer).Imm(Constants::ARRAY_BUFFER_DATA_OFFSET).ref
        If(bufferData, 0).EQ.Unlikely {
          Goto(:SlowPathEntrypoint)
        }
        if signed
          byteOffsetF64 := LoadI(arr).Imm(Constants::TYPED_ARRAY_BYTE_OFFSET_OFFSET).f64
          byteOffset := Cast(byteOffsetF64).i32
        else
          byteOffset := LoadI(arr).Imm(Constants::TYPED_UNSIGNED_ARRAY_BYTE_OFFSET_OFFSET).i32
        end
        arrayDataOffset := AddI(byteOffset).Imm(Constants::ARRAY_DATA_OFFSET).i32
        offset0 := Add(arrayDataOffset, ShlI(startPos).Imm(scale).i32).i32
        offsetEnd := Add(arrayDataOffset, ShlI(endPos).Imm(scale).i32).i32

      Label(:Loop)
        offset := Phi(offset0, offset1).u32
        If(offset, offsetEnd).GE {
            Goto(:End)
        }
        Store(bufferData, offset, val).send(outType)
        offset1 := AddI(offset).Imm(1 << scale).i32
        Goto(:Loop)

      Label(:SlowPathEntrypoint)
        if cgmode == :NativePlus
          Call(arr, val, startPos, endPos).Method("EtsEscompat#{name}ArrayFillInternal").void
          Goto(:End)
        else
          ep_offset = get_entrypoint_offset("#{prefix}_ARRAY_FILL_INTERNAL_USUAL")
          Intrinsic(:SLOW_PATH_ENTRY, arr, val, startPos, endPos).AddImm(ep_offset).MethodAsImm("#{name}ArrayFillInternalUsualBridge").Terminator.void
          Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
        end
      Label(:End)
        ReturnVoid().void
    }
end

GenerateTypedArrayFillInternal('Int8', 'INT8', 'i8', 'i8', 0, :FastPath)
GenerateTypedArrayFillInternal('Int16', 'INT16', 'i16', 'i16', 1, :FastPath)
GenerateTypedArrayFillInternal('Int32', 'INT32', 'i32', 'i32', 2, :FastPath)
GenerateTypedArrayFillInternal('BigInt64', 'BIG_INT64', 'i64', 'i64', 3, :FastPath)
GenerateTypedArrayFillInternal('Float32', 'FLOAT32', 'i32', 'i32', 2, :FastPath)
GenerateTypedArrayFillInternal('Float64', 'FLOAT64', 'i64', 'i64', 3, :FastPath)
GenerateTypedArrayFillInternal('Int8', 'INT8', 'i8', 'i8', 0, :NativePlus)
GenerateTypedArrayFillInternal('Int16', 'INT16', 'i16', 'i16', 1, :NativePlus)
GenerateTypedArrayFillInternal('Int32', 'INT32', 'i32', 'i32', 2, :NativePlus)
GenerateTypedArrayFillInternal('BigInt64', 'BIG_INT64', 'i64', 'i64', 3, :NativePlus)
GenerateTypedArrayFillInternal('Float32', 'FLOAT32', 'f32', 'f32', 2, :NativePlus)
GenerateTypedArrayFillInternal('Float64', 'FLOAT64', 'f64', 'f64', 3, :NativePlus)

GenerateTypedArrayFillInternal('UInt8Clamped', 'U_INT8_CLAMPED', 'i32', 'u8', 0, :FastPath)
GenerateTypedArrayFillInternal('UInt8', 'U_INT8', 'i32', 'u8', 0, :FastPath)
GenerateTypedArrayFillInternal('UInt16', 'U_INT16', 'i32', 'u16', 1, :FastPath)
GenerateTypedArrayFillInternal('UInt32', 'U_INT32', 'i64', 'u32', 2, :FastPath)
GenerateTypedArrayFillInternal('BigUInt64', 'BIG_U_INT64', 'i64', 'u64', 3, :FastPath)
GenerateTypedArrayFillInternal('UInt8Clamped', 'U_INT8_CLAMPED', 'i32', 'u8', 0, :NativePlus)
GenerateTypedArrayFillInternal('UInt8', 'U_INT8', 'i32', 'u8', 0, :NativePlus)
GenerateTypedArrayFillInternal('UInt16', 'U_INT16', 'i32', 'u16', 1, :NativePlus)
GenerateTypedArrayFillInternal('UInt32', 'U_INT32', 'i64', 'u32', 2, :NativePlus)
GenerateTypedArrayFillInternal('BigUInt64', 'BIG_U_INT64', 'i64', 'u64', 3, :NativePlus)

###
# Numbers in an instance of 'std.core.Array' are represented as an array of object pointers to instances of the
# boxing class 'std.core.Double' or 'std.core.Int'.
#
scoped_macro(:validate_number) do |data, offset, type_mask_value|
  _boxed_ptr := get_object_pointer(data, offset)
  _klass := load_class(_boxed_ptr)
  _flags := LoadI(_klass).Imm(EtsConstants::ETS_CLASS_FLAGS_FROM_RUNTIME_CLASS_OFFSET).u32
  If(getBoxedType(_flags), type_mask_value).EQ.Likely {
    _valid1 := Cast(1).b
    Goto(:Done)
  } Else {
    _valid2 := Cast(0).b
  }
  Label(:Done)
  Phi(_valid1, _valid2).b
end  # validate_number

###
# Numbers in an instance of 'std.core.Array' are represented as an array of object pointers to instances of the
# boxing class 'std.core.Double' or 'std.core.Int'. Runtime stores such objects as instances of the
# 'ark::ets::EtsBoxPrimitive' class and every instance has a field of type 'double' or 'int', the value.
#
# The macro reads the boxed value by an object pointer and applies unboxing.
#
scoped_macro(:load_number) do |data, offset, type|
  _boxed_ptr := get_object_pointer(data, offset)
  LoadI(_boxed_ptr).Imm(EtsConstants::BOX_PRIMITIVE_VALUE_OFFSET).send(type)
end  # load_number

["i8", "i16", "i32", "u8", "u16", "u32"].each do |tgt_type|
  scoped_macro("get_#{tgt_type}_from_number".to_sym) do |number|
    if tgt_type != 'i32'
      Cast(number).send(tgt_type)
    else
      number
    end
  end  # get_#{tgt_type}_from_number
end

scoped_macro("get_f32_from_number".to_sym) do |num|
  Cast(num).f32
end  # get_f64_from_number

scoped_macro("get_f64_from_number".to_sym) do |num|
  num
end  # get_f64_from_number

scoped_macro("clamp_u8_value".to_sym) do |int|
  If(int, Cast(0).i32).LT.Unlikely {
    _val1 := 0
  } Else {
    If(int, Cast(255).i32).GT.Unlikely {
      _val2 := 255
    } Else {
      _val0 := Cast(int).u8
    }
  }
  Phi(_val1, _val2, _val0).u8
end # clamp_u8_value

scoped_macro(:load_big_int) do |data, offset|
  get_object_pointer(data, offset)
end # load_big_int

###
# BigInt values in an instance of 'std.core.Array' are represented as an array of object pointers to instances of the
# class `BigInt` and a special bit is set for this class.
#
scoped_macro(:validate_big_int) do |data, offset|
  _object := load_big_int(data, offset)
  _klass := load_class(_object)
  _flags := LoadI(_klass).Imm(EtsConstants::ETS_CLASS_FLAGS_FROM_RUNTIME_CLASS_OFFSET).u32
  isBigIntType(_flags)
end # validate_big_int

scoped_macro(:get_long_from_big_int) do |object|
  _bytes := get_object_pointer_imm(object, Constants::ETS_BIG_INT_BYTES_OFFSET)
  _sign := Cast(LoadI(object).Imm(Constants::ETS_BIG_INT_SIGN_OFFSET).i32).i64
  _bytes_data := AddI(_bytes).Imm(Constants::ARRAY_DATA_OFFSET).ptr
  _bytes_length := LoadI(_bytes).Imm(Constants::ARRAY_LENGTH_OFFSET).u32
  _length1 := Cast(_bytes_length).u32
  _limit_len := Cast(2).u32
  If(_limit_len, _length1).BE {
    _length2 := _limit_len
  }
  _length := Phi(_length1, _length2).u32
  _i1 := Cast(0).u32
  _res1 := Cast(0).i64
Label(:Loop)
  _i := Phi(_i1, _i2).u32
  _res := Phi(_res1, _res2).i64
  If(_i, _length).AE.Unlikely {
    Goto(:LoopDone)
  }
  _int := Cast(Load(_bytes_data, ShlI(Cast(_i).u64).Imm(Constants::LOG2_BYTES_PER_I32).u64).u32).u64
  _masked := AndI(_int).Imm(Constants::ETS_BIG_INT_TO_LONG_MASK).u64
  _shift := Mul(Cast(_i).u64, Constants::ETS_BIG_INT_TO_LONG_SHIFT).u64
  _comp := Cast(Shl(_masked, _shift).u64).i64
  _res2 := Add(_res, _comp).i64
  _i2 := AddI(_i).Imm(1).u32
  Goto(:Loop)
Label(:LoopDone)
  Mul(_sign, _res).i64
end # get_long_from_big_int

scoped_macro(:get_ulong_from_big_int) do |object|
  Cast(get_long_from_big_int(object)).u64
end # get_ulong_from_big_int


def GenerateTypedArraySetValuesFromArray(name, etype, stype, elm_size, mode)
  if mode == "signed"
    prefix = "TYPED_ARRAY"
  else
    prefix = "TYPED_UNSIGNED_ARRAY"
  end

  function("#{name}ArraySetValuesFromArray".to_sym,
          params: {dest: 'ref', source: 'ref'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

    # Arm32 is not supported
    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).Terminator.void
      next
    end

    # load the source Array params
    source_array := get_object_pointer_imm(source, EtsConstants::ESCOMPAT_ARRAY_DATA_OFFSET)
    source_data := AddI(source_array).Imm(Constants::ARRAY_DATA_OFFSET).ptr
    source_length := LoadI(source).Imm(EtsConstants::ESCOMPAT_ARRAY_ACTUAL_LENGTH_OFFSET).u32

    # source.length == 0 - exit
    If(source_length, 0).EQ.Unlikely {
        Goto(:LoopDone)
    }

    # source.length > this.length (Out of range)
    dest_length := LoadI(dest).Imm(eval("Constants::#{prefix}_LENGTH_INT_OFFSET")).u32
    If(source_length, dest_length).GT.Unlikely {
      Goto(:SlowPathEntrypoint)
    }

    # load TypedArray params, ArrayBuffer and Array
    buffer := LoadI(dest).Imm(eval("Constants::#{prefix}_BUFFER_OFFSET")).ref
    packet := LoadI(buffer).Imm(Constants::ARRAY_BUFFER_DATA_OFFSET).ref
    If(packet, 0).EQ.Unlikely {
      Goto(:SlowPathEntrypoint)
    }
    dest_data := AddI(packet).Imm(Constants::ARRAY_DATA_OFFSET).ptr

    source_offset1 := Cast(0).u64
    dest_offset1 := Cast(0).u64
    source_byte_len := ShlI(Cast(source_length).u64).Imm(EtsConstants::OBJ_PTR_LOG2_SIZE).u64
Label(:Loop)
    source_offset := Phi(source_offset1, source_offset2).u64
    dest_offset := Phi(dest_offset1, dest_offset2).u64
    If(source_offset, source_byte_len).AE.Unlikely {
      Goto(:LoopDone)
    }

    if name == "BigInt64" || name == "BigUint64"
      valid := validate_big_int(source_data, source_offset)
    elsif name == "Float32" || name == "Float64"
      valid := validate_number(source_data, source_offset, Cast(EtsConstants::ETS_CLASS_BOXED_TYPE_DOUBLE_MASK_VALUE).u32)
    else
      valid := validate_number(source_data, source_offset, Cast(EtsConstants::ETS_CLASS_BOXED_TYPE_INT_MASK_VALUE).u32)
    end
    If(valid, 0).EQ.Unlikely {
      Goto(:SlowPathEntrypoint)
    }

    case name
    when "BigInt64"
      elem := get_long_from_big_int(load_big_int(source_data, source_offset).ptr)
    when "BigUint64"
      elem := get_ulong_from_big_int(load_big_int(source_data, source_offset).ptr)
    when "Uint8Clamped"
      elem := clamp_u8_value(load_number(source_data, source_offset, 'i32').i32)
    else
      elem := eval("get_#{etype}_from_number(load_number(source_data, source_offset, '#{stype}').#{stype})")
    end
    Store(dest_data, dest_offset, elem).send(etype)

    source_offset2 := AddI(source_offset).Imm(EtsConstants::OBJ_PTR_SIZE).u64
    dest_offset2 := AddI(dest_offset).Imm(elm_size).u64
    Goto(:Loop)
  Label(:LoopDone)

    ReturnVoid().void

  Label(:SlowPathEntrypoint)
    entrypoint = get_entrypoint_offset("#{name.gsub(/(.)([A-Z])/,'\1_\2').upcase}_ARRAY_SET_VALUES_FROM_ARRAY_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, dest, source).AddImm(entrypoint).MethodAsImm("#{name}ArraySetValuesFromArrayUsualBridge").Terminator.void
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  }
end

GenerateTypedArraySetValuesFromArray('Int8', 'i8', 'i32', 1, "signed")
GenerateTypedArraySetValuesFromArray('Int16', 'i16', 'i32', 2, "signed")
GenerateTypedArraySetValuesFromArray('Int32', 'i32', 'i32', 4, "signed")
GenerateTypedArraySetValuesFromArray('BigInt64', 'i64', '', 8, "signed")
GenerateTypedArraySetValuesFromArray('Float32', 'f32', 'f64', 4, "signed")
GenerateTypedArraySetValuesFromArray('Float64', 'f64', 'f64', 8, "signed")
GenerateTypedArraySetValuesFromArray('Uint8Clamped', 'u8', 'i32', 1, "unsigned")
GenerateTypedArraySetValuesFromArray('Uint8', 'u8', 'i32', 1, "unsigned")
GenerateTypedArraySetValuesFromArray('Uint16', 'u16', 'i32', 2, "unsigned")
GenerateTypedArraySetValuesFromArray('Uint32', 'u32', 'i32', 4, "unsigned")
GenerateTypedArraySetValuesFromArray('BigUint64', 'u64', '', 8, "unsigned")

def GenerateArrayCopyWithin(name, uname, type, scale)
    signed = (['i8', 'i16', 'i32', 'i64', 'f32', 'f64'].include?(type) ? true : false)
    function("Array#{name}CopyWithin".to_sym,
            params: {arr: 'ref', dst_start: 'u32', src_start: 'u32', count: 'u32'},
            regmap: $full_regmap,
            regalloc_set: $panda_mask,
            mode: [:FastPath]) {

        if Options.arch == :arm32
          Intrinsic(:UNREACHABLE).Terminator.void
          next
        end

        if signed
          buffer := LoadI(arr).Imm(Constants::TYPED_ARRAY_BUFFER_OFFSET).ref
        else
          buffer := LoadI(arr).Imm(Constants::TYPED_UNSIGNED_ARRAY_BUFFER_OFFSET).ref
        end

        bufferData := Cast(LoadI(buffer).Imm(Constants::ARRAY_BUFFER_DATA_OFFSET).ref).ptr
        If(bufferData, 0).EQ.Unlikely {
          Goto(:SlowPathEntrypoint)
        }

        if signed
          byteOffsetF64 := LoadI(arr).Imm(Constants::TYPED_ARRAY_BYTE_OFFSET_OFFSET).f64
          byteOffset := Cast(byteOffsetF64).u32
        else
          byteOffset := LoadI(arr).Imm(Constants::TYPED_UNSIGNED_ARRAY_BYTE_OFFSET_OFFSET).u32
        end

        arrayDataOffset := AddI(byteOffset).Imm(Constants::ARRAY_DATA_OFFSET).u32
        addr := Add(bufferData, Cast(arrayDataOffset).word).ptr
        do_array_copy_bare(1 << scale, scale, addr, dst_start, src_start, count, arr)
        Goto(:End)
      Label(:SlowPathEntrypoint)
        ep_offset = get_entrypoint_offset('ETS_ESCOMPAT_' + uname + '_ARRAY_COPY_WITHIN_IMPL_USUAL')
        ep_name = 'EtsEscompat' + name + 'ArrayCopyWithinImplUsualBridge'
        Intrinsic(:SLOW_PATH_ENTRY, arr, dst_start, src_start, count).AddImm(ep_offset).MethodAsImm(ep_name).Terminator.void
        Intrinsic(:UNREACHABLE).Terminator.ref if defines.DEBUG
     Label(:End)
     ReturnVoid().void
  }
end

GenerateArrayCopyWithin('Int8', 'INT8', 'i8', 0)
GenerateArrayCopyWithin('Int16', 'INT16', 'i16', 1)
GenerateArrayCopyWithin('Int32', 'INT32', 'i32', 2)
GenerateArrayCopyWithin('BigInt64', 'BIG_INT64', 'i64', 3)

GenerateArrayCopyWithin('UInt8', 'U_INT8', 'u8', 0)
GenerateArrayCopyWithin('UInt16', 'U_INT16', 'u''u16', 1)
GenerateArrayCopyWithin('UInt32', 'U_INT32', 'u32', 2)
GenerateArrayCopyWithin('BigUInt64', 'BIG_U_INT64', 'u64', 3)
