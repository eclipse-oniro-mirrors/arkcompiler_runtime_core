# plugin typed_arrays
# Copyright (c) 2024 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

include_relative 'common.irt'
include_relative '../../../irtoc/scripts/common.irt'
include_relative '../../../irtoc/scripts/string_helpers.irt'

module Constants
  ARRAY_BUFFER_CLASS_SIZE = "cross_values::GetArrayBufferClassSize(GetArch())"
  ARRAY_BUFFER_BYTE_LENGTH_OFFSET =  "cross_values::GetArrayBufferByteLengthOffset(GetArch())"
  ARRAY_BUFFER_DATA_OFFSET = "cross_values::GetArrayBufferDataOffset(GetArch())"
  ARRAY_BUFFER_NATIVE_DATA_OFFSET = "cross_values::GetArrayBufferNativeDataOffset(GetArch())"
  ARRAY_BUFFER_MANAGED_DATA_OFFSET = "cross_values::GetArrayBufferManagedDataOffset(GetArch())"
  ARRAY_BUFFER_IS_RESIZABLE_OFFSET = "cross_values::GetArrayBufferIsResizableOffset(GetArch())"
  ARRAY_BUFFER_CLASS_SIZE_WITH_ALIGNMENT = "cross_values::GetArrayBufferClassSize(GetArch()) + TLAB_ALIGNMENT - 1"

  TYPED_UNSIGNED_ARRAY_BYTES_PER_ELEMENT_OFFSET = "cross_values::GetTypedUnsignedArrayBytesPerElementOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_BYTE_OFFSET_OFFSET = "cross_values::GetTypedUnsignedArrayByteOffsetOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_BYTE_LENGTH_OFFSET = "cross_values::GetTypedUnsignedArrayByteLengthOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_LENGTH_INT_OFFSET = "cross_values::GetTypedUnsignedArrayLengthIntOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_LENGTH_OFFSET = "cross_values::GetTypedUnsignedArrayLengthOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_CLASS_SIZE = "cross_values::GetTypedUnsignedArrayClassSize(GetArch())"
  TYPED_UNSIGNED_ARRAY_BUFFER_OFFSET = "cross_values::GetTypedUnsignedArrayBufferOffset(GetArch())"
  TYPED_UNSIGNED_ARRAY_CLASS_SIZE_WITH_ALIGNMENT = "cross_values::GetTypedUnsignedArrayClassSize(GetArch()) + TLAB_ALIGNMENT - 1"

  TYPED_ARRAY_BYTES_PER_ELEMENT_OFFSET = "cross_values::GetTypedArrayBytesPerElementOffset(GetArch())"
  TYPED_ARRAY_BYTE_OFFSET_OFFSET = "cross_values::GetTypedArrayByteOffsetOffset(GetArch())"
  TYPED_ARRAY_BYTE_LENGTH_OFFSET = "cross_values::GetTypedArrayByteLengthOffset(GetArch())"
  TYPED_ARRAY_LENGTH_INT_OFFSET = "cross_values::GetTypedArrayLengthIntOffset(GetArch())"
  TYPED_ARRAY_LENGTH_OFFSET = "cross_values::GetTypedArrayLengthOffset(GetArch())"
  TYPED_ARRAY_CLASS_SIZE = "cross_values::GetTypedArrayClassSize(GetArch())"
  TYPED_ARRAY_BUFFER_OFFSET = "cross_values::GetTypedArrayBufferOffset(GetArch())"
  TYPED_ARRAY_CLASS_SIZE_WITH_ALIGNMENT = "cross_values::GetTypedArrayClassSize(GetArch()) + TLAB_ALIGNMENT - 1"

  ETS_BIG_INT_BYTES_OFFSET = "cross_values::GetEtsBigIntBytesOffset(GetArch())"
  ETS_BIG_INT_SIGN_OFFSET = "cross_values::GetEtsBigIntSignOffset(GetArch())"
  ETS_BIG_INT_TO_LONG_SHIFT = "static_cast<uint64_t>(32U)"
  ETS_BIG_INT_TO_LONG_MASK = "((uint64_t{1U} << uint64_t{32U}) - uint64_t{1U})"
  LOG2_BYTES_PER_I32 = "2"
end

def GenerateTypedArrayFillInternal(name, prefix, type, scale)
    function("#{name}ArrayFillInternalFastPath".to_sym,
            params: {arr: 'ref', val: type, startPos: 'i32', endPos: 'i32'},
            regmap: $full_regmap,
            regalloc_set: $panda_mask,
            mode: [:FastPath]) {

        if Options.arch == :arm32
            Intrinsic(:UNREACHABLE).Terminator.void
            next
        end
        buffer := LoadI(arr).Imm(Constants::TYPED_ARRAY_BUFFER_OFFSET).ref
        bufferData := LoadI(buffer).Imm(Constants::ARRAY_BUFFER_DATA_OFFSET).ref
        If(bufferData, 0).EQ.Unlikely {
          Goto(:SlowPathEntrypoint)
        }
        byteOffsetF64 := LoadI(arr).Imm(Constants::TYPED_ARRAY_BYTE_OFFSET_OFFSET).f64
        byteOffset := Cast(byteOffsetF64).i32
        arrayDataOffset := AddI(byteOffset).Imm(Constants::ARRAY_DATA_OFFSET).i32
        offset0 := Add(arrayDataOffset, ShlI(startPos).Imm(scale).i32).i32
        offsetEnd := Add(arrayDataOffset, ShlI(endPos).Imm(scale).i32).i32

      Label(:Loop)
        offset := Phi(offset0, offset1).u32
        If(offset, offsetEnd).GE {
            Goto(:End)
        }
        Store(bufferData, offset, val).send(type)
        offset1 := AddI(offset).Imm(1 << scale).i32
        Goto(:Loop)

      Label(:End)
        ReturnVoid().void
      Label(:SlowPathEntrypoint)
        ep_offset = get_entrypoint_offset("#{prefix}_ARRAY_FILL_INTERNAL_USUAL")
        Intrinsic(:SLOW_PATH_ENTRY, arr, val, startPos, endPos).AddImm(ep_offset).MethodAsImm("#{name}ArrayFillInternalUsualBridge").Terminator.void
        Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
    }
end

GenerateTypedArrayFillInternal('Int8', 'INT8', 'i8', 0)
GenerateTypedArrayFillInternal('Int16', 'INT16', 'i16', 1)
GenerateTypedArrayFillInternal('Int32', 'INT32', 'i32', 2)
GenerateTypedArrayFillInternal('BigInt64', 'BIG_INT64', 'i64', 3)
GenerateTypedArrayFillInternal('Float32', 'FLOAT32', 'i32', 2)
GenerateTypedArrayFillInternal('Float64', 'FLOAT64', 'i64', 3)

def GenerateTypedUnsignedArrayFillInternal(name, prefix, inType, outType, scale)
    function("#{name}ArrayFillInternalFastPath".to_sym,
            params: {arr: 'ref', val: inType, startPos: 'i32', endPos: 'i32'},
            regmap: $full_regmap,
            regalloc_set: $panda_mask,
            mode: [:FastPath]) {

        if Options.arch == :arm32
            Intrinsic(:UNREACHABLE).Terminator.void
            next
        end
        buffer := LoadI(arr).Imm(Constants::TYPED_UNSIGNED_ARRAY_BUFFER_OFFSET).ref
        bufferData := LoadI(buffer).Imm(Constants::ARRAY_BUFFER_DATA_OFFSET).ref
        If(bufferData, 0).EQ.Unlikely {
          Goto(:SlowPathEntrypoint)
        }
        byteOffset := LoadI(arr).Imm(Constants::TYPED_ARRAY_BYTE_OFFSET_OFFSET).i32
        arrayDataOffset := AddI(byteOffset).Imm(Constants::ARRAY_DATA_OFFSET).i32
        offset0 := Add(arrayDataOffset, ShlI(startPos).Imm(scale).i32).i32
        offsetEnd := Add(arrayDataOffset, ShlI(endPos).Imm(scale).i32).i32

      Label(:Loop)
        offset := Phi(offset0, offset1).u32
        If(offset, offsetEnd).GE {
            Goto(:End)
        }
        Store(bufferData, offset, val).send(outType)
        offset1 := AddI(offset).Imm(1 << scale).i32
        Goto(:Loop)

      Label(:End)
        ReturnVoid().void
      Label(:SlowPathEntrypoint)
        ep_offset = get_entrypoint_offset("#{prefix}_ARRAY_FILL_INTERNAL_USUAL")
        Intrinsic(:SLOW_PATH_ENTRY, arr, val, startPos, endPos).AddImm(ep_offset).MethodAsImm("#{name}ArrayFillInternalUsualBridge").Terminator.void
        Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
    }
end

GenerateTypedUnsignedArrayFillInternal('UInt8Clamped', 'U_INT8', 'i32', 'u8', 0)
GenerateTypedUnsignedArrayFillInternal('UInt8', 'U_INT8', 'i32', 'u8', 0)
GenerateTypedUnsignedArrayFillInternal('UInt16', 'U_INT16', 'i32', 'u16', 1)
GenerateTypedUnsignedArrayFillInternal('UInt32', 'U_INT32', 'i64', 'u32', 2)
GenerateTypedUnsignedArrayFillInternal('BigUInt64', 'BIG_U_INT64', 'i64', 'u64', 3)

# Try to allocate object in TLAB.
# The result is either a pointer to a new object or null if there is no enough space in TLAB.
macro(:allocate_object_tlab) do |klass, klass_size, data_size|
    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).Terminator.void
      ReturnVoid().void
      next
    end

    _data_size := Cast(data_size).word
    _klass_size_align := AddI(Cast(klass_size).word).Imm("TLAB_ALIGNMENT - 1").word
    _size_0 := AndI(_klass_size_align).Imm(Constants::ALIGNMENT_MASK).word
    If(_data_size, Cast(0).word).NE.Unlikely {
        _size_1 := Add(Add(_data_size, Cast(klass_size).word).word, "DEFAULT_ALIGNMENT_IN_BYTES - 1").word
        _size_1 := And(_size_1, "(~(DEFAULT_ALIGNMENT_IN_BYTES - 1))").word
    }
    _size := Phi(_size_0, _size_1).word

    # Load pointer to the TLAB from TLS
    _tlab := LoadI(%tr).Imm(Constants::TLAB_OFFSET).ptr
    # Load pointer to the start address of free memory in the TLAB
    _start := LoadI(_tlab).Imm(Constants::TLAB_CUR_FREE_POSITION_OFFSET).ptr
    # Load pointer to the end address of free memory in the TLAB
    _end := LoadI(_tlab).Imm(Constants::TLAB_MEMORY_END_ADDR_OFFSET).ptr
    # Check if there is enough space
    If(Sub(_end, _start).word, _size).B.Unlikely {
        Goto(:SlowPathEntrypoint)
    }
    Intrinsic(:WRITE_TLAB_STATS_SAFE, _start, _size, Cast(-1).u64).void if defines.DEBUG
    if defines.__SANITIZE_ADDRESS__ || defines.__SANITIZE_THREAD__
      call_runtime_save_all(Constants::ANNOTATE_SANITIZERS_NO_BRIDGE, _start, _size).void
    end
    # Store class of the object
    StoreI(_start, klass).Imm(Constants::OBJECT_CLASS_OFFSET).ref
    # Update the TLAB state
    StoreI(Add(_tlab, Constants::TLAB_CUR_FREE_POSITION_OFFSET).ptr, Add(_start, _size).ptr).Imm(0).Volatile.ptr
    # Return a pointer to the newly allocated string
    _allocated_object := _start
end

###
# Numbers in an instance of 'escompat.Array' are represented as an array of object pointers to instances of the
# boxing class 'std.core.Double' or 'std.core.Int'.
#
scoped_macro(:validate_number) do |data, offset, type_mask_value|
  _boxed_ptr := get_object_pointer(data, offset)
  _klass := LoadI(_boxed_ptr).Imm(Constants::OBJECT_CLASS_OFFSET).ref
  _flags := LoadI(_klass).Imm(EtsConstants::ETS_CLASS_FLAGS_FROM_RUNTIME_CLASS_OFFSET).u32
  If(getBoxedType(_flags), type_mask_value).EQ.Likely {
    _valid1 := Cast(1).b
    Goto(:Done)
  } Else {
    _valid2 := Cast(0).b
  }
  Label(:Done)
  Phi(_valid1, _valid2).b
end  # validate_number

###
# Numbers in an instance of 'escompat.Array' are represented as an array of object pointers to instances of the
# boxing class 'std.core.Double' or 'std.core.Int'. Runtime stores such objects as instances of the
# 'ark::ets::EtsBoxPrimitive' class and every instance has a field of type 'double' or 'int', the value.
#
# The macro reads the boxed value by an object pointer and applies unboxing.
#
scoped_macro(:load_number) do |data, offset, type|
  _boxed_ptr := get_object_pointer(data, offset)
  LoadI(_boxed_ptr).Imm(EtsConstants::BOX_PRIMITIVE_VALUE_OFFSET).send(type)
end  # load_number

["i8", "i16", "i32", "u8", "u16", "u32"].each do |tgt_type|
  scoped_macro("get_#{tgt_type}_from_number".to_sym) do |number|
    if tgt_type != 'i32'
      Cast(number).send(tgt_type)
    else
      number
    end
  end  # get_#{tgt_type}_from_number
end

scoped_macro("get_f32_from_number".to_sym) do |num|
  Cast(num).f32
end  # get_f64_from_number

scoped_macro("get_f64_from_number".to_sym) do |num|
  num
end  # get_f64_from_number

scoped_macro("clamp_u8_value".to_sym) do |int|
  If(int, Cast(0).i32).LT.Unlikely {
    _val1 := 0
  } Else {
    If(int, Cast(255).i32).GT.Unlikely {
      _val2 := 255
    } Else {
      _val0 := Cast(int).u8
    }
  }
  Phi(_val1, _val2, _val0).u8
end # clamp_u8_value

scoped_macro(:load_big_int) do |data, offset|
  get_object_pointer(data, offset)
end # load_big_int

###
# BigInt values in an instance of 'escompat.Array' are represented as an array of object pointers to instances of the
# class `BigInt` and a special bit is set for this class.
#
scoped_macro(:validate_big_int) do |data, offset|
  _object := load_big_int(data, offset)
  _klass := LoadI(_object).Imm(Constants::OBJECT_CLASS_OFFSET).ref
  _flags := LoadI(_klass).Imm(EtsConstants::ETS_CLASS_FLAGS_FROM_RUNTIME_CLASS_OFFSET).u32
  isBigIntType(_flags)
end # validate_big_int

scoped_macro(:get_long_from_big_int) do |object|
  _bytes := get_object_pointer_imm(object, Constants::ETS_BIG_INT_BYTES_OFFSET)
  _sign := Cast(LoadI(object).Imm(Constants::ETS_BIG_INT_SIGN_OFFSET).i32).i64
  _bytes_data := AddI(_bytes).Imm(Constants::ARRAY_DATA_OFFSET).ptr
  _bytes_length := LoadI(_bytes).Imm(Constants::ARRAY_LENGTH_OFFSET).u32
  _length1 := Cast(_bytes_length).u32
  _limit_len := Cast(2).u32
  If(_limit_len, _length1).LE {
    _length2 := _limit_len
  }
  _length := Phi(_length1, _length2).u32
  _i1 := Cast(0).u32
  _res1 := Cast(0).i64
Label(:Loop)
  _i := Phi(_i1, _i2).u32
  _res := Phi(_res1, _res2).i64
  If(_i, _length).AE.Unlikely {
    Goto(:LoopDone)
  }
  _int := Cast(Load(_bytes_data, ShlI(Cast(_i).u64).Imm(Constants::LOG2_BYTES_PER_I32).u64).u32).u64
  _masked := AndI(_int).Imm(Constants::ETS_BIG_INT_TO_LONG_MASK).u64
  _shift := Mul(Cast(_i).u64, Constants::ETS_BIG_INT_TO_LONG_SHIFT).u64
  _comp := Cast(Shl(_masked, _shift).u64).i64
  _res2 := Add(_res, _comp).i64
  _i2 := AddI(_i).Imm(1).u32
  Goto(:Loop)
Label(:LoopDone)
  Mul(_sign, _res).i64
end # get_long_from_big_int

scoped_macro(:get_ulong_from_big_int) do |object|
  Cast(get_long_from_big_int(object)).u64
end # get_ulong_from_big_int


def GenerateTypedArraySetValuesFromArray(name, etype, stype, elm_size, mode)
  if mode == "signed"
    prefix = "TYPED_ARRAY"
  else
    prefix = "TYPED_UNSIGNED_ARRAY"
  end

  function("#{name}ArraySetValuesFromArray".to_sym,
          params: {dest: 'ref', source: 'ref'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

    # Arm32 is not supported
    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).Terminator.void
      next
    end

    # load the source Array params
    source_array := get_object_pointer_imm(source, EtsConstants::ESCOMPAT_ARRAY_DATA_OFFSET)
    source_data := AddI(source_array).Imm(Constants::ARRAY_DATA_OFFSET).ptr
    source_length := LoadI(source).Imm(EtsConstants::ESCOMPAT_ARRAY_ACTUAL_LENGTH_OFFSET).u32

    # source.length == 0 - exit
    If(source_length, 0).EQ.Unlikely {
        Goto(:LoopDone)
    }

    # source.length > this.length (Out of range)
    dest_length := LoadI(dest).Imm(eval("Constants::#{prefix}_LENGTH_INT_OFFSET")).u32
    If(source_length, dest_length).GT.Unlikely {
      Goto(:SlowPathEntrypoint)
    }

    # load TypedArray params, ArrayBuffer and Array
    buffer := LoadI(dest).Imm(eval("Constants::#{prefix}_BUFFER_OFFSET")).ref
    packet := LoadI(buffer).Imm(Constants::ARRAY_BUFFER_DATA_OFFSET).ref
    If(packet, 0).EQ.Unlikely {
      Goto(:SlowPathEntrypoint)
    }
    dest_data := AddI(packet).Imm(Constants::ARRAY_DATA_OFFSET).ptr

    source_offset1 := Cast(0).u64
    dest_offset1 := Cast(0).u64
    source_byte_len := ShlI(Cast(source_length).u64).Imm(EtsConstants::LOG2_BYTES_PER_OBJ_PTR).u64
Label(:Loop)
    source_offset := Phi(source_offset1, source_offset2).u64
    dest_offset := Phi(dest_offset1, dest_offset2).u64
    If(source_offset, source_byte_len).AE.Unlikely {
      Goto(:LoopDone)
    }

    if name == "BigInt64" || name == "BigUint64"
      valid := validate_big_int(source_data, source_offset)
    elsif name == "Float32" || name == "Float64"
      valid := validate_number(source_data, source_offset, Cast(EtsConstants::ETS_CLASS_BOXED_TYPE_DOUBLE_MASK_VALUE).u32)
    else
      valid := validate_number(source_data, source_offset, Cast(EtsConstants::ETS_CLASS_BOXED_TYPE_INT_MASK_VALUE).u32)
    end
    If(valid, 0).EQ.Unlikely {
      Goto(:SlowPathEntrypoint)
    }

    case name
    when "BigInt64"
      elem := get_long_from_big_int(load_big_int(source_data, source_offset).ptr)
    when "BigUint64"
      elem := get_ulong_from_big_int(load_big_int(source_data, source_offset).ptr)
    when "Uint8Clamped"
      elem := clamp_u8_value(load_number(source_data, source_offset, 'i32').i32)
    else
      elem := eval("get_#{etype}_from_number(load_number(source_data, source_offset, '#{stype}').#{stype})")
    end
    Store(dest_data, dest_offset, elem).send(etype)

    source_offset2 := AddI(source_offset).Imm(EtsConstants::OBJ_PTR_SIZE).u64
    dest_offset2 := AddI(dest_offset).Imm(elm_size).u64
    Goto(:Loop)
  Label(:LoopDone)

    ReturnVoid().void

  Label(:SlowPathEntrypoint)
    entrypoint = get_entrypoint_offset("#{name.gsub(/(.)([A-Z])/,'\1_\2').upcase}_ARRAY_SET_VALUES_FROM_ARRAY_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, dest, source).AddImm(entrypoint).MethodAsImm("#{name}ArraySetValuesFromArrayUsualBridge").Terminator.void
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  }
end

GenerateTypedArraySetValuesFromArray('Int8', 'i8', 'i32', 1, "signed")
GenerateTypedArraySetValuesFromArray('Int16', 'i16', 'i32', 2, "signed")
GenerateTypedArraySetValuesFromArray('Int32', 'i32', 'i32', 4, "signed")
GenerateTypedArraySetValuesFromArray('BigInt64', 'i64', '', 8, "signed")
GenerateTypedArraySetValuesFromArray('Float32', 'f32', 'f64', 4, "signed")
GenerateTypedArraySetValuesFromArray('Float64', 'f64', 'f64', 8, "signed")
GenerateTypedArraySetValuesFromArray('Uint8Clamped', 'u8', 'i32', 1, "unsigned")
GenerateTypedArraySetValuesFromArray('Uint8', 'u8', 'i32', 1, "unsigned")
GenerateTypedArraySetValuesFromArray('Uint16', 'u16', 'i32', 2, "unsigned")
GenerateTypedArraySetValuesFromArray('Uint32', 'u32', 'i32', 4, "unsigned")
GenerateTypedArraySetValuesFromArray('BigUint64', 'u64', '', 8, "unsigned")
