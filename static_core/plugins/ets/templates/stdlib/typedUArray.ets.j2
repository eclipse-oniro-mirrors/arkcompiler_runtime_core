/*
 * Copyright (c) 2021-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file. DO NOT EDIT
package escompat;

// NOTE(kprokopenko): placing into std.core.Runtime breaks frontend
native function RuntimeGetPlatformIsLittleEndian(): boolean;

const IS_LITTLE_ENDIAN = RuntimeGetPlatformIsLittleEndian();

{%- for element in [{'name': 'Uint8Clamped', 'subsetType': 'number', 'subsetTypeValues': 'Number', 'etsType': 'int', 'bytes': 1, 'max': 255, 'min': 0, 'clamped': True},
                    {'name': 'Uint8',        'subsetType': 'number', 'subsetTypeValues': 'Number', 'etsType': 'int', 'bytes': 1},
                    {'name': 'Uint16',       'subsetType': 'number', 'subsetTypeValues': 'Number', 'etsType': 'int', 'bytes': 2},
                    {'name': 'Uint32',       'subsetType': 'number', 'subsetTypeValues': 'Number', 'etsType': 'long', 'bytes': 4},
                    {'name': 'BigUint64',    'subsetType': 'BigInt', 'subsetTypeValues': 'BigInt', 'etsType': 'long', 'bytes': 8}] %}
    {%- set _ = element.update({'subsetTypeBoxed':  element['subsetType'][0].upper() + element['subsetType'][1:], 'etsTypeBoxed':  element['etsType'][0].upper() + element['etsType'][1:]}) %}
    {%- set asElementCompat = ('%s as ' + element['subsetType']) if element['subsetType'] != 'BigInt' else 'new BigInt(%s)' %}
    {%- set fromElementCompat = ('%s as ' + element['etsType']) if element['subsetType'] != 'BigInt' else '%s.getULong()' %}
    {%- set numberBigIntToPrimitive = ('.' + element['etsType'] + 'Value()') if element['subsetType'] != 'BigInt' else '.getULong()' %}
    {%- set numberBigIntUndefToPrimitive = (numberBigIntToPrimitive) %}
    {%- set isNonCompat = '/* public */ internal' if element['subsetType'] != 'BigInt' else 'private' %}

class {{element['name']}}ArrayIteratorKeys implements IterableIterator<Number> {
    private length: int = 0
    private idx: int = 0

    constructor(parent: {{element['name']}}Array) {
        this.length = parent.length as int
    }

    public override iterator(): IterableIterator<Number> {
        return this;
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.idx++))
    }
}

class {{element['name']}}ArrayIterator implements IterableIterator<{{element['subsetTypeValues']}}> {
    private parent: {{element['name']}}Array
    private idx: int = 0

    constructor(parent: {{element['name']}}Array) {
        this.parent = parent
    }

    public override iterator(): IterableIterator<{{element['subsetTypeValues']}}> {
        return this;
    }

    override next(): IteratorResult<{{element['subsetTypeValues']}}> {
        if (this.idx < 0 || this.idx >= this.parent.lengthInt) {
            return new IteratorResult<{{element['subsetTypeValues']}}>()
        }
        return new IteratorResult<{{element['subsetTypeValues']}}>(false, new {{element['subsetTypeValues']}}(this.parent.getUnsafe(this.idx++)))
    }
}

/**
 * JS {{element['name']}}Array API-compatible class
 */
export class {{element['name']}}Array implements Iterable<{{element['subsetTypeValues']}}> {
    public static readonly BYTES_PER_ELEMENT: number = {{element['bytes']}}

    /** Underlying Buffer */
    public readonly buffer: ArrayBufferLike

    internal readonly byteOffsetInt: int
    internal readonly byteLengthInt: int
    internal readonly lengthInt: int

    /**
     * Creates an empty {{element['name']}}Array.
     */
    public constructor() {
        this(0 as int)
    }

    /**
     * Creates an {{element['name']}}Array with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<{{element['subsetTypeValues']}}>) {
        // NOTE (ikorobkov): dealing with this overload is tricky
        // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
        let arr = Array.from<{{element['subsetTypeValues']}}>(elements)
        this.byteLengthInt = arr.length as int * {{element['name']}}Array.BYTES_PER_ELEMENT as int
        this.lengthInt = arr.length as int
        this.buffer = new ArrayBuffer(this.byteLengthInt)
        this.byteOffsetInt = 0
        for (let i: int = 0; i < this.lengthInt; ++i) {
            {%- if element.get('clamped', False) %}
            this.setUnsafe(i, {{element['name']}}Array.clamp(arr.$_get(i){{numberBigIntUndefToPrimitive}}))
            {%- else %}
            this.setUnsafe(i, arr.$_get(i){{numberBigIntToPrimitive}})
            {%- endif %}
        }
    }

    /**
     * Creates an {{element['name']}}Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type {{element['etsType']}} in newly created {{element['name']}}Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.intValue()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int
        if (buf instanceof ArrayBuffer) {
            intByteLength = (buf as ArrayBuffer).getByteLength()
        } else if (buf instanceof SharedArrayBuffer) {
            intByteLength = (buf as SharedArrayBuffer).getByteLength()
        } else {
            throw new Error("unexpected type of ArrayBufferLike")
        }
        intByteLength = intByteLength - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }
{% if element.get('bytes') != 1 %}
        if (intByteLength % {{element['name']}}Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("ArrayBufferLike.byteLength should be multiple of {{element['bytes']}} as {{element['name']}}Array.BYTES_PER_ELEMENT")
        }
        if (intByteOffset % {{element['name']}}Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("byteOffset should be multiple of {{element['bytes']}} as {{element['name']}}Array.BYTES_PER_ELEMENT")
        }
{% endif %}
        let intLength: int
        if (length != undefined) {
            intLength = length.intValue()
            if (intLength > intByteLength / {{element['name']}}Array.BYTES_PER_ELEMENT as int) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / {{element['name']}}Array.BYTES_PER_ELEMENT as int
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / {{element['name']}}Array.BYTES_PER_ELEMENT as int) {
            intByteLength = intLength * {{element['name']}}Array.BYTES_PER_ELEMENT as int
        }
        this.byteLengthInt = intByteLength
        this.byteOffsetInt = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an {{element['name']}}Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined) {
        this(buf, byteOffset, undefined)
    }

    /**
     * Creates an {{element['name']}}Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type {{element['etsType']}} in newly created {{element['name']}}Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number, length: number) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an {{element['name']}}Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an {{element['name']}}Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type {{element['etsType']}} in newly created {{element['name']}}Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an {{element['name']}}Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an {{element['name']}}Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBufferLike) {
        if (buf instanceof ArrayBuffer) {
            this.byteLengthInt = (buf as ArrayBuffer).getByteLength()
            if (this.byteLengthInt % {{element['name']}}Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of {{element['etsType']}} as {{element['name']}}Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLengthInt / {{element['name']}}Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as ArrayBuffer
            this.byteOffsetInt = 0
        } else if (buf instanceof SharedArrayBuffer) {
            this.byteLengthInt = (buf as SharedArrayBuffer).getByteLength();
            if (this.byteLengthInt % {{element['name']}}Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of {{element['etsType']}} as {{element['name']}}Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLengthInt / {{element['name']}}Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as SharedArrayBuffer
            this.byteOffsetInt = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLengthInt = arr.length as int * {{element['name']}}Array.BYTES_PER_ELEMENT as int
            this.lengthInt = arr.length as int
            this.buffer = new ArrayBuffer(this.byteLengthInt)
            this.byteOffsetInt = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                {%- if element.get('clamped', False) %}
                this.setUnsafe(i, {{element['name']}}Array.clamp(arr.$_get(i).{{element['etsType']}}Value()))
                {%- else %}
                this.setUnsafe(i, arr.$_get(i).{{element['etsType']}}Value())
                {%- endif %}
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Creates an {{element['name']}}Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        if (length < 0) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length
        this.byteLengthInt = length * {{element['name']}}Array.BYTES_PER_ELEMENT as int
        this.byteOffsetInt = 0
        this.buffer = new ArrayBuffer(this.byteLengthInt)
    }

    /**
     * Creates an {{element['name']}}Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of {{element['name']}}Array.
     *
     * @param other data initializer
     */
    public constructor(other: {{element['name']}}Array) {
        if (other.buffer instanceof ArrayBuffer) {
            this.buffer = (other.buffer as ArrayBuffer).slice(0 as int, other.byteLength as int) as ArrayBuffer
        } else if (other.buffer instanceof SharedArrayBuffer) {
            this.buffer = (other.buffer as SharedArrayBuffer).slice(0 as int, other.byteLength as int) as SharedArrayBuffer
        } else {
            throw new Error("unexpected type of buffer")
        }
        this.byteLengthInt = other.byteLength as int
        this.lengthInt = other.length as int
        this.byteOffsetInt = 0
    }
{%- if element.get('name') != 'Uint8Clamped' %}{#- comment: Uint8Array and others, except Uint8Clamped #}

    internal zeroIfInfinity(val: {{element['subsetType']}}): {{element['subsetType']}} {
        {%- if element.get('subsetType') == 'number' %}
        if ((val == Infinity) || (val == -Infinity)) {
        {%- else %}
        if (({{fromElementCompat % 'val'}} == Infinity) || ({{fromElementCompat % 'val'}} == -Infinity)) {
        {%- endif %}
            return {{asElementCompat % '0'}}
        }
        return {{asElementCompat % 'val'}}
    }

    internal zeroIfInfinity(val: {{element['etsType']}}): {{element['etsType']}} {
        if ((val == Infinity) || (val == -Infinity)) {
            return 0 as {{element['etsType']}}
        }
        return val
    }
    {%- endif %}

    /**
     * Iteratorable interface implementation
     * @returns iterator over all elements
     */
    public override iterator(): IterableIterator<{{element['subsetTypeValues']}}> {
         return this.values()
    }

    /**
     * Iteratorable interface implementation
     * @returns iterator over all elements
     */
    public $_iterator(): IterableIterator<{{element['subsetTypeValues']}}> {
         return this.values()
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): {{element['subsetTypeBoxed']}} | undefined {
        return this.at(index as int)
    }

    /**
     * Returns an instance of primitive type at passed index if index is correct.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): {{element['subsetTypeBoxed']}} | undefined {
        let k: int;
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        {%- if element['subsetType'] == 'BigInt'%}
        return new BigInt(this.getUnsafe(k))
        {%- else %}
        return new Number(this.getUnsafe(k))
        {%- endif %}
    }

    /**
     * Returns an instance of {{element['subsetType']}} at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public $_get(index: number): {{element['subsetType']}} {
        return this.$_get(index as int)
    }

    /**
     * Returns an instance of {{element['subsetType']}} at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public $_get(i: int): {{element['subsetType']}} {
        if (i < 0 || i >= this.lengthInt) {
            throw new RangeError("invalid offset")
        }
        return {{asElementCompat % 'this.getUnsafe(i)'}}
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: {{element['subsetType']}}): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: {{element['subsetType']}}): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        {%- if element.get('name') != 'Uint8Clamped' %}
        let v = this.zeroIfInfinity(val)
        this.setUnsafeClamp(index, {{fromElementCompat % 'v'}})
        {%- else %}
        this.setUnsafeClamp(index, {{fromElementCompat % 'val'}})
        {%- endif %}
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: {{element['etsType']}}): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: {{element['etsType']}}): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        {%- if element.get('name') != 'Uint8Clamped' %}
        let v = this.zeroIfInfinity(val)
        this.setUnsafeClamp(index, v)
        {%- else %}
        this.setUnsafeClamp(index, val)
        {%- endif %}
    }
    {%- if element['etsType'] != 'int' %}

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: int): void {
        this.$_set(index as int, val as int)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: int): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        {%- if element.get('name') != 'Uint8Clamped' %}
        let v = this.zeroIfInfinity(val as {{element['etsType']}})
        this.setUnsafeClamp(index, v)
        {%- else %}
        this.setUnsafeClamp(index, val as {{element['etsType']}})
        {%- endif %}
    }
    {%- endif %}

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: number, end?: number): {{element['name']}}Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: number, end?: number): {{element['name']}}Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: int, end?: number): {{element['name']}}Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: number): {{element['name']}}Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param insert insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end: int): {{element['name']}}Array {
        let toPos = normalizeIndex(target, this.lengthInt)
        let fromPos = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        let count: int = finalPos - fromPos
        if (count > (this.lengthInt - toPos)) {
            count = this.lengthInt - toPos
        }
        let direction: int = 1
        if ((fromPos < toPos) && (toPos < fromPos + count)) {
            fromPos = fromPos + count - 1
            toPos   = toPos   + count - 1
            direction = -1
        }
        while (count > 0) {
            const value = this.getUnsafe(fromPos)
            this.setUnsafe(toPos, value)
            fromPos = fromPos + direction
            toPos = toPos + direction
            --count
        }
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of {{element['name']}}Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: number): {{element['name']}}Array {
        return this.copyWithin(target as int)
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of {{element['name']}}Array.
     *
     * @param insert insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): {{element['name']}}Array {
        return this.copyWithin(target, 0, this.lengthInt)
    }

    /**
     * Returns an iterator for all entries
     */
    // NOTE (ivan-tyulyandin): blocked by tuples implentation
    // public entries(): Iterator<[Int, Object]> {
    //     let ret: Entry<Int, Object> = new Entry<Int, Object>[this.lengthInt];
    //     for (let i: int = 0; i < this.lengthInt; i++) {
    //         ret[i] = new Entry<Int, Object>(i, this.at(i));
    //     }
    //     return new MapIterator<Int, Object>(ret);
    // }

    /**
     * Fills the {{element['name']}}Array with specified value
     *
     * @param value new value
     *
     * @returns modified {{element['name']}}Array
     */
    public fill(value: {{element['subsetType']}}, start?: number, end?: number): {{element['name']}}Array {
        return this.fill({{fromElementCompat % 'value'}}, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Fills the {{element['name']}}Array with specified value
     *
     * @param value new value
     *
     * @returns modified {{element['name']}}Array
     */
    public fill(value: {{element['subsetType']}}, start: int, end?: number): {{element['name']}}Array {
        return this.fill({{fromElementCompat % 'value'}}, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Fills the {{element['name']}}Array with specified value
     *
     * @param value new value
     *
     * @returns modified {{element['name']}}Array
     */
    public fill(value: {{element['subsetType']}}, start: int, end: number): {{element['name']}}Array {
        return this.fill({{fromElementCompat % 'value'}}, start as int, end as int)
    }

    /**
     * Fills the {{element['name']}}Array with specified value
     *
     * @param value new value
     *
     * @returns modified {{element['name']}}Array
     */
    public fill(value: {{element['subsetType']}}, start: number, end: int): {{element['name']}}Array {
        return this.fill({{fromElementCompat % 'value'}}, start as int, end as int)
    }

    /**
     * Fills the {{element['name']}}Array with specified value
     *
     * @param value new value
     *
     * @returns modified {{element['name']}}Array
     */
    public fill(value: {{element['subsetType']}}, start: int, end: int): {{element['name']}}Array {
        return this.fill({{fromElementCompat % 'value'}}, start as int, end as int)
    }

    /**
     * Fills the {{element['name']}}Array with specified value
     *
     * @param value new value
     *
     * @returns modified {{element['name']}}Array
     */
    public fill(value: {{element['etsType']}}, start?: number, end?: number): {{element['name']}}Array {
        return this.fill(value, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Fills the {{element['name']}}Array with specified value
     *
     * @param value new value
     *
     * @returns modified {{element['name']}}Array
     */
    public fill(value: {{element['etsType']}}, start: int, end?: number): {{element['name']}}Array {
        return this.fill(value, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Fills the {{element['name']}}Array with specified value
     *
     * @param value new value
     *
     * @returns modified {{element['name']}}Array
     */
    public fill(value: {{element['etsType']}}, start: int, end: number): {{element['name']}}Array {
        return this.fill(value, start as int, end as int)
    }

    /**
     * Fills the {{element['name']}}Array with specified value
     *
     * @param value new value
     *
     * @returns modified {{element['name']}}Array
     */
    public fill(value: {{element['etsType']}}, start: number, end: int): {{element['name']}}Array {
        return this.fill(value, start as int, end as int)
    }

    /**
     * Fills the {{element['name']}}Array with specified value
     *
     * @param value new value
     *
     * @returns modified {{element['name']}}Array
     */
    public fill(value: {{element['etsType']}}, start: int, end: int): {{element['name']}}Array {
        {%- if element.get('clamped', False) %}
        value = {{element['name']}}Array.clamp(value);
        {%- endif %}
        const k = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        for (let i: int = k; i < finalPos; ++i) {
            this.setUnsafe(i, value)
        }
        return this
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: number, val: {{element['subsetType']}}): void {
        this.$_set(insertPos as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: {{element['subsetType']}}): void {
        this.$_set(insertPos as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: number, val: {{element['etsType']}}): void {
        this.$_set(insertPos as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: {{element['etsType']}}): void {
        this.$_set(insertPos as int, val)
    }

    /**
     * Copies all elements of arr to the current {{element['name']}}Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: {{element['subsetType']}}[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: {{element['etsType']}}[]): size of arr is greater than {{element['name']}}Array.length")
        }
        for (let i = 0; i < arr.length; i++) {
        {%- if element.get('name') != 'Uint8Clamped' %}
            let v = this.zeroIfInfinity(arr[i])
            this.setUnsafeClamp(insertPos as int + i as int, {{fromElementCompat % 'v'}})
        {%- else %}
            this.setUnsafeClamp(insertPos as int + i as int, {{fromElementCompat % 'arr[i]'}})
        {%- endif %}
        }
    }

    /**
     * Copies all elements of arr to the current {{element['name']}}Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: {{element['etsType']}}[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: {{element['etsType']}}[]): size of arr is greater than {{element['name']}}Array.length")
        }
        for (let i = 0; i < arr.length; i++) {
        {%- if element.get('name') != 'Uint8Clamped' %}
            let v = this.zeroIfInfinity(arr[i])
            this.setUnsafeClamp(insertPos + i, v)
        {%- else %}
            this.setUnsafeClamp(insertPos + i, arr[i])
        {%- endif %}
        }
    }

    /**
     * Copies all elements of arr to the current {{element['name']}}Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: {{element['subsetType']}}[]): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current {{element['name']}}Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: {{element['etsType']}}[]): void {
        this.set(arr, 0)
    }


    /**
     * Copies elements from an ArrayLike object to the {{element['name']}}Array.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<{% if element['name'] == 'BigUint64' %}BigInt{% else %}number{% endif %}>, offset: number = 0): void {
        const insertPos = offset as int
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; i++) {
        {%- if element.get('name') != 'Uint8Clamped' %}
            let v = this.zeroIfInfinity(array[i])
            this.setUnsafeClamp(insertPos as int + i as int, {{fromElementCompat % 'v'}})
        {%- else %}
            this.setUnsafeClamp(insertPos as int + i as int, {{fromElementCompat % 'array[i]'}})
        {%- endif %}
        }
    }

    /**
     * Creates an array from an array-like or iterable object.
     * @param arrayLike An array-like or iterable object to convert to an array.
     * @returns new {{element['name']}}Array
     */
    public static from(arr: ArrayLike<{{element['subsetType']}}>): {{element['name']}}Array {
    {%- if element.get('name') != 'BigUint64' %}
        return {{element['name']}}Array.from<{{element['subsetType']}}>(arr, (x: {{element['subsetType']}}, k: number): {{element['subsetType']}} => x);
    {%- else %}
        throw new Error("{{element['name']}}Array.from: not implemented")
    {%- endif %}
    }
    
    /**
     * Creates an array from an array-like or iterable object.
     * @param arrayLike An array-like or iterable object to convert to an array.
     * @param mapfn A mapping function to call on every element of the array.
     * @returns new {{element['name']}}Array
     */
    public static from(arrayLike: Iterable<{{element['subsetType']}}>, mapfn?: (v: {{element['subsetType']}}, k: number) => {{element['subsetType']}}): {{element['name']}}Array {
    {%- if element.get('name') != 'BigUint64' %}   
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }
        // NOTE(aleksander-sotov): Reflection is used due to #15523
        const aType = Type.of(arrayLike) as ClassType
        const mNum = aType.getMethodsNum()
        let m: Method
        let i: long
        for (i = 0; i < mNum; i++) {
            m = aType.getMethod(i);
            if (m.getName() == "iterator" && !m.isStatic() && m.getType().getParametersNum() == 0) {
                break
            }
        }
        if (i == mNum) {
            throw new Error("failed to get iterator from iterable")
        }

        // Calc length of items inside arrayLike, save length into i variable
        i = 0
        let iter  = m.invoke(arrayLike, [])! as Iterator<number>
        while (true) {
            const v = iter.next()
            if (v.done) {
                break
            }
            i++
        }

        let res = new {{element['name']}}Array(i as int)
        i = 0
        iter = m.invoke(arrayLike, [])! as Iterator<number>
        while (true) {
            const v = iter.next()
            if (v.done) {
                return res
            }
        {%- if element.get('name') != 'Uint8Clamped' %}
            res.setUnsafeClamp(i as int, res.zeroIfInfinity((mapfn)!(v.value as number, i as number)) as {{element['etsType']}})
        {%- else %}
            res.setUnsafeClamp(i as int, (mapfn)!(v.value as number, i as number) as {{element['etsType']}})
        {%- endif %}
            i++
        }
    {%- else %}
        throw new Error("{{element['name']}}Array.from: not implemented");
    {%- endif %}
    }

    /**
     * Creates an array from an array-like or iterable object.
     * @param arrayLike An array-like or iterable object to convert to an array.
     * @param mapfn A mapping function to call on every element of the array.
     * @returns new {{element['name']}}Array
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => {{element['subsetType']}}): {{element['name']}}Array {
    {%- if element.get('name') != 'BigUint64' %}
        let res = new {{element['name']}}Array(arrayLike.length);
        let idx = new int[1];
        idx[0] = 0;
        const verifyCompiles: Iterable<T> = arrayLike
        // NOTE(aleksander-sotov): Reflection is used due to #15523
        const getIteratorFromIterable = (a: Object): Iterator<T> => {
            if (a instanceof String) {
                return (a as String).iterator() as Iterator<T>
            }
            const aType = Type.of(a) as ClassType
            const mNum = aType.getMethodsNum();
            for (let i = 0; i < mNum; i++) {
                const m = aType.getMethod(i);
                if (m.getName() == "iterator" && !m.isStatic() && m.getType().getParametersNum() == 0) {
                    return m.invoke(a, [])! as Iterator<T>
                }
            }
            throw new Error("failed to get iterator from iterable")
        }
        iteratorForEach(getIteratorFromIterable(arrayLike), (x: T): void => {
        {%- if element.get('name') != 'Uint8Clamped' %}
            res.setUnsafeClamp(idx[0] as int, res.zeroIfInfinity(mapfn(x as T, idx[0] as number)) as {{element['etsType']}})
        {%- else %}
            res.setUnsafeClamp(idx[0] as int, mapfn(x as T, idx[0] as number) as {{element['etsType']}})
        {%- endif %}
            idx[0] += 1;
        })
        return res;
    {%- else %}
        throw new Error("{{element['name']}}Array.from: not implemented");
    {%- endif %}
    }

    /**
     * Checks if specified argument is in {{element['name']}}Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in {{element['name']}}Array, false otherwise
     */
    public includes(e: {{element['subsetType']}}, fromIndex: number): boolean {
        return this.includes({{fromElementCompat % 'e'}}, fromIndex as int)
    }

    /**
     * Checks if specified argument is in {{element['name']}}Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in {{element['name']}}Array, false otherwise
     */
    public includes(e: {{element['etsType']}}, fromIndex: int): boolean {
        return this.indexOf(e, fromIndex) != -1
    }

    /**
     * Checks if specified argument is in {{element['name']}}Array
     *
     * @param e search element
     *
     * @returns true if e is in {{element['name']}}Array, false otherwise
     */
    public includes(e: {{element['subsetType']}}): boolean {
        return this.includes({{fromElementCompat % 'e'}}, 0)
    }

    /**
     * Checks if specified argument is in {{element['name']}}Array
     *
     * @param e search element
     *
     * @returns true if e is in {{element['name']}}Array, false otherwise
     */
    public includes(e: {{element['etsType']}}): boolean {
        return this.includes(e, 0)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: {{element['subsetType']}}, fromIndex: number): number {
        return this.indexOf({{fromElementCompat % 'e'}}, fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: {{element['etsType']}}, fromIndex: int): int {
        throw new Error("not implemented")
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: {{element['subsetType']}}): number {
        return this.indexOf({{fromElementCompat % 'e'}})
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: {{element['etsType']}}): int {
        return this.indexOf(e, 0)
    }

    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s?: String): string {
        if (s == undefined) {
            return this.join(",")
        }
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; i++) {
            res.append({{asElementCompat % 'this.getUnsafe(i)'}})
            res.append(s)
        }
        if (this.lengthInt > 0) {
            res.append({{asElementCompat % 'this.getUnsafe(this.lengthInt - 1)'}})
        }
        return res.toString()
    }

    /**
     * Returns keys of the {{element['name']}}Array
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<Number> {
        return new {{element['name']}}ArrayIteratorKeys(this)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: {{element['subsetType']}}, fromIndex: number): number {
        return this.lastIndexOf({{fromElementCompat % 'val'}}, fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: {{element['etsType']}}, fromIndex: int): number {
        if (fromIndex >= this.lengthInt) {
            fromIndex = this.lengthInt - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.lengthInt + fromIndex
        }

        for (let i = fromIndex; i >= 0; i--) {
            let tmp = this.at(i)
            if (tmp == undefined) {
                return -1 as number
            }
            if (tmp{{numberBigIntUndefToPrimitive}} == val) {
                return i as number
            }
        }
        return -1 as number
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: {{element['subsetType']}}): number {
        return this.lastIndexOf({{fromElementCompat % 'val'}}, this.lengthInt - 1)
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: {{element['etsType']}}): number {
        return this.lastIndexOf(val, this.lengthInt - 1)
    }

   /**
    * Creates a new {{element['name']}}Array using initializer
    *
    * @param data initializer
    *
    * @returns a new {{element['name']}}Array from data
    */
    public of(...data: {{element['subsetType']}}[]): {{element['name']}}Array {
        throw new Error("{{element['name']}}Array.of: not implemented")
    }

    /**
     * Creates a new {{element['name']}}Array using reversed data from the current one
     *
     * @returns a new {{element['name']}}Array using reversed data from the current one
     */
    public reverse(): {{element['name']}}Array {
        for (let i: int = 0; i < this.lengthInt / 2 as int; i++) {
            const tmp = this.getUnsafe(this.lengthInt - 1 - i)
            this.setUnsafe(this.lengthInt - 1 - i, this.getUnsafe(i))
            this.setUnsafe(i, tmp)
        }
        return this
    }

    /**
     * Creates a slice of current {{element['name']}}Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new {{element['name']}}Array with elements of current {{element['name']}}Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: number, end?: number): {{element['name']}}Array {
        return this.slice(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a slice of current {{element['name']}}Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new {{element['name']}}Array with elements of current {{element['name']}}Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): {{element['name']}}Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current {{element['name']}}Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new {{element['name']}}Array with elements of current {{element['name']}}Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: int): {{element['name']}}Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current {{element['name']}}Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new {{element['name']}}Array with elements of current {{element['name']}}Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: number): {{element['name']}}Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current {{element['name']}}Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new {{element['name']}}Array with elements of current {{element['name']}}Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): {{element['name']}}Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        if (this.buffer instanceof ArrayBuffer) {
            let buf = (this.buffer as ArrayBuffer).slice(relStart * {{element['name']}}Array.BYTES_PER_ELEMENT as int, relEnd * {{element['name']}}Array.BYTES_PER_ELEMENT as int) as ArrayBuffer
            return new {{element['name']}}Array(buf)
        } else if (this.buffer instanceof SharedArrayBuffer) {
            let buf = (this.buffer as SharedArrayBuffer).slice(relStart * {{element['name']}}Array.BYTES_PER_ELEMENT as int, relEnd * {{element['name']}}Array.BYTES_PER_ELEMENT as int) as SharedArrayBuffer
            return new {{element['name']}}Array(buf)
        } else {
            throw new Error("unexpected type of buffer")
        }
    }

    /**
     * Creates a slice of current {{element['name']}}Array using range [begin, this.lengthInt).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new {{element['name']}}Array with elements of current {{element['name']}}Array[begin, this.lengthInt)
     */
    public slice(begin: number): {{element['name']}}Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current {{element['name']}}Array using range [begin, this.lengthInt).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new {{element['name']}}Array with elements of current {{element['name']}}Array[begin, this.lengthInt)
     */
    public slice(begin: int): {{element['name']}}Array {
        return this.slice(begin, this.lengthInt)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted {{element['name']}}Array
     */
    public sort(): {{element['name']}}Array {
        let newF = (a: {{element['subsetType']}}, b: {{element['subsetType']}}): number => { throw new Error("not implemented") }
        return this.sort(newF)
    }

    /**
     * Creates a {{element['name']}}Array with the same underlying Buffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new {{element['name']}}Array with the same underlying Buffer
     */
    public subarray(begin?: number, end?: number): {{element['name']}}Array {
        return this.subarray(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a {{element['name']}}Array with the same underlying Buffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new {{element['name']}}Array with the same underlying Buffer
     */
    public subarray(begin: number, end: number): {{element['name']}}Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a {{element['name']}}Array with the same underlying Buffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new {{element['name']}}Array with the same underlying Buffer
     */
    public subarray(begin: number, end: int): {{element['name']}}Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a {{element['name']}}Array with the same underlying Buffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new {{element['name']}}Array with the same underlying Buffer
     */
    public subarray(begin: int, end: number): {{element['name']}}Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a {{element['name']}}Array with the same underlying Buffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new {{element['name']}}Array with the same underlying Buffer
     */
    public subarray(begin: int, end: int): {{element['name']}}Array {
        const len: int = this.length as int
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new {{element['name']}}Array(this.buffer, relStart * {{element['name']}}Array.BYTES_PER_ELEMENT as int, count)
    }

    /**
     * Creates a {{element['name']}}Array with the same Buffer
     *
     * @param begin start index, inclusive
     *
     * @returns new {{element['name']}}Array with the same Buffer
     */
    public subarray(begin: number): {{element['name']}}Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Creates a {{element['name']}}Array with the same Buffer
     *
     * @param begin start index, inclusive
     *
     * @returns new {{element['name']}}Array with the same Buffer
     */
    public subarray(begin: int): {{element['name']}}Array {
        return this.subarray(begin, this.lengthInt)
    }

    /**
     * Converts {{element['name']}}Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("{{element['name']}}Array.toLocaleString: not implemented")
    }

    /**
     * Converts {{element['name']}}Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts {{element['name']}}Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): {{element['name']}}Array {
        return new {{element['name']}}Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): {{element['name']}}Array {
        return new {{element['name']}}Array(this).sort()
    }

    /**
     * Returns a string representation of the {{element['name']}}Array
     *
     * @returns a string representation of the {{element['name']}}Array
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<{{element['subsetTypeValues']}}> {
         return new {{element['name']}}ArrayIterator(this);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an {{element['name']}}Array with replaced value on index
     */
    public with(index: number, value: {{element['subsetType']}}): {{element['name']}}Array {
        return this.with(index as int, {{fromElementCompat % 'value'}})
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an {{element['name']}}Array with replaced value on index
     */
    {{isNonCompat}} with(index: int, value: {{element['etsType']}}): {{element['name']}}Array {
        let res = new {{element['name']}}Array(this)
        res.setUnsafeClamp(index, value)
        return res
    }

    /// === with element lambda functions ===
    {#- NOTE: to add overloads with idxType == 'int' we need to enhance generics supports #}
    {%- for isEts in [False] %}
        {%- if isEts %}
            {%- set idxType, castToIdx = 'int', '' %}
            {%- set elType, castToEl, castFromEl = element['etsType'], '%s', '%s' %}
        {%- else %}
            {%- set idxType, castToIdx = 'number', ' as number' %}
            {%- set elType, castToEl, castFromEl = element['subsetType'], asElementCompat, fromElementCompat %}
        {%- endif %}

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts one argument.
     * The every method calls the predicate function for each element in the array until the predicate returns a false, 
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element, 
     * in which case false is immediately returned.
     */
    public every(predicate: (element: {{elType}}) => boolean): boolean {
        return this.every((element: {{elType}}, index: number, array: {{element['name']}}Array): boolean => predicate(element))
    }

    /**
     * creates a new {{element['name']}}Array from current {{element['name']}}Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new {{element['name']}}Array with elements from current {{element['name']}}Array that satisfy condition fn
     */
    public filter(fn: (val: {{elType}}) => boolean): {{element['name']}}Array {
        let newF: (val: {{elType}}, index: number, array: {{element['name']}}Array) => boolean =
            (val: {{elType}}, index: number, array: {{element['name']}}Array): boolean => { return fn(val) }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns {{elType}} | undefined
     */
    public find(predicate: () => boolean): {{elType}} | undefined {
        return this.find((value: {{elType}}, index: number, obj: {{element['name']}}Array): boolean => predicate())
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns {{elType}} | undefined
     */
    public find(predicate: (value: {{elType}}) => boolean): {{elType}} | undefined {
        return this.find((value: {{elType}}, index: number, obj: {{element['name']}}Array): boolean => predicate(value))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns {{idxType}}
     */
    public findIndex(predicate: (value: {{elType}}) => boolean): {{idxType}} {
        return this.findIndex((value: {{elType}}, index: number, obj: {{element['name']}}Array): boolean => predicate(value)){{castToIdx}}
    }

    /**
     * Finds the last element in the {{element['name']}}Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: {{elType}}) => boolean): {{elType}} {
        let newF: (val: {{elType}}, index: number, array: {{element['name']}}Array) => boolean =
            (val: {{elType}}, index: number, array: {{element['name']}}Array): boolean => { return fn(val) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the {{element['name']}}Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: {{elType}}) => boolean): {{idxType}} {
        let newF: (val: {{elType}}, index: number, array: {{element['name']}}Array) => boolean =
            (val: {{elType}}, index: number, array: {{element['name']}}Array): boolean => { return fn(val) }
        return this.findLastIndex(newF){{castToIdx}}
    }

    /**
     * Applies a function over all elements of {{element['name']}}Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: {{elType}}) => {{elType}}): void {
        let newF: (val: {{elType}}, index: number, array: {{element['name']}}Array) => {{elType}} =
            (val: {{elType}}, index: number, array: {{element['name']}}Array): {{elType}} => { return fn(val) }
        this.forEach(newF)
    }

    /**
     * Creates a new {{element['name']}}Array using fn(arr[i]) over all elements of current {{element['name']}}Array
     *
     * @param fn a function to apply for each element of current {{element['name']}}Array
     *
     * @returns a new {{element['name']}}Array where for each element from current {{element['name']}}Array fn was applied
     */
    public map(fn: (val: {{elType}}) => {{elType}}): {{element['name']}}Array {
        let newF: (val: {{elType}}, index: number) => {{elType}} =
            (val: {{elType}}, index: number): {{elType}} => { return fn(val) }
        return this.map(newF)
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * 
     * @param predicate A function that accepts one argument.
     * The some method calls the predicate function for each element in the array 
     * until the predicate returns a true or until the end of the array.
     * 
     * @returns false unless predicate function returns true for an array element, 
     * in which case true is immediately returned.
     */ 
    public some(predicate: (element: {{elType}}) => boolean): boolean {
        return this.some((element: {{elType}}, index: number, array: {{element['name']}}Array): boolean => predicate(element))
    }

    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted {{element['name']}}Array
     */
    public sort(fn: (a: {{elType}}, b: {{elType}}) => number): {{element['name']}}Array {
        let arr: {{element['etsType']}}[] = new {{element['etsType']}}[this.lengthInt]
        for (let i = 0; i < this.lengthInt; i++) {
            arr[i] = this.getUnsafe(i)
        }
        // NOTE(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        // let mustPrecede: (a: {{element['etsType']}}, b: {{element['etsType']}}) => boolean =
        //     (a: {{element['etsType']}}, b: {{element['etsType']}}): boolean => { return (fn(a, b) <= 0) }
        // sort(arr, mustPrecede)
        // for (let i = 0; i < this.lengthInt; i++) {
        //     this.setUnsafe(i, arr[i])
        // }
        return this;
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * 
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array 
     * until the predicate returns a true or until the end of the array.
     * 
     * @returns false unless predicate function returns true for an array element, 
     * in which case true is immediately returned.
     */ 
    public some(predicate: (element: {{elType}}, index: {{idxType}}, array: {{element['name']}}Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate({{castToEl % 'this.getUnsafe(i)'}}, i{{castToIdx}}, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * 
     * @param predicate A function that accepts two arguments.
     * The some method calls the predicate function for each element in the array 
     * until the predicate returns a true or until the end of the array.
     * 
     * @returns false unless predicate function returns true for an array element, 
     * in which case true is immediately returned.
     */ 
    public some(predicate: (element: {{elType}}, index: {{idxType}}) => boolean): boolean {
        return this.some((element: {{elType}}, index: number, array: {{element['name']}}Array): boolean => predicate(element, index))
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     * 
     * @param predicate A function that accepts no arguments.
     * The some method calls the predicate function for each element in the array 
     * until the predicate returns a true or until the end of the array.
     * 
     * @returns false unless predicate function returns true for an array element, 
     * in which case true is immediately returned.
     */ 
    public some(predicate: () => boolean): boolean {
        return this.some((element: {{elType}}, index: number, array: {{element['name']}}Array): boolean => predicate())
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = {{elType}}>(
                callbackfn: (previousValue: U, currentValue: {{elType}}, currentIndex: {{idxType}}, array: {{element['name']}}Array) => U, 
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, {{castToEl % 'this.getUnsafe(i)'}}, i{{castToIdx}}, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = {{elType}}>(
                callbackfn: (previousValue: U, currentValue: {{elType}}, currentIndex: {{idxType}}) => U, 
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevVal, currVal, currIndex), 
                initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = {{elType}}>(
                callbackfn: (previousValue: U, currentValue: {{elType}}) => U, 
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevVal, currVal), 
                initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = {{elType}}>(
                callbackfn: (previousValue: U) => U, 
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevVal), 
                initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = {{elType}}>(
                callbackfn: () => U, 
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(), 
                initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: {{elType}}, currentValue: {{elType}}, currentIndex: {{idxType}}, array: {{element['name']}}Array) => {{elType}}): {{elType}} {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = {{castToEl % 'this.$_get(0)'}}
        for (let i = 1; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, {{castToEl % 'this.getUnsafe(i)'}}, i{{castToIdx}}, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: {{elType}}, currentValue: {{elType}}, currentIndex: {{idxType}}) => {{elType}}): {{elType}} {
        return this.reduce(
                (prevVal: {{elType}}, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevVal, currVal, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: {{elType}}, currentValue: {{elType}}) => {{elType}}): {{elType}} {
        return this.reduce(
                (prevVal: {{elType}}, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevVal, currVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: {{elType}}) => {{elType}}): {{elType}} {
        return this.reduce(
                (prevVal: {{elType}}, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: () => {{elType}}): {{elType}} {
        return this.reduce(
                (prevVal: {{elType}}, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn())
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = {{elType}}>(
                callbackfn: (previousValue: U, currentValue: {{elType}}, currentIndex: {{idxType}}, array: {{element['name']}}Array) => U, 
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, {{castToEl % 'this.getUnsafe(i)'}}, i{{castToIdx}}, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = {{elType}}>(
                callbackfn: (previuosValue: U, currentValue: {{elType}}, currentIndex: {{idxType}}) => U, 
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevVal, currVal, currIndex), 
                initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = {{elType}}>(
                callbackfn: (previuosValue: U, currentValue: {{elType}}) => U, 
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevVal, currVal), 
                initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = {{elType}}>(
                callbackfn: (previuosValue: U) => U, 
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevVal), 
                initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = {{elType}}>(
                callbackfn: () => U, 
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(), 
                initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: {{elType}}, currentValue: {{elType}}, currentIndex: {{idxType}}, array: {{element['name']}}Array) => {{elType}}): {{elType}} {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }
        
        let accumulatedValue: {{elType}} = {{castToEl % 'this.$_get(this.lengthInt - 1)'}}
        for (let i = this.lengthInt - 2; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, {{castToEl % 'this.getUnsafe(i)'}}, i{{castToIdx}}, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: {{elType}}, currentValue: {{elType}}, currentIndex: {{idxType}}) => {{elType}}): {{elType}} {
        return this.reduceRight(
                (prevValue: {{elType}}, currValue: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevValue, currValue, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: {{elType}}, currentValue: {{elType}}) => {{elType}}): {{elType}} {
        return this.reduceRight(
                (prevValue: {{elType}}, currValue: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevValue, currValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: {{elType}}) => {{elType}}): {{elType}} {
        return this.reduceRight(
                (prevValue: {{elType}}, currValue: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn(prevValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: () => {{elType}}): {{elType}} {
        return this.reduceRight(
                (prevValue: {{elType}}, currValue: {{elType}}, currIndex: {{idxType}}, array: {{element['name']}}Array) => 
                        callbackfn())
    }

    /**
     * Creates a new {{element['name']}}Array using fn(arr[i]) over all elements of current {{element['name']}}Array.
     *
     * @param fn a function to apply for each element of current {{element['name']}}Array
     *
     * @returns a new {{element['name']}}Array where for each element from current {{element['name']}}Array fn was applied
     */
    public map(fn: (val: {{elType}}, index: {{idxType}}) => {{elType}}): {{element['name']}}Array {
        let resBuf = new ArrayBuffer(this.lengthInt * {{element['name']}}Array.BYTES_PER_ELEMENT as int)
        let res = new {{element['name']}}Array(resBuf)
        for (let i = 0; i < this.lengthInt; i++) {
            const fnRes = fn({{castToEl % 'this.getUnsafe(i)'}}, i{{castToIdx}});
            res.setUnsafeClamp(i, {{castFromEl % 'fnRes'}})
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments. 
     * The every method calls the predicate function for each element in the array until the predicate returns a false, 
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element, 
     * in which case false is immediately returned.
     */
    public every(predicate: (element: {{elType}}, index: {{idxType}}, array: {{element['name']}}Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (!predicate({{castToEl % 'this.getUnsafe(i)'}}, i{{castToIdx}}, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts two arguments. 
     * The every method calls the predicate function for each element in the array until the predicate returns a false, 
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element, 
     * in which case false is immediately returned.
     */
    public every(predicate: (element: {{elType}}, index: {{idxType}}) => boolean): boolean {
        return this.every((element: {{elType}}, index: number, array: {{element['name']}}Array): boolean => predicate(element, index))
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false, 
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element, 
     * in which case false is immediately returned.
     */
    public every(predicate: () => boolean): boolean {
        return this.every((element: {{elType}}, index: number, array: {{element['name']}}Array): boolean => predicate())
    }

    /**
     * Creates a new {{element['name']}}Array from current {{element['name']}}Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new {{element['name']}}Array with elements from current {{element['name']}}Array that satisfy condition fn
     */
    public filter(fn: (val: {{elType}}, index: {{idxType}}, array: {{element['name']}}Array) => boolean): {{element['name']}}Array {
        let markers = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; i++) {
            markers[i] = fn({{castToEl % 'this.getUnsafe(i)'}}, i{{castToIdx}}, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let res = new {{element['name']}}Array(resLen)
        for (let i = 0, j = 0; i < this.lengthInt; i++) {
            if (markers[i]) {
                res.setUnsafe(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new {{element['name']}}Array from current {{element['name']}}Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new {{element['name']}}Array with elements from current {{element['name']}}Array that satisfy condition fn
     */
    public filter(fn: (val: {{elType}}, index: {{idxType}}) => boolean): {{element['name']}}Array {
        let newF: (val: {{elType}}, index: number, array: {{element['name']}}Array) => boolean =
            (val: {{elType}}, index: number, array: {{element['name']}}Array): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns {{elType}} | undefined
     */
    public find(predicate: (value: {{elType}}, index: {{idxType}}, array: {{element['name']}}Array) => boolean): {{elType}} | undefined {
        for (let i = 0; i < this.lengthInt; i++) {
            let val = {{castToEl % 'this.getUnsafe(i)'}}
            if (predicate(val, i{{castToIdx}}, this)) {
                return val
            }
        }
        return undefined
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns {{elType}} | undefined
     */
    public find(predicate: (value: {{elType}}, index: {{idxType}}) => boolean): {{elType}} | undefined {
        return this.find((value: {{elType}}, index: number, obj: {{element['name']}}Array): boolean => predicate(value, index))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns {{idxType}}
     */
    public findIndex(predicate: (value: {{elType}}, index: {{idxType}}, obj: {{element['name']}}Array) => boolean): {{idxType}} {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate({{castToEl % 'this.getUnsafe(i)'}}, i{{castToIdx}}, this)) {
                return i{{castToIdx}}
            }
        }
        return -1{{castToIdx}}
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns {{idxType}}
     */
    public findIndex(predicate: (value: {{elType}}, index: {{idxType}}) => boolean): {{idxType}} {
        return this.findIndex((value: {{elType}}, index: number, obj: {{element['name']}}Array): boolean => predicate(value, index))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns {{idxType}}
     */
    public findIndex(predicate: () => boolean): {{idxType}} {
        return this.findIndex((value: {{elType}}, index: number, obj: {{element['name']}}Array): boolean => predicate())
    }

    /**
     * Finds the last element in the {{element['name']}}Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: {{elType}}, index: {{idxType}}, array: {{element['name']}}Array) => boolean): {{elType}} {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            let val = {{castToEl % 'this.getUnsafe(i)'}}
            if (fn(val, i{{castToIdx}}, this)) {
                return val
            }
        }
        throw new Error("{{element['name']}}Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the {{element['name']}}Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: {{elType}}, index: {{idxType}}) => boolean): {{elType}} {
        let newF: (val: {{elType}}, index: number, array: {{element['name']}}Array) => boolean =
            (val: {{elType}}, index: number, array: {{element['name']}}Array): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the {{element['name']}}Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: {{elType}}, index: {{idxType}}, array: {{element['name']}}Array) => boolean): {{idxType}} {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            if (fn({{castToEl % 'this.getUnsafe(i)'}}, i{{castToIdx}}, this)) {
                return i{{castToIdx}}
            }
        }
        return -1{{castToIdx}}
    }

    /**
     * Finds an index of the last element in the {{element['name']}}Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: {{elType}}, index: {{idxType}}) => boolean): {{idxType}} {
        let newF: (val: {{elType}}, index: number, array: {{element['name']}}Array) => boolean =
            (val: {{elType}}, index: number, array: {{element['name']}}Array): boolean => { return fn(val, index) }
        return this.findLastIndex(newF){{castToIdx}}
    }

    /**
     * Applies a function over all elements of {{element['name']}}Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: {{elType}}, index: {{idxType}}, array: {{element['name']}}Array) => {{elType}}): void {
        for (let i = 0; i < this.lengthInt; i++) {
            let tmp = fn({{castToEl % 'this.getUnsafe(i)'}}, i{{castToIdx}}, this)
            this.setUnsafeClamp(i, {{fromElementCompat % 'tmp'}})
        }
        //NOTE (ikorobkov): needs check the correctness of this function
        //throw new Error("{{element['name']}}Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of {{element['name']}}Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: {{elType}}, index: {{idxType}}) => {{elType}}): void {
        let newF: (val: {{elType}}, index: number, array: {{element['name']}}Array) => {{elType}} =
            (val: {{elType}}, index: number, array: {{element['name']}}Array): {{elType}} => { return fn(val, index) }
        this.forEach(newF)
    }

    {% endfor -%}

    /** Byte offset within the underlying Buffer */
    public get byteOffset(): number {
        return this.byteOffsetInt
    }

    /** Number of bytes used */
    public get byteLength(): number {
        return this.byteLengthInt
    }

    /** Number of {{element['etsType']}} stored in {{element['name']}}Array */
    public get length(): number {
        return this.lengthInt
    }

    /** String \"{{element['name']}}Array\" */
    public readonly name = "{{element['name']}}Array"

    private static clamp(val: {{element['etsType']}}): {{element['etsType']}} {
        {%- if element.get('clamped', False) %}
        if (val > {{element['max']}}) {
            val = {{element['max']}}
        } else if (val < {{element['min']}}) {
            val = {{element['min']}}
        }
        {%- endif %}
        return val;
    }

    internal setUnsafeClamp(insertPos: int, val: {{element['etsType']}}): void {
        {%- if element.get('clamped', False) %}
        val = {{element['name']}}Array.clamp(val);
        {%- endif %}
        this.setUnsafe(insertPos, val)
    }

    internal getUnsafe(index: int): {{element['etsType']}} {
        index = index * {{element['name']}}Array.BYTES_PER_ELEMENT as int + this.byteOffsetInt
        let res: {{element['etsType']}} = 0
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < {{element['name']}}Array.BYTES_PER_ELEMENT as int; i++) {
                    let el = (this.buffer as ArrayBuffer).at(index + i) as {{element['etsType']}}
                    el &= 0xff
                    res |= el << (8 * i)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < {{element['name']}}Array.BYTES_PER_ELEMENT as int; i++) {
                    let el = (this.buffer as SharedArrayBuffer).at(index + i) as {{element['etsType']}}
                    el &= 0xff
                    res |= el << (8 * i)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < {{element['name']}}Array.BYTES_PER_ELEMENT as int; i++) {
                    let el = (this.buffer as ArrayBuffer).at(index + {{element['bytes'] - 1}} - i) as {{element['etsType']}}
                    el &= 0xff
                    res |= el << (8 * i)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < {{element['name']}}Array.BYTES_PER_ELEMENT as int; i++) {
                    let el = (this.buffer as SharedArrayBuffer).at(index + {{element['bytes'] - 1}} - i) as {{element['etsType']}}
                    el &= 0xff
                    res |= el << (8 * i)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        }
        return res;
    }

    internal setUnsafe(index: int, val: {{element['etsType']}}): void {
        index = index * {{element['name']}}Array.BYTES_PER_ELEMENT as int + this.byteOffsetInt;
        let res: {{element['etsType']}} = 0;
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < {{element['name']}}Array.BYTES_PER_ELEMENT as int; i++) {
                    (this.buffer as ArrayBuffer).set(index + i, (val & 0xff) as byte);
                    val = val >> 8;
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < {{element['name']}}Array.BYTES_PER_ELEMENT as int; i++) {
                    (this.buffer as SharedArrayBuffer).set(index + i, (val & 0xff) as byte);
                    val = val >> 8;
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < {{element['name']}}Array.BYTES_PER_ELEMENT as int; i++) {
                    (this.buffer as ArrayBuffer).set(index + {{element['bytes'] - 1}} - i, (val & 0xff) as byte);
                    val = val >> 8;
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < {{element['name']}}Array.BYTES_PER_ELEMENT as int; i++) {
                    (this.buffer as SharedArrayBuffer).set(index + {{element['bytes'] - 1}} - i, (val & 0xff) as byte);
                    val = val >> 8;
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        }
    }
}
{% endfor -%}
