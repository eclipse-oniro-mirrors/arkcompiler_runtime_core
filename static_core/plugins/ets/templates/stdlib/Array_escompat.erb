/*
 * Copyright (c) 2021-2026 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Defines the Array for ArkTS
 * @kit ArkTS
 */

package std.core;

// NOTE: autogenerated file

 // NOTE(zaytsevaekaterina): fix in #26615
class ArrayKeysIterator<T> implements IterableIterator<number> {
    private parent: Array<T>
    private idx: int = 0
    private isDone: boolean = false

    constructor(parent: Array<T>) {
        this.parent = parent
    }

    override next(): IteratorResult<number> {
        if (this.isDone || this.idx >= this.parent.length) {
            this.isDone = true
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>((this.idx++).toDouble())
    }

    override $_iterator(): IterableIterator<number> {
        return this
    }
}

class FromBuffer {}
// initialized in _initializerBlock_.ets
const FROM_BUFFER: FromBuffer;

/**
 * Defines arrType for Array
 * 
 * @typedef { String | undefined } arrType
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
type arrType = String | undefined;

/**
 * Represents a Array.
 * 
 * @class Array
 * @implements ReadonlyArray<T>, Iterable<T>
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export class Array<T> implements ReadonlyArray<T>, Iterable<T> {
    private buffer: FixedArray<Any>
    protected actualLength: int
    private static INIT_CAPACITY: int = 4

    /**
     * Get the length of the array.
     *
     * @returns { int } The length of the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    override get length(): int {
        return this.actualLength
    }

    /**
     * Set the length of the array.
     *
     * @param { int } newLen The new length of the array.
     * @returns { void }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    set length(newLen: int) {
        const len = newLen
        if (len < 0 || len > this.actualLength) {
            throw new RangeError("can't change length to bigger or negative")
        }
        if (len == 0) {
            this.buffer = new FixedArray<Any>(Array.INIT_CAPACITY)
        } else {
            const other = this.slice(0, len)
            this.buffer = other.buffer
        }
        this.actualLength = len
    }

    /**
     * Get the element at the specified index.
     *
     * @param { int } idx The index of the element to get.
     * @returns { T } The element at the specified index.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override native $_get(idx: int): T;

    private final native $_get_unsafe(idx: int): T

    /**
     * Set the element at the specified index.
     *
     * @param { int } idx The index of the element to set.
     * @param { T } val The value to set at the specified index.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_set(idx: int, val: T): void;

    private final native $_set_unsafe(idx: int, val: T | undefined): void

    /**
     * Creates a new instance of Array with the specified initial length.
     *
     * @param { int } arrayLen The initial length of the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(arrayLen: int) {
        this.buffer = new FixedArray<Any>(arrayLen)
        this.actualLength = arrayLen
    }

    private constructor(_tag: FromBuffer, buf: FixedArray<Any>) {
        this.buffer = buf
        this.actualLength = buf.length
    }

    /**
     * Creates a new empty instance of Array.
     *
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor() {
        this.buffer = new FixedArray<Any>(Array.INIT_CAPACITY)
        this.actualLength = 0
    }

    /**
     * Creates a new instance of Array with the given elements.
     *
     * @param { T } first The first element of the array.
     * @param { T[] } d The rest of the elements to initialize the array with.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(first: T, ...d: T[]) {
        this.buffer = new FixedArray<Any>(d.length + 1)
        this.actualLength = d.length + 1
        this.buffer[0] = first

        for (let k: int = 0; k < d.length; k++) {
            this.$_set_unsafe(k + 1, d[k])
        }
    }

    /**
     * Creates a new instance of Array with a specific length and initializes each element using a function.
     *
     * @param { int } arrayLen The amount of elements in the array.
     * @param { function } initializer A function that generates an element for a given index.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(arrayLen: int, initializer: (index: int) => T) {
        this.buffer = new FixedArray<Any>(arrayLen)
        this.actualLength = arrayLen
        for (let k: int = 0; k < arrayLen; k++) {
            this.$_set_unsafe(k, initializer(k))
        }
    }

    /**
     * Creates a new Array of the specified length, filled with the specified initial value.
     *
     * @param { int } arrayLength The amount of elements in the new array.
     * @param { T } initialValue The value to fill the array with.
     * @returns { Array<T> } A new Array instance filled with the initial value.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static create<T>(arrayLength: int, initialValue: T): Array<T> {
        let other = new Array<T>(arrayLength)
        other.fill(initialValue)
        return other
    }

    /**
     * Extends the Array with new elements up to the specified length.
     *
     * @param { int } arrayLength The new length of the array.
     * @param { T } initialValue The initial value for the added elements.
     * @throws { RangeError } Throws a RangeError if the array length is negative.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public extendTo(arrayLength: int, initialValue: T): void {
        if(arrayLength < 0){
            throw new RangeError("Parameter error.Invalid array length.")
        }
        const delta: int = arrayLength - this.actualLength
        if (delta <= 0) {
            return
        }
        this.ensureUnusedCapacity(delta)
        for (let i: int = 0; i < delta; i++) {
            this.buffer[this.actualLength + i] = initialValue
        }
        this.actualLength = arrayLength
    }

    /**
     * Shrinks the Array to the specified length. Elements beyond the new length are removed.
     *
     * @param { int } arrayLength The length at which to shrink the array.
     * @throws { RangeError } Throws a RangeError if the array length is negative.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public shrinkTo(arrayLength: int): void {
        if(arrayLength < 0){
            throw new RangeError("Parameter error.Invalid array length.")
        }
        if (arrayLength >= this.actualLength) {
            return
        }
        let newLen: int = arrayLength
        if (newLen < 0) {
            // Convert from signed to unsigned
            newLen = newLen & Int.MAX_VALUE
        }
        const other = this.slice(0, newLen)
        this.buffer = other.buffer
        this.actualLength = other.actualLength
    }

    /**
     * Creates a new empty instance of Array.
     *
     * @returns { Array<T> } A new Array instance.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     * @example
     * ```arkts
     * // Using the constructor
     * const a = new Array<number>();
     *
     * // Using the invoke overload (behaves like calling Array() as a function)
     * const b = Array<number>();
     * ```
     */
    static $_invoke<T>(): Array<T> {
        return new Array<T>();
    }

    /**
     * Creates a new instance of an Array with the specified length.
     *
     * @param { int } [arrayLength] The length of the array to be created (optional).
     * @returns { Array<T> } A new Array instance with the specified length.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     * @example
     * ```arkts
     * // Constructor form
     * const a = new Array<number>(3); // length = 3
     *
     * // Invoke overload form (Array() as a function)
     * const b = Array<number>(3);     // also creates an array of length 3
     * ```
     */
    static $_invoke<T>(arrayLength?: int): Array<T> {
        if (arrayLength != undefined) {
            return new Array<T>(arrayLength);
        } else {
            return new Array<T>();
        }
    }

    /**
     * Creates a new instance of Array with the given elements.
     *
     * @param { T[] } items The elements to initialize the array with.
     * @returns { Array<T> } A new Array instance with the given elements.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     * @example
     * ```arkts
     * // Constructor form
     * const a = new Array(1, 2, 3);
     *
     * // Invoke overload form (Array() as a function)
     * const b = Array(1, 2, 3);
     * ```
     */
    static $_invoke<T>(...items: T[]): Array<T> {
        if (items.length == 0) {
            return new Array<T>(0)
        }
        return new Array<T>(items[0], ...items.slice(1))
    }

    /**
     * Creates a new `Array` instance from a `FixedArray`.
     *
     * @param { FixedArray<T> } arr The source primitive array.
     * @returns { Array<T> } A new Array instance containing the elements from the source array.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(arr: FixedArray<T>): Array<T> {
        const len: int = arr.length
        const ret: FixedArray<Any> = new FixedArray<Any>(len)
        for (let i: int = 0; i < len; i++) {
            ret[i] = arr[i]
        }
        return new Array<T>(FROM_BUFFER, ret)
    }

    /**
     * Creates a new `Array` instance from an `ArrayLike` object.
     *
     * @param { ArrayLike<T> } arr An array-like object to convert to an array.
     * @returns { Array<T> } A new Array instance containing the elements from the array-like object.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(arr: ArrayLike<T>): Array<T> {
        const ret: Array<T> = new Array<T>(arr.length)
        let i: int = 0
        iteratorForEach<T>(arr.$_iterator(), (x: T): void => {
            ret[i] = x
            i += 1
        })
        return ret
    }

    /**
     * Creates a new `Array` instance from an iterable or array-like object.
     *
     * @param { ArrayLike<T> | Iterable<T> } iterable An iterable or array-like object to convert to an array.
     * @returns { Array<T> } A new Array instance containing the elements from the iterable.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(iterable: ArrayLike<T> | Iterable<T>): Array<T> {
        const ret = new Array<T>()
        iteratorForEach<T>(iterable.$_iterator(), (x: T): void => {
            ret.push(x)
        })
        return ret
    }

    /**
     * Creates a new `Array` instance from a `FixedArray` and applies a mapping function to each element.
     *
     * @param { FixedArray<T> } values The source primitive array.
     * @param { function } mapfn A mapping function to call on every element of the array.
     * @returns { Array<U> } A new Array instance with the mapped values.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T, U>(values: FixedArray<T>, mapfn: (v: T, k: int) => U): Array<U> {
        const length: int = values.length
        const ret: Array<U> = new Array<U>(length)
        for (let i: int = 0; i < length; ++i) {
            ret[i] = mapfn(values[i], i)
        }
        return ret
    }

    /**
     * Creates a new `Array` instance from an iterable object, applying a mapping function to each element.
     * Every value to be added to the array is first passed through this function, and `mapfn`'s return value is added
     * to the array instead.
     *
     * @param { ArrayLike<T> | Iterable<T> } iterable An iterable or array-like object to convert to an array.
     * @param { function } mapfn A mapping function to call on every element of the array.
     * @returns { Array<U> } A new Array instance with the mapped values.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T, U>(iterable: ArrayLike<T> | Iterable<T>, mapfn: (v: T, k: int) => U): Array<U> {
        const ret: Array<U> = new Array<U>()
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new FixedArray<int>(1)
        idx[0] = 0
        iteratorForEach<T>(iterable.$_iterator(), (x: T): void => {
            ret.push(mapfn(x, idx[0]))
            idx[0] += 1
        })
        return ret
    }

    private searchUndefined(fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (this.$_get_unsafe(i) instanceof undefined) {
                return true
            }
        }
        return false
    }

    private searchNull(fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (this.$_get_unsafe(i) instanceof null) {
                return true
            }
        }
        return false
    }

    private searchString(val: String, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof String) {
                if (tmp == val) {
                    return true
                }
            }
        }
        return false
    }

    private searchDouble(val: double, fi: int, len: int): boolean {
        if (isNaN(val)) {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Double) {
                    if (isNaN(tmp)) {
                        return true
                    }
                }
            }
        } else {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Double) {
                    if (val == tmp) {
                        return true
                    }
                }
            }
        }
        return false
    }

    private searchFloat(val: Float, fi: int, len: int): boolean {
        if (isNaN(val)) {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Float) {
                    if (isNaN(tmp)) {
                        return true
                    }
                }
            }
        } else {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Float) {
                    if (val == tmp) {
                        return true
                    }
                }
            }
        }
        return false
    }

    private searchLong(val: Long, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Long) {
                if (tmp == val) {
                    return true
                }
            }
        }
        return false
    }

    private searchInt(val: Int, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Int) {
                if (tmp == val) {
                    return true
                }
            }
        }
        return false
    }

    private searchCommon(val: T, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (val == this.$_get_unsafe(i)) {
                return true;
            }
        }
        return false
    }

    /**
     * Default comparison function for sort algorithm.
     * Objects are compared as string. Both objects are converted to string
     * using `toString()` method and compared using `compareTo()` method of `String` class.
     *
     * @param { Any } a Object to be compared.
     * @param { Any } b Object to be compared.
     * @returns { int } One of -1 (less), 0 (equal), or 1 (greater).
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private static defaultComparator(a: Any, b: Any): int {
        if (a instanceof Number && b instanceof Number) {
            const x = a
            const y = b
            if (Number.isInteger(x) && Number.isInteger(y) &&
                x <= Int.MAX_VALUE / 128 && x >= Int.MIN_VALUE / 128 &&
                y <= Int.MAX_VALUE / 128 && y >= Int.MIN_VALUE / 128) {
                let z = x.toInt()
                let w = y.toInt()
                return Array.defaultComparatorInts(z, w)
            }
        } else if (a instanceof String && b instanceof String) {
            return a.compareTo(b)
        }
        let sa = new String(a)
        let sb = new String(b)
        return sa.compareTo(sb)
    }

    private static defaultComparatorInts(a: int, b: int): int {
        if (a < 0) {
            if (b >= 0) {
                return -1
            }
            a *= -1
            b *= -1
        } else if (b < 0) {
            return 1
        }
        let aDigs = 1
        while (10 * aDigs <= a) {
            aDigs *= 10
        }
        let bDigs = 1
        while (10 * bDigs <= b) {
            bDigs *= 10
        }

        while (aDigs > 0 && bDigs > 0) {
            let r = (a / aDigs) - (b / bDigs)
            if (r != 0) {
                return r
            }
            aDigs /= 10
            bDigs /= 10
        }
        return (aDigs - bDigs)
    }

    private static defaultComparatorStr(a: String, b: String) {
        return a.compareTo(b)
    }

    /**
     * Helper function preparing copy of `this` instance of `Array` class' data array.
     *
     * @returns { FixedArray<Any> } Copy of this Array's primitive buffer.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private copyArray(): FixedArray<Any> {
        let len: int = this.actualLength
        let res : FixedArray<Any> = new FixedArray<Any>(len)
        for (let i = 0; i < len; i++) {
            res[i] = this.$_get_unsafe(i)
        }
        return res
    }

    private wrap_default_sort(): void {
        let idxNonUndef = 0
        try {
            let strArr : FixedArray<arrType> = new FixedArray<arrType>(this.actualLength)
            for (let i = 0; i < this.actualLength; i++) {
                const vl = this.$_get_unsafe(i)
                if (vl !== undefined) {
                    if (vl == null) {
                        this.$_set_unsafe(idxNonUndef, vl as T)
                        strArr[idxNonUndef] = "null"
                    } else {
                        this.$_set_unsafe(idxNonUndef, vl)
                        strArr[idxNonUndef] = (vl as object).toString() // #26217
                    }
                    idxNonUndef++
                }
            }
            let sortTo = idxNonUndef
            for (let i = idxNonUndef; i < this.actualLength; i++) {
                this.$_set_unsafe(i, undefined as T)
            }

            sort_default<Any>(this.buffer, strArr, 0, sortTo)
        }
        catch (e) {
            if (e instanceof OutOfMemoryError) {
                this.slow_default_sort()
            } else {
                throw e as Error
            }
        }
    }

    private slow_default_sort(): void {
        let idxNonUndef = 0
        const cmp: (l: Any, r: Any) => int = (l: Any, r: Any): int => {
            return Array.defaultComparator(l, r)
        }
        for (let i = 0; i < this.actualLength; i++) {
            const vl = this.$_get_unsafe(i)
            if (vl !== undefined) {
                this.$_set_unsafe(idxNonUndef, vl)
                idxNonUndef++
            }
        }
        let sortTo: int = idxNonUndef
        for (let i = idxNonUndef; i < this.actualLength; i++) {
            this.$_set_unsafe(i, undefined as T)
        }
        sort_stable<Any>(this.buffer, 0, sortTo, cmp)
    }

    private move_undefined_end(): int {
        let writeIndex: int = 0
        for (let i = 0; i < this.actualLength; i++) {
            let val = this.$_get_unsafe(i)
            if (val !== undefined) {
                if(writeIndex != i) {
                    this.$_set_unsafe(writeIndex, val)
                }
                writeIndex++
            }
        }
        for (let i = writeIndex; i < this.actualLength; i++) {
            this.$_set_unsafe(i, undefined as T)
        }
        return writeIndex
    }

    /**
     * Sorts the elements of an array in place and returns the reference to the same array, now sorted.
     *
     * @param { function } [comparator] Optional. A function that defines the sort order. If omitted, the array is sorted
     *     according to each character's Unicode code point value, according to the string conversion of each element.
     * @returns { this } The sorted array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public sort(comparator?: (a: T, b: T) => int): this {
        if (this.actualLength <= 1)
            return this

        if (comparator == undefined) {
            this.wrap_default_sort()
            return this
        }

        const compareTo: int = this.move_undefined_end()
        let cmp: (l: Any, r: Any) => int = (l: Any, r: Any): int => {
            return comparator!(l as T, r as T)
        }
        sort_stable<Any>(this.buffer, 0, compareTo, cmp)
        return this
    }

    /**
     * Removes the first element from an array and returns that removed element. This method changes the length of the array.
     *
     * @returns { T | undefined } The removed element from the array; undefined if the array is empty.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public shift(): T | undefined {
        const len: int = this.actualLength
        if(len == 0) {
            return undefined
        }
        let obj: T = this.$_get_unsafe(0)
        copyToFastWithBarriers(this.buffer, this.buffer, 0, 1, len)
        this.popImpl()
        return obj
    }

    /**
     * Removes the last element from an array and returns that element. This method changes the length of the array.
     *
     * @returns { T | undefined } The removed element from the array; undefined if the array is empty.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public pop(): T | undefined {
        const len: int = this.actualLength
        if(len == 0) {
            return undefined
        }
        let obj: T = this.$_get_unsafe(len - 1)
        this.popImpl()
        return obj
    }

    private popImpl(): void {
        const index: int = this.actualLength - 1
        this.$_set_unsafe(index, undefined)
        this.actualLength = index
    }

    /**
     * Adds the specified elements to the end of an array and returns the new length of the array.
     *
     * @param { T[] } val The elements to add to the end of the array.
     * @returns { int } The new length of the array upon which the method was called.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public pushArray(...val: T[]): int {
        const length: int = val.length
        this.ensureUnusedCapacity(length)
        for (let i = 0; i < length; i++) {
            this.buffer[this.actualLength + i] = val[i]
        }
        this.actualLength += length
        return this.actualLength
    }

    /**
     * Adds the specified element to the end of an array and returns the new length of the array.
     *
     * @param { T } val The element to add to the end of the array.
     * @returns { int } The new length of the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public pushOne(val: T): int {
        this.ensureUnusedCapacity(1)
        this.buffer[this.actualLength] = val
        this.actualLength += 1
        return this.actualLength
    }

    overload push{ pushOne, pushArray }

    private ensureUnusedCapacity(cap: int): void {
        const length: int = this.buffer.length
        if (this.actualLength + cap > length) {
            const copy: FixedArray<Any> = new FixedArray<Any>(length * 2 + cap)
            for (let i = 0; i < this.actualLength; i++) {
                copy[i] = this.buffer[i]
            }
            this.buffer = copy
        }
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.
     *
     * @param { int } start The index at which to start changing the array.
     * @param { int | undefined } delete The number of items to remove after the start index.
     * @param { T[] } items The elements to add to the array, beginning from start.
     * @returns { Array<T> } An array containing the deleted elements.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public splice(start: int, delete: int | undefined, ...items: T[]): Array<T> {
        if (delete === undefined) {
            delete = 0
        }
        start = normalizeIndex(start, this.actualLength)
        if (delete < 0) {
            delete = 0
        }
        if (start > this.actualLength - delete) {
            delete = this.actualLength - start
        }
        // this: [left middle right], we must replace middle with `items`

        const itemsLength = items.length
        this.ensureUnusedCapacity(itemsLength - delete)
        const oldLen = this.actualLength
        const newLen = this.actualLength - delete + itemsLength
        // Extend `actualLength` to ensure correct operations.
        // Note that shrinking the array will lead to incorrect behavior
        if (newLen > oldLen) {
            this.actualLength = newLen
        }

        let ret = new Array<T>(delete)
        // left part remains unchanged
        // copy excluded part
        for (let i = 0; i < delete; i++) {
            ret.$_set_unsafe(i, this.$_get_unsafe(start + i))
        }
        // move right part to the right of the buffer
        const rightLen = oldLen - start - delete
        if (itemsLength > delete) {
            for (let i = 0; i < rightLen; i++) {
                // This operation is correct because `actualLength` was extended before
                this.$_set_unsafe(newLen - 1 - i, this.$_get_unsafe(oldLen - 1 - i))
            }
        } else {
            for (let i = 0; i < rightLen; i++) {
                this.$_set_unsafe(start + itemsLength + i, this.$_get_unsafe(start + delete + i))
            }
            for (let i = newLen; i < oldLen; i++) {
                this.$_set_unsafe(i, undefined)
            }
        }
        // insert middle part
        for (let i = 0; i < itemsLength; i++) {
            this.$_set_unsafe(start + i, items.$_get_unsafe(i))
        }
        // Update length in the end to ensure correct `this` operations
        this.actualLength = newLen
        return ret
    }

    /**
     * Changes the contents of an array by removing existing elements in place from the start index to the end.
     *
     * @param { int } start The index at which to start changing the array.
     * @returns { Array<T> } An array containing the deleted elements.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public splice(start: int): Array<T> {
        return this.splice(start, this.actualLength)
    }

    /**
     * Checks whether the passed value is an Array.
     *
     * @param { Any } o The value to be checked.
     * @returns { boolean } True if the value is an Array; otherwise, false.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static isArray(o: Any): boolean {
        return o instanceof Array
    }

    /**
     * Creates a new Array instance from a variable number of arguments, regardless of number or type of the arguments.
     *
     * @param { T[] } values Elements of which to create the array.
     * @returns { Array<T> } A new Array instance.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of<T>(...values: T[]): Array<T> {
        const ret = new Array<T>()
        const length: int = values.length
        ret.ensureUnusedCapacity(length)
        for (let i = 0; i < length; i++) {
            ret.push(values[i])
        }
        return ret
    }

    /**
     * Adds the specified elements to the beginning of an Array and returns the new length of the Array.
     *
     * @param { T[] } values The elements to add to the front of the array.
     * @returns { int } The new length of the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public unshift(...values: T[]): int {
        const length: int = this.buffer.length
        if (length <= values.actualLength + this.actualLength) {
            let buffer: FixedArray<Any> = new FixedArray<Any>(length * 2 + values.actualLength)
            Array.unshiftInternal(this.buffer, this.actualLength, buffer, values)
            this.buffer = buffer
        } else {
            Array.unshiftInternal(this.buffer, this.actualLength, this.buffer, values)
        }

        this.actualLength += values.actualLength
        return this.actualLength
    }

    private static native unshiftInternal<T>(self: FixedArray<Any>, selfLen: int, buffer: FixedArray<Any>, values: Array<T>): void

    /**
     * Returns a new Array Iterator object that contains the keys for each index in the array.
     *
     * @returns { IterableIterator<number> } A new Array Iterator object.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    // NOTE(zaytsevaekaterina): fix in #26615
    public override keys(): IterableIterator<number> {
        return new ArrayKeysIterator<T>(this)
    }

    /**
     * Returns an iterator over all values
     * 
     * @returns { IterableIterator<T> } An iterator over all values.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override $_iterator(): IterableIterator<T> {
        return this.values()
    }

    // === methods with incompatible implementation ===
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     *
     * @param { function } predicate A function that accepts up to three arguments. The filter method calls the
     *     predicate function one time for each element in the array.
     * @returns { Array<T> } A new array with the elements that pass the test.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override filter(predicate: (value: T, index: int, array: Array<T>) => boolean): Array<T> {
        const res = new Array<T>()
        const len = this.actualLength
        for (let i: int = 0; i < len && i < this.actualLength; i++) {
            const val = this.$_get_unsafe(i)
            if (predicate(val, i, this)) {
                res.push(val)
            }
        }
        return res
    }

    /**
     * Creates a new Array with all sub-array elements concatenated into it recursively up to the specified depth.
     *
     * @param { int } depth The depth level specifying how deep a nested array structure should be flattened.
     * @returns { Array<U> } A new array with the sub-array elements concatenated into it.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public flat<U = T>(depth: int): Array<U> {
        let ret = new Array<U>()
        this.flatImpl<U>(depth, ret)
        return ret
    }

    /**
     * Determines whether obj is exactly an instance of the std.core.Array class.
     *
     * @param { Object } obj The object to check.
     * @returns { boolean } True if obj is an instance of std.core.Array; otherwise, false.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private static native isPlatformArray(obj: Object): boolean

    /**
     * Returns the buffer from an instance of the std.core.Array class.
     * The caller must ensure obj is an instance of std.core.Array (e.g. via isPlatformArray).
     *
     * @param { Object } obj An instance of std.core.Array.
     * @returns { FixedArray<Any> } A reference to the (obj as Array<T>).buffer field.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private static native getBuffer(obj: Object): FixedArray<Any>;

    /**
     * Creates a new `Array` by merging this `Array` instance with given arrays and/or values.
     *
     * @param { FixedArray<ConcatArray<T>> } items Arrays and/or values to concatenate into a new array.
     * @returns { Array<T> } A new Array instance.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public concat(...items: FixedArray<ConcatArray<T>>): Array<T> {
        let totalAdd = this.actualLength;
        for (let i = 0; i < items.length; i++) {
            totalAdd += items[i].length
        }

        const buf : FixedArray<Any> = new FixedArray<Any>(totalAdd);
        copyTo(this.buffer, buf, 0, 0, this.actualLength)

        let insertTo = this.actualLength;
        for (let i = 0; i < items.length; i++) {
            const arr = items[i]
            const len: int = arr.length
            if (Array.isPlatformArray(arr)) {
                copyTo(Array.getBuffer(arr), buf, insertTo, 0, len)
                insertTo += len
            } else {
                for (let j = 0; j < len; j++) {
                    buf[insertTo++] = arr.$_get(j)
                }
            }
        }

        return new Array<T>(FROM_BUFFER, buf);
    }

    private flatImpl<U>(depth: int, to: Array<U>) {
        for (let i = 0; i < this.actualLength; i++) {
            let element = this.buffer[i]
            if (depth > 0 && element instanceof Array) {
                let subArray = (element as Array<T>).flat<U>(depth - 1)
                for (let j = 0; j < subArray.length; j++) {
                    to.push(subArray[j] as U)
                }
            } else {
                to.push(element as U)
            }
        }
    }

    /**
     * Creates a new Array with all sub-array elements concatenated into it recursively with a default depth of 1.
     *
     * @returns { Array<U> } A new array with the sub-array elements concatenated into it.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public flat<U = T>(): Array<U> {
        return this.flat<U>(1)
    }

    /**
     * Calls a defined callback function on each element of an array. Then, flattens the result into a new array.
     * This is identical to a map() followed by a flat() with depth 1.
     *
     * @param { function } fn A function that produces an element of the new Array.
     * @returns { Array<U> } A new array with each element being the result of the callback function and flattened.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public flatMap<U = T>(fn: (v: T, k: int, arr: Array<T>) => U | ReadonlyArray<U>): Array<U> {
        const result = new Array<U>();
        for (let i = 0; i < this.actualLength; ++i) {
            let value: U | ReadonlyArray<U> = fn(this.$_get_unsafe(i), i, this);
            if (value instanceof ReadonlyArray) {
                let vv: ReadonlyArray<U> = value;
                for (let i = 0; i < vv.length; ++i) {
                    result.push(vv[i]);  // Workaround to not use 'push(value[i] as U)'
                }
            }
            else {
                result.push(value);
            }
        }
        return result;
    }


    // === methods common among all arrays ===
% require 'ostruct'
% ctx = OpenStruct.new
% $ctx = ctx
% ctx.this = 'this'
% ctx.this_arg = ''
% ctx.this_buffer = 'this.buffer'
% ctx.this_len_int = 'this.actualLength'
% ctx.this_array = 'escompat_array'
% ctx.array_len_int = Proc.new { |v| "#{v}.length" }
% ctx.access_public = 'public'
% ctx.access_private = 'private'
% ctx.override = 'override'
% ctx.override_expected_here = '' # hide 'override' when it cannot be implemented
% ctx.get_unsafe = Proc.new { |t, i| "#{t}.$_get_unsafe(#{i})" }
% ctx.get = Proc.new { |t, i| "#{t}[#{i}]" }
% ctx.set_unsafe = Proc.new { |t, i, v| "#{t}.$_set_unsafe(#{i}, #{v})" }
% ctx.el_type = 'T'
% ctx.el_type_boxed = 'T'
% ctx.function_type = 'has_native'
% ctx.this_type = 'Array<T>'
% ctx.this_return_type = 'this'
% ctx.clone_this = 'new Array<T>(FROM_BUFFER, this.copyArray())'
% ctx.make_buffer = Proc.new { |l, elt|
%   "new FixedArray<Any>(#{l})"
% }
% ctx.make_fixed_array = 'FixedArray<Any>'
% ctx.from_buffer = Proc.new { |b, elt|
%   elt ||= ctx.el_type
%   "new Array<#{elt}>(FROM_BUFFER, #{b})"
% }
% ctx.array_of_type = Proc.new { |t| "Array<#{t}>" }
% ctx.this_call = Proc.new { |f| "this.#{f}(" }
% ctx.arr_method_call = Proc.new { |t, f, *args| "#{t}.#{f}(#{args.join(', ')})" }
% ctx.this_generic = ''
% ctx.this_generic_one = ''
% ctx.this_iterator_generic = '<T>'
% ctx.copy_function = 'copyToFast'
% template = ERB.new(File.read("Array_common.erb"), trim_mode: '%', eoutvar: '_sub01')
<%= template.result(ctx.instance_eval { binding }).gsub(/^/, '    ') %>
% template = ERB.new(File.read("Array_map.erb"), trim_mode: '%', eoutvar: '_sub02')
% ctx.mapped_type_readonlyarray = 'U | ReadonlyArray<U>'
% ctx.mapped_type = 'U'
% ctx.map_generic = '<U>'
<%= template.result(ctx.instance_eval { binding }).gsub(/^/, '    ') %>

}

%# When ['T'] is added to BuiltinArray, the copyToFast() function should be declared and for BuiltinArray too.
/**
 * Copies src array into dst with respect to passed indexes and without setting pre-write barriers.
 * dst must be a newly allocated array with enough space; otherwise out-of-bounds may occur.
 *
 * @param { FixedArray<Any> } src Source array to be copied.
 * @param { FixedArray<Any> } dst Destination array.
 * @param { int } dstStart Index of dst to start from.
 * @param { int } srcStart Index of src to start from.
 * @param { int } srcEnd Last index of src to copy, exclusive (src[srcEnd] is not copied).
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 * @example
 * ```arkts
 * copyToFast(src, dst, 0, 0, src.length)
 * ```
 */
native function copyToFast(src: FixedArray<Any>, dst: FixedArray<Any>, dstStart: int, srcStart: int, srcEnd: int): void;

/**
 * Copies src array into dst with respect to passed indexes and with setting pre-write barriers.
 * dst may be the same as src and must have enough space; otherwise out-of-bounds may occur.
 *
 * @param { FixedArray<Any> } src Source array to be copied.
 * @param { FixedArray<Any> } dst Destination array.
 * @param { int } dstStart Index of dst to start from.
 * @param { int } srcStart Index of src to start from.
 * @param { int } srcEnd Last index of src to copy, exclusive (src[srcEnd] is not copied).
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 * @example
 * ```arkts
 * copyToFastWithBarriers(src, dst, 0, 1, src.length)
 * ```
 */
native function copyToFastWithBarriers(src: FixedArray<Any>, dst: FixedArray<Any>, dstStart: int, srcStart: int, srcEnd: int): void;

/**
 * Tries to get the length of the iterator from an object.
 *
 * @param { Object } obj The object to check for an iterator length.
 * @returns { int | undefined } The length of the iterator if found; otherwise, undefined.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function tryGetIteratorLength(obj: Object): int | undefined {
    const objCls = Class.of(obj)
    for (const method of objCls.getInstanceMethods()) {
        if (method.getName() == "__Iterator_getLength" && method.getParametersNum() == 0) {
            return method.invoke(obj, []) as int
        }
    }
    return undefined
}

% template = ERB.new(File.read("Array_common_top_scope.erb"), trim_mode: '%', eoutvar: '_sub03')
<%= template.result(ctx.instance_eval { binding }).rstrip %>
