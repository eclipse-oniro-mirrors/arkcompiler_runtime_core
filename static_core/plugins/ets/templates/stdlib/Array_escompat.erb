/*
 * Copyright (c) 2021-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package escompat;

// NOTE: autogenerated file

% template = ERB.new(File.read("Array_header.erb"), nil, '%', eoutvar: '_sub04')
<%= template.result(binding) %>

class ArrayKeysIterator<T> implements IterableIterator<number> {
    private parent: Array<T>
    private idx: int = 0

    constructor(parent: Array<T>) {
        this.parent = parent
    }

    override next(): IteratorResult<number> {
        if (this.idx >= this.parent.actualLength) {
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>(this.idx++ as number)
    }

    override iterator(): IterableIterator<number> {
        return this
    }
}

class FromBuffer {}
const FROM_BUFFER = new FromBuffer()

/**
 * Represents JS API-compatible Array
 */
export final class Array<T> implements ReadonlyArray<T>, Iterable<T> {
    private buffer: NullishType[]
    internal actualLength: int

    /* override */ get length(): number {
        return this.actualLength as number
    }

    set length(newLen: number): void {
        const len = newLen as int
        if (len < 0 || len > this.actualLength) {
            throw new RangeError("can't change length to bigger or negative")
        }
        this.actualLength = len
    }

    public /* override */ $_get(index: number): T {
        return this.$_get(index as int)
    }

    public $_set(i: number, val: T): void {
        this.$_set(i as int, val)
    }

    public $_get(idx: int): T {
        if (idx >= this.actualLength) {
            throw new RangeError("Out of bounds")
        }
        return this.buffer[idx] as T
    }

    internal $_get_unsafe(idx: int): T {
        return this.buffer[idx] as T
    }

    public $_set(idx: int, val: T): void {
        if (idx >= this.actualLength) {
            throw new RangeError("Out of bounds")
        }
        this.buffer[idx] = val as Object
    }

    private $_set_unsafe(idx: int, val: T): void {
        this.buffer[idx] = val
    }

    /**
     * Creates a new instance of Array
     */
    public constructor(arrayLen: number) {
        this.buffer = new NullishType[arrayLen as int];
        this.actualLength = arrayLen as int // TODO(kprokopenko): this is incorrect! null-safety
    }

    internal constructor(_tag: FromBuffer, buf: NullishType[]) {
        this.buffer = buf
        this.actualLength = buf.length
    }

    internal constructor() {
        this.buffer = new NullishType[4];
        this.actualLength = 0
    }

    /**
     * Creates a new instance of Array based on Object[]
     *
     * @param d Array initializer
     */
    public constructor(first: T, ...d: T[]) {
        this.buffer = new NullishType[d.length + 1];
        this.actualLength = d.length + 1

        this.buffer[0] = first

        for (let k: int = 0; k < d.length; k++) {
            this.$_set_unsafe(k + 1, d[k]);
        }
    }

    /**
     * Creates a new `Array` instance from `Object[]` primitive array.
     *
     * @param arr primitive 'Object' array to be converted to `Array` instance.
     *
     * @returns `Array` intance constructed from `Object[]` primitive array.
     */
    public static from<T>(arr: ArrayLike<T> | Iterable<T>): Array<T> {
        return Array.from<T, T>(arr, (x: T, k: number): T => x)
    }

    /**
     * Creates a new `Array` instance from `Object[]` primitive array.
     *
     * @param arr primitive 'Object' array, converted to `Array` instance.
     *
     * @param fn map function to call on every element of the array.
     * Every value to be added to the array is first passed through this function, and `fn`'s return value
     * is added to the array instead.
     *
     * @returns `Array` intance constructed from `Object[]` primitive array and given function.
     */
    public static from<T, U>(arr: ArrayLike<T> | Iterable<T>, fn: (v: T, k: number) => U): Array<U> {
        const ret = new Array<U>()
        const idx = new int[1]
        idx[0] = 0
        // NOTE(kprokopenko): see #15523 #15096 can't call .iterator()
        const verifyCompiles: Iterable<T> = arr
        const getIteratorFromIterable = (a: Object): Iterator<T> => {
            if (a instanceof String) {
                return (a as String).iterator() as Iterator<T>
            }
            const aType = Type.of(a) as ClassType
            const mNum = aType.getMethodsNum();
            for (let i = 0; i < mNum; i++) {
                const m = aType.getMethod(i);
                if (m.getName() == "iterator" && !m.isStatic() && m.getType().getParametersNum() == 0) {
                    return m.invoke(a, [])! as Iterator<T>
                }
            }
            throw new Error("failed to get iterator from iterable")
        }
        iteratorForEach(getIteratorFromIterable(arr), (x: T): void => {
            ret.push(fn(x, idx[0] as number))
            idx[0] += 1
        })
        return ret;
    }

    /**
    * Creates a new `Array` instance from `Object[]` primitive array.
    *
    * @param arr primitive array.
    *
    * @returns `Array` intance constructed from `Object[]` primitive array.
    */
    public static from<T>(arr: T[]): Array<T> {
        const len = arr.length;
        const ret = new NullishType[len as int]
        for (let i: int = 0; i < len; i++) {
            ret[i] = arr[i] as NullishType;
        }
        return new Array<T>(FROM_BUFFER, ret);
    }

    /**
     * Default comparison function for sort algorithm.
     * Objects are compared as string. Both objects are convereted to string
     * using `toString()` method and compared using `compareTo() method of `string` class.
     *
     * @param a: Object - Object to be compared
     *
     * @param b: Object - Object to be compared
     *
     * @returns Returns one of values -1, 0, 1 (_less_, _equal_, _greater_ respectively).
     */
    private static defaultComparator(a: NullishType, b: NullishType): number {
        if (a instanceof Number && b instanceof Number) {
            const x = (a as Number).valueOf()
            const y = (b as Number).valueOf()
            if (Number.isInteger(x) && Number.isInteger(y) &&
                x <= Int.MAX_VALUE / 128 && x >= Int.MIN_VALUE / 128 &&
                y <= Int.MAX_VALUE / 128 && y >= Int.MIN_VALUE / 128) {
                let z = x as int
                let w = y as int
                return Array.defaultComparatorInts(z, w)
            }
        }
        let sa = new String(a);
        let sb = new String(b);
        return sa.compareTo(sb);
    }

    private static defaultComparatorInts(a: int, b: int): number {
        if (a < 0) {
            if (b >= 0) {
                return -1;
            }
            a *= -1;
            b *= -1;
        } else if (b < 0) {
            return 1;
        }
        let aDigs = 1;
        while (10 * aDigs <= a) {
            aDigs *= 10
        }
        let bDigs = 1;
        while (10 * bDigs <= b) {
            bDigs *= 10
        }

        while (aDigs > 0 && bDigs > 0) {
            let r = (a / aDigs) - (b / bDigs)
            if (r != 0) {
                return r
            }
            aDigs /= 10
            bDigs /= 10
        }
        return (aDigs - bDigs)
    }

    /**
     * Helper function preparing copy of `this` instance of `Array` class' data array.
     *
     * @returns Copy of an `Array`'s primitive array data.
     */
    private copyArray(): NullishType[] {
        let len: int = this.actualLength;
        let res = new NullishType[len];
        for (let i = 0; i < len; i++) {
            res[i] = this.$_get_unsafe(i);
        }
        return res;
    }

    /**
     * Reorders elements of `this` using comparator function.
     *
     * @param comparator function that defines the sort order.
     *
     * @note Mutating method
     *
     * NOTE clarify UTF-16 or UTF-8
     */
    public sort(comparator?: (a: T, b: T) => number): this {
        let cmp: (l: NullishType, r: NullishType) => number = (l: NullishType, r: NullishType): number => {
            return Array.defaultComparator(l, r);
        };
        let sortTo = this.actualLength
        if (!__runtimeIsSameReference(comparator, undefined)) {
            cmp = (l: NullishType, r: NullishType): number => {
                return comparator!(l as T, r as T);
            };
        } else {
            let idxNonUndef = 0
            let undefCount = 0
            for (let i = 0; i < this.actualLength; i++) {
                const vl = this.$_get_unsafe(i)
                if (__runtimeIsSameReference(vl, undefined)) {
                    undefCount++
                } else {
                    this.$_set_unsafe(idxNonUndef++, vl)
                }
            }
            sortTo = idxNonUndef
            for (let i = idxNonUndef; i < this.actualLength; i++) {
                this.$_set_unsafe(i, undefined as T)
            }
        }
        sort_stable<NullishType>(this.buffer, 0, sortTo, cmp);
        return this;
    }

    /**
     * Removes the first element from an array and returns that removed element.
     * This method changes the length of the array.
     *
     * @returns shifted element, i.e. that was at index zero
     */
    public shift(): T | undefined {
        if(this.actualLength == 0) {
            return undefined
        }
        let obj = this.$_get_unsafe(0)
        const other = this.slice(1, this.actualLength)
        this.buffer = other.buffer
        this.actualLength = other.actualLength
        return obj
    }

    /**
     * Removes the last element from an array and returns that element.
     * This method changes the length of the array.
     *
     * @returns removed element
     */
    public pop(): T | undefined {
        if(this.actualLength == 0) {
            return undefined
        }
        let obj = this.$_get_unsafe(this.actualLength - 1)
        this.buffer[this.actualLength - 1] = null
        this.actualLength--
        return obj
    }

    // TODO(kprokopenko): remove when #14756 is fixed and rename below fucntion to push
    public push(val: T): number {
        this.ensureUnusedCapacity(1)
        this.buffer[this.actualLength] = val
        this.actualLength += 1
        return this.actualLength
    }

    /**
     * Adds the specified elements to the end of an array and returns the new length of the array.
     *
     * @returns new length
     */
    public pushECMA(...val: T[]): number {
        this.ensureUnusedCapacity(val.length)
        for (let i = 0; i < val.length; i++) {
            this.buffer[this.actualLength + i] = val[i];
        }
        this.actualLength += val.length
        return this.actualLength
    }

    private ensureUnusedCapacity(cap: int): void {
        if (this.actualLength + cap > this.buffer.length) {
            const copy = new NullishType[this.buffer.length * 2 + cap]
            for (let i = 0; i < this.actualLength; i++) {
                copy[i] = this.buffer[i]
            }
            this.buffer = copy
        }
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements
     * and/or adding new elements in place.
     *
     * @param start index
     *
     * @param delete number of items after start index
     *
     * @returns an Array with deleted elements
     */
    public splice(start: number, delete: Number | undefined, ...items: T[]): Array<T> {
        return this.splice(start as int, asIntOrDefault(delete, this.actualLength), ...items)
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements
     * and/or adding new elements in place.
     *
     * @param start index
     *
     * @param delete number of items after start index
     *
     * @returns an Array with deleted elements
     */
    public splice(start: int, delete: int, ...items: T[]): Array<T> {
        start = normalizeIndex(start, this.actualLength)
        if (delete < 0) {
            delete = 0;
        }
        if (start > this.actualLength - delete) {
            delete = this.actualLength - start
        }
        // this: [left middle right], we must replace middle with `items`

        this.ensureUnusedCapacity(items.length - delete)
        const oldLen = this.actualLength
        this.actualLength = this.actualLength - delete + items.length

        let ret = new Array<T>(delete)
        let lastSet = start
        // left part remains unchanged
        // copy excluded part
        for (let i = 0; i < delete; i++) {
            ret.buffer[i] = this.buffer[start + i]
        }
        // move right part to the right of the buffer
        const rightLen = oldLen - start - delete
        if (items.length > delete) {
            for (let i = 0; i < rightLen; i++) {
                this.buffer[this.actualLength - 1 - i] = this.buffer[oldLen - 1 - i]
            }
        } else {
            for (let i = 0; i < rightLen; i++) {
                this.buffer[start + items.length + i] = this.buffer[start + delete + i]
            }
        }
        // insert middle part
        for (let i = 0; i < items.length; i++) {
            this.buffer[start + i] = items[i]
        }
        return ret
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements
     * and/or adding new elements in place.
     *
     * @param start index
     *
     * @returns an Array with deleted elements from start to the last element of the current instance
     */
    public splice(start: number): Array<T> {
        return this.splice(start as int)
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements
     * and/or adding new elements in place.
     *
     * @param start index
     *
     * @returns an Array with deleted elements from start to the last element of the current instance
     */
    public splice(start: int): Array<T> {
        return this.splice(start, this.actualLength)
    }

    /**
     * Checks whether the passed value is an Array.
     *
     * @param arr
     *
     * @returns true is arr is a non-nullish array, false otherwise
     */
    public static isArray(o: NullishType): boolean {
        if (o instanceof Array) {
            return true
        }
        return (Type.of(o) instanceof ArrayType)
    }

    /**
     * Creates a new Array instance from a variable number of arguments,
     * regardless of number or type of the arguments.
     *
     * @param values an initilizer
     *
     * @returns a newly created Array
     */
    public static of<T>(...values: T[]): Array<T> {
        const ret = new Array<T>()
        ret.ensureUnusedCapacity(values.length)
        for (let i = 0; i < values.length; i++) {
            ret.push(values[i])
        }
        return ret;
    }

    /**
     * Adds the specified elements to the beginning of an Array
     * and returns the new length of the Array.
     *
     * @param values data to be added
     *
     * @returns new length of the Array
     */
    public unshift(...values: T[]): number {
        let buffer = this.buffer
        if (this.buffer.length <= values.length + this.actualLength) {
            buffer = new NullishType[this.buffer.length * 2 + values.length]
        }
        for (let i = 0; i < this.actualLength; i++) {
            buffer[this.actualLength + values.length - i - 1] = this.buffer[this.actualLength - 1 - i];
        }
        for (let i = 0; i < values.length; i++) {
            buffer[i] = values[i];
        }
        this.buffer = buffer
        this.actualLength += values.length;
        return this.actualLength;
    }

    /**
     * Returns an iterator over all indices
     */
    public /* override */ keys(): IterableIterator<Number> {
        return new ArrayKeysIterator<T>(this)
    }

    /**
     * Returns an iterator over all values
     */
    public override iterator(): IterableIterator<T> {
        return this.values()
    }

    // === methods with uncompatible implementation ===
    /**
     * Constructs a new `Array` instance and populates it with
     * portion of a given array, filtered down to just the elements from the
     * given array that pass the test implemented by the provided function.
     *
     * @param fn test function, applied to each element of an array.
     *
     * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
     */
    public /* override */ filter(fn: (v: T, k: number) => boolean): Array<T> {
        const res = new Array<T>()

        for (let i: int = 0; i < this.actualLength; i++) {
            const val = this.$_get_unsafe(i);
            if (fn(val, i as number)) {
                res.push(val)
            }
        }
        return res;
    }

    /**
     * Creates a new Array with all sub-array elements concatenated
     * into it recursively up to the specified depth.
     *
     * @param depth
     *
     * @returns a flattened Array with respect to depth
     */
    public flat<U>(depth: number): Array<U> {
        return this.flat<U>(depth as int)
    }

    /**
     * Creates a new Array with all sub-array elements concatenated
     * into it recursively up to the specified depth.
     *
     * @param depth
     *
     * @returns a flattened Array with respect to depth
     */
    public flat<U>(depth: int): Array<U> {
        let ret = new Array<U>()
        this.flatImpl<U>(depth, ret)
        return ret
    }

    private flatImpl<U>(depth: int, to: Array<U>) {
        throw new Error("not implemented");
    }

    /**
     * Creates a new Array with all sub-array elements concatenated
     *
     * @returns a flattened Array
     */
    public flat<U>(): Array<U> {
        return this.flat<U>(1)
    }

    /**
     * Applies flat and than map
     *
     * fn a function to apply
     *
     * @return new Array after map and than flat
     */
    // NOTE(ivan-tyulyandin): TBD, flatMap may be not subset, see ReadonlyArray
    public flatMap<U>(fn: (v: T, k: number, arr: Array<T>) => U): Array<U> {
        let mapped: Array<U> = this.map<U>(fn)
        return mapped.flat<U>()
    }

    /**
     * Applies flat and than map
     *
     * fn a function to apply
     *
     * @return new Array after map and than flat
     */
     // NOTE(ivan-tyulyandin): TBD, flatMap may be not subset, see ReadonlyArray
    public flatMap<U>(fn: (v: T, k: number) => U): Array<U> {
        let mapped: Array<U> = this.map<U>(fn)
        return mapped.flat<U>()
    }

    /**
     * Applies flat and than map
     *
     * fn a function to apply
     *
     * @return new Array after map and than flat
     */
    // NOTE(ivan-tyulyandin): TBD, flatMap may be not subset, see ReadonlyArray
    public flatMap<U>(fn: (v: T) => U): Array<U> {
        let mapped: Array<U> = this.map<U>(fn)
        return mapped.flat<U>()
    }

    // === methods common among all arrays ===
% require 'ostruct'
% ctx = OpenStruct.new
% $ctx = ctx
% ctx.this = 'this'
% ctx.this_arg = ''
% ctx.this_len_int = 'this.actualLength'
% ctx.array_len_int = Proc.new { |v| "#{v}.actualLength" }
% ctx.access_public = 'public'
% ctx.access_private = 'private'
% ctx.override = '' # 'override'
% ctx.get_unsafe = Proc.new { |t, i| "#{t}.$_get_unsafe(#{i})" }
% ctx.set_unsafe = Proc.new { |t, i, v| "#{t}.$_set_unsafe(#{i}, #{v})" }
% ctx.el_type = 'T'
% ctx.el_type_boxed = 'T'
% ctx.this_type = 'Array<T>'
% ctx.this_return_type = 'this'
% ctx.clone_this = 'new Array<T>(FROM_BUFFER, this.copyArray())'
% ctx.make_buffer = Proc.new { |l, elt|
%   "new NullishType[#{l}]"
% }
% ctx.from_buffer = Proc.new { |b, elt|
%   elt ||= ctx.el_type
%   "new Array<#{elt}>(FROM_BUFFER, #{b})"
% }
% ctx.array_of_type = Proc.new { |t| "Array<#{t}>" }
% ctx.this_call = Proc.new { |f| "this.#{f}(" }
% ctx.arr_method_call = Proc.new { |t, f| "#{t}.#{f}(" }
% ctx.this_generic = ''
% ctx.this_generic_one = ''
% ctx.this_iterator_generic = '<T>'
% template = ERB.new(File.read("Array_common.erb"), nil, '%', eoutvar: '_sub01')
<%= template.result(ctx.instance_eval { binding }).gsub(/^/, '    ') %>
% template = ERB.new(File.read("Array_map.erb"), nil, '%', eoutvar: '_sub02')
% ctx.mapped_type = 'U'
% ctx.map_generic = '<U>'
<%= template.result(ctx.instance_eval { binding }).gsub(/^/, '    ') %>
}
% template = ERB.new(File.read("Array_common_top_scope.erb"), nil, '%', eoutvar: '_sub03')
<%= template.result(ctx.instance_eval { binding }).rstrip %>
