%# Copyright (c) 2021-2026 Huawei Device Co., Ltd.
%# Licensed under the Apache License, Version 2.0 (the "License");
%# you may not use this file except in compliance with the License.
%# You may obtain a copy of the License at
%#
%# http://www.apache.org/licenses/LICENSE-2.0
%#
%# Unless required by applicable law or agreed to in writing, software
%# distributed under the License is distributed on an "AS IS" BASIS,
%# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%# See the License for the specific language governing permissions and
%# limitations under the License.
%
% require_relative 'Array_code'

/**
 * Takes an integer value and returns the item at that index, allowing for positive and negative integers.
 * Negative integers count back from the last item in the array.
 *
     <% if this_arg != "" %>@param { <%= this_type %> } self The array to operate `at` on.<% end %>
 * @param { int } index Zero-based index of the array element to be returned.
 * @returns { <%= el_type_boxed %> } The element at the given index.
 * @throws { RangeError } Throws a RangeError if the index is out of bounds.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> at<%= this_generic %>(<%= this_arg %>index: int): <%= el_type_boxed %> {
    let len = <%= this_len_int %>;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        throw new RangeError("Invalid index");
    }

    return <%= get_unsafe.(this, 'k') %>;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its
 * length.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `copyWithin` on.<% end %>
 * @param { int } target Zero-based index at which to copy the sequence to.
 * @returns { <%= this_return_type %> } The modified array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> copyWithin<%= this_generic %>(<%= this_arg %>target: int): <%= this_return_type %> {
    <%= this_call.('copyWithin') %>target, 0, <%= this_len_int %>);
    return <%= this %>;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its
 * length.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `copyWithin` on.<% end %>
 * @param { int } target Zero-based index at which to copy the sequence to.
 * @param { int } start Zero-based index at which to start copying elements from.
 * @returns { <%= this_return_type %> } The modified array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> copyWithin<%= this_generic %>(<%= this_arg %>target: int, start: int): <%= this_return_type %> {
    <%= this_call.('copyWithin') %>target, start, <%= this_len_int %>);
    return <%= this %>;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its
 * length.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `copyWithin` on.<% end %>
 * @param { int } target Zero-based index at which to copy the sequence to.
 * @param { int } start Zero-based index at which to start copying elements from.
 * @param { int } [end] Zero-based index at which to end copying elements from.
 * @returns { <%= this_return_type %> } The modified array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> copyWithin<%= this_generic %>(<%= this_arg %>target: int, start: int, end?: int): <%= this_return_type %> {
    target = normalizeIndex(target, <%= this_len_int %>)
    start = normalizeIndex(start, <%= this_len_int %>)
    end = normalizeIndex(end ?? <%= this_len_int %>, <%= this_len_int %>)

    if (end <= start) {
        return <%= this %>;
    }

    if (target <= start) {
        while (start < end) {
            const read = <%= get_unsafe.(this, 'start++') %>;
            <%= set_unsafe.(this, 'target++', 'read') %>;
        }
    } else {
        let len = end - start;
        if (target + len > <%= this_len_int %>) {
            len = <%= this_len_int %> - target
        }
        for (let i = 0; i < len; i++) {
            const read = <%= get_unsafe.(this, 'start + len - 1 - i') %>;
            <%= set_unsafe.(this, 'target + len - 1 - i', 'read') %>;
        }
    }

    return <%= this %>;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `fill` on.<% end %>
 * @param { T } value The value to fill the array with.
 * @param { int } [start] The index at which to start filling (optional).
 * @param { int } [end] The index at which to end filling (optional, not included).
 * @returns { <%= this_return_type %> } The modified array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
% if function_type != 'has_native'
<%= access_public %> fill<%= this_generic %>(<%= this_arg %>value: <%= el_type %>, start?: int, end?: int): <%= this_return_type %> {
    start = normalizeIndex(start ?? 0, <%= this_len_int %>);
    end = normalizeIndex(end ?? <%= this_len_int %>, <%= this_len_int %>)

    for (let i = start; i < end; i++) {
        <%= set_unsafe.(this, 'i', 'value') %>;
    }
    return <%= this %>;
}

% else
<%= access_public %> fill<%= this_generic %>(<%= this_arg %>value: <%= el_type %>, start?: int, end?: int): <%= this_return_type %> {
    Array.fillImpl(<%= this_buffer %>, <%= this_len_int %>, value, start ?? 0, end ?? <%= this_len_int %>)
    return this
}

<%= access_private %> static native fillImpl<T>(buffer: FixedArray<Any>, actualLength: int, value: T, start: int, end: int): void;
% end

% TemplateData::get_lambda_data.each { |lambda_args_params|
%   lambda_params_num, lambda_args, lambda_params, lambda_args2 = lambda_args_params
/**
 * Returns the value of the first element in the array where predicate is true, and undefined otherwise.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `find` on.<% end %>
 * @param { function } predicate A function to execute on each value in the array.
 * @returns { <%= el_type_boxed %> | undefined } The value of the first element that satisfies the provided testing function;
 *     otherwise, undefined.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> find<%= this_generic %>(<%= this_arg %>predicate: (value: <%= el_type %><%= lambda_params %>) => boolean): <%= el_type_boxed %> | undefined {<% if this_arg == "" %>
    const len = <%= this_len_int %>
    for (let i = 0; i < len && i < <%= this_len_int %>; i++) {
        const val = <%= get_unsafe.(this, 'i') %>;
        if (predicate(val<%= lambda_args %>)) {
            return val;
        }
    }
    return undefined;<% else %>
    const res = <%= this_call.('findIndex') %>predicate)
    if (res == -1) {
        return undefined
    }
    return <%= get_unsafe.(this, 'res') %>;<% end %>
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1 otherwise.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `findIndex` on.<% end %>
 * @param { function } predicate A function to execute on each value in the array.
 * @returns { int } The index of the first element that satisfies the provided testing function; otherwise, -1.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> findIndex<%= this_generic %>(<%= this_arg %>predicate: (value: <%= el_type %><%= lambda_params %>) => boolean): int {<% if this_arg == "" %>
    const len = <%= this_len_int %>
    for (let i = 0; i < len && i < <%= this_len_int %>; i++) {<% else %>
    for (let i = 0; i < <%= this_len_int %>; i++) {<% end %>
        if (predicate(<%= get_unsafe.(this, 'i') %><%= lambda_args %>)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element that satisfies the provided
 * testing function.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `findLast` on.<% end %>
 * @param { function } predicate A function to execute on each value in the array.
 * @returns { <%= el_type_boxed %> | undefined } The value of the element if found; otherwise, undefined.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> findLast<%= this_generic %>(<%= this_arg %>predicate: (elem: <%= el_type %><%= lambda_params %>) => boolean): <%= el_type_boxed %> | undefined {<% if this_arg == "" %>
    for (let i = <%= this_len_int %> - 1; i >= 0 && i < <%= this_len_int %>; i--) {<% else %>
    for (let i = <%= this_len_int %> - 1; i >= 0; i--) {<% end %>
        const val = <%= get_unsafe.(this, 'i') %>;
        if (predicate(val<%= lambda_args %>)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `every` on.<% end %>
 * @param { function } predicate A function that accepts up to three arguments. The every method calls the predicate
 *     function for each element in the array until the predicate returns a value which is 
 *     coercible to the Boolean value false, or until the end of the array.
 * @returns { boolean } True if the predicate returns true for all elements in the array; otherwise, false.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> every<%= this_generic %>(<%= this_arg %>predicate: (value: <%= el_type %><%= lambda_params %>) => boolean): boolean {<% if this_arg == "" %>
    let curArrLength = <%= this_len_int %>
    for (let i = 0; i < curArrLength && i < <%= this_len_int %>; i++) {<% else %>
    for (let i = 0; i < <%= this_len_int %>; i++) {<% end %>
        if (!predicate(<%= get_unsafe.(this, 'i') %><%= lambda_args %>)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `some` on.<% end %>
 * @param { function } predicate A function that accepts up to three arguments. The some method calls the predicate
 *     function for each element in the array until the predicate returns a value which is
 *     coercible to the Boolean value true, or until the end of the array.
 * @returns { boolean } True if the predicate returns true for at least one element in the array; otherwise, false.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> some<%= this_generic %>(<%= this_arg %>predicate: (value: <%= el_type %><%= lambda_params %>) => boolean): boolean {<% if this_arg == "" %>
    const len = <%= this_len_int %>
    for (let i = 0; i < len && i < <%= this_len_int %>; i++) {<% else %>
    for (let i = 0; i < <%= this_len_int %>; i++) {<% end %>
        if (predicate(<%= get_unsafe.(this, 'i') %><%= lambda_args %>)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of the first element that satisfies the provided
 * testing function. If no elements satisfy the testing function, -1 is returned.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `findLastIndex` on.<% end %>
 * @param { function } predicate A function to execute on each value in the array.
 * @returns { int } The index of the first element that satisfies the provided testing function; otherwise, -1.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> findLastIndex<%= this_generic %>(<%= this_arg %>predicate: (element: <%= el_type %><%= lambda_params %>) => boolean): int {<% if this_arg == "" %>
    for (let i = <%= this_len_int %> - 1; i >= 0 && i < <%= this_len_int %>; i--) {<% else %>
    for (let i = <%= this_len_int %> - 1; i >= 0; i--) {<% end %>
        if (predicate(<%= get_unsafe.(this, 'i') %><%= lambda_args %>)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function
 * is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `reduce` on.<% end %>
 * @param { function } callbackfn A function that accepts up to four arguments. The reduce method calls the
 *     callbackfn function one time for each element in the array.
 * @returns { <%= el_type %> } The accumulated result.
 * @throws { TypeError } Throws a TypeError if the array is empty and no initial value is provided.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> reduce<%= this_generic %>(<%= this_arg %>callbackfn: (previousValue: <%= el_type %>, currentValue: <%= el_type %><%= lambda_params %>) => <%= el_type %>): <%= el_type %> {
    if (<%= this_len_int %> == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: <%= el_type %> = <%= get_unsafe.(this, '0') %>;<% if this_arg == "" %>
    const len = <%= this_len_int %>
    for (let i = 1; i < len && i < <%= this_len_int %>; i++) {<% else %>
    for (let i = 1; i < <%= this_len_int %>; i++) {<% end %>
        acc = callbackfn(acc, <%= get_unsafe.(this, 'i') %><%= lambda_args %>)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function
 * is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `reduce` on.<% end %>
 * @param { function } callbackfn A function that accepts up to four arguments. The reduce method calls the
 *     callbackfn function one time for each element in the array.
 * @param { U } initialValue The initial value of the accumulator.
 * @returns { U } The accumulated result.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> reduce<<%= this_generic_one %>U = <%= el_type %>>(<%= this_arg %>callbackfn: (previousValue: U, currentValue: <%= el_type %><%= lambda_params %>) => U, initialValue: U): U {
    let acc = initialValue<% if this_arg == "" %>
    const len = <%= this_len_int %>
    for (let i = 0; i < len && i < <%= this_len_int %>; i++) {<% else %>
    for (let i = 0; i < <%= this_len_int %>; i++) {<% end %>
        acc = callbackfn(acc, <%= get_unsafe.(this, 'i') %><%= lambda_args %>)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of
 * the callback function is the accumulated result, and is provided as an argument in the next call to the callback
 * function.
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `reduce` on.<% end %>
 * @param { function } callbackfn A function that accepts up to four arguments. The reduceRight method calls the
 *     callbackfn function one time for each element in the array.
 * @param { U } initialValue The initial value of the accumulator.
 * @returns { U } The accumulated result.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> reduceRight<<%= this_generic_one %>U>(<%= this_arg %>callbackfn: (previousValue: U, currentValue: <%= el_type %><%= lambda_params %>) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = <%= this_len_int %> - 1; i >= 0; i--) {<% if this_arg == "" %>
        if (i < <%= this_len_int %>) {
            acc = callbackfn(acc, <%= get_unsafe.(this, 'i') %><%= lambda_args %>)
        }<% else %>
        acc = callbackfn(acc, <%= get_unsafe.(this, 'i') %><%= lambda_args %>)<% end %>
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `forEach` on.<% end %>
 * @param { function } callbackfn A function that accepts up to three arguments. forEach calls the callbackfn
 *     function one time for each element in the array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> forEach<%= this_generic %>(<%= this_arg %>callbackfn: (value: <%= el_type %><%= lambda_params %>) => void): void {
    const len0 = <%= this_len_int %>;<% if this_arg == "" %>
    for (let i = 0; i < len0 && i < <%= this_len_int %>; i++) {<% else %>
    for (let i = 0; i < len0; i++) {<% end %>
        if (i >= <%= this_len_int %>) {
            break
        }
        callbackfn(<%= get_unsafe.(this, 'i') %><%= lambda_args %>)
    }
}

% }

/**
 * Returns a copy of a section of an array.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `slice` on.<% end %>
 * @param { int } start The beginning index of the specified portion of the array.
 * @returns { <%= this_type %> } A new Array object containing the extracted elements.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> slice<%= this_generic %>(<%= this_arg %>start: int): <%= this_type %> {
    return <%= this_call.('slice') %>start, Int.MAX_VALUE);
}

/**
 * Returns a copy of a section of an array.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `slice` on.<% end %>
 * @param { int } [start] The beginning index of the specified portion of the array.
 * @param { int } [end] The end index of the specified portion of the array. The slice includes elements up to but not
 *     including the end index.
 * @returns { <%= this_type %> } A new Array object containing the extracted elements.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> slice<%= this_generic %>(<%= this_arg %>start?: int, end?: int): <%= this_type %> {
    const len: int = <%= this_len_int %>;
    const relStart = normalizeIndex(start ?? 0, len)
    const relEnd = normalizeIndex(end ?? len, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res : <%= make_fixed_array %> = <%= make_buffer.('count') %>
    <%=copy_function%>(<%= this_buffer %>, res, 0, relStart, relStart + count);
    return <%= from_buffer.('res') %>
}

<% if access_public == "export function" %><% #generate code for BuiltinArray.ets %>
/**
 * Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array
 * is searched backwards.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `lastIndexOf` on.<% end %>
 * @param { <%= el_type %> } searchElement The element to locate in the array.
 * @returns { int } The last index of the element in the array; -1 if not found.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> lastIndexOf<%= this_generic %>(<%= this_arg %>element: <%= el_type %>, fromIndex?: int): int {
    if (<%= this_len_int %> == 0) {
        return -1;
    }
    let n = fromIndex ?? <%= this_len_int %> - 1;
    let k: int;
    if (n >= 0) {
        k = min(<%= this_len_int %> - 1, n);
    } else {
        k = <%= this_len_int %> + n;
    }

    while (k >= 0) {
        if (<%= get_unsafe.(this, 'k') %> === element) {
            return k;
        }
        k--;
    }
    return -1;
}
<% else %><% #generate code for Array.ets %>
/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param buffer Array's underlying buffer.
 *
 * @param actualLength Array's underlying length, might be greater than buffer's length.
 *
 * @param searchElement element to locate in the array.
 *
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array â€” if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 * If `fromIndex` is undefined then `fromIndex = 0`.
 * If `fromIndex` is ommited then `fromIndex = length()-1`.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
<%= access_private %> static native lastIndexOfImpl<T>(<%= this_arg %>buffer: FixedArray<Any>, actualLength: int, searchElement: T, fromIndex: int): int;

/**
 * Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array
 * is searched backwards.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `lastIndexOf` on.<% end %>
 * @param { <%= el_type %> } searchElement The element to locate in the array.
 * @returns { int } The last index of the element in the array; -1 if not found.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> lastIndexOf<%= this_generic %>(<%= this_arg %>searchElement: <%= el_type %>): int {
    return Array.lastIndexOfImpl(this.buffer, <%= this_len_int %>, searchElement, <%= this_len_int %> - 1)
}

/**
 * Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array
 * is searched backwards, starting at fromIndex.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `lastIndexOf` on.<% end %>
 * @param { <%= el_type %> } searchElement The element to locate in the array.
 * @param { int } [fromIndex] The index at which to start searching backwards.
 * @returns { int } The last index of the element in the array; -1 if not found.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> lastIndexOf<%= this_generic %>(<%= this_arg %>searchElement: <%= el_type %>, fromIndex?: int): int {
    return Array.lastIndexOfImpl(this.buffer, <%= this_len_int %>, searchElement, fromIndex ?? 0)
}
<% end %>

<% if el_type == "T" %>
private isPrimitive(element: T): boolean {
    return (element instanceof String ||
            element instanceof Int ||
            element instanceof Number ||
            element instanceof Float ||
            element instanceof Long ||
            element instanceof Short ||
            element instanceof Boolean ||
            element instanceof Char ||
            element instanceof Byte ||
            element == null);
}
private static native joinInternal(buffer: FixedArray<Any>, actualLength: int, sep: string): string;

private joinObject(arr: Array<T>, visited: Set<Array<T>>, result: StringBuilder, sep?: String): void {
    let length = arr.length
    if (length == 0 || visited.has(arr)) {
        return
    }
    visited.add(arr)
    const sepReal = sep === undefined ? "," : sep!
    const first_el = arr[0]
    if (first_el != null) {
        if (first_el instanceof Array) {
            this.joinObject(first_el as Array<T>, visited, result)
        } else {
            result.append(new String(first_el))
        }
    }
    for (let i: int = 1; i < length; i++) {
        result.append(sepReal)
        const tmp = arr[i]
        if (tmp == null) {
            continue
        }
        if (tmp instanceof Array) {
            this.joinObject(tmp as Array<T>, visited, result)
        } else {
            result.append(new String(tmp))
        }
    }
    visited.delete(arr)
}
<% end %>

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`, separated by a specified
 * separator string.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `join` on.<% end %>
 * @param { String } [sep] A string to separate each pair of adjacent elements of the array. If omitted, the array
 *     elements are separated with a comma.
 * @returns { string } A string with all array elements joined.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> join<%= this_generic %>(<%= this_arg %>sep?: String): string {
    if (<%= this_len_int %> == 0) {
        return ""
    }
    <% if el_type != "T" %>const sepReal = sep === undefined ? "," : sep!
    let sb = new StringBuilder(new String(<%= get_unsafe.(this, '0') %>))
    for (let i: int = 1; i < <%= this_len_int %>; i++) {
        const tmp = <%= get_unsafe.(this, 'i') %>
        sb.append(sepReal);
        sb.append(tmp)
    }

    return sb.toString();
}
    <% else %>
    let objArray: boolean = false;
    for (let i: int = 0; i < <%= this_len_int %>; i++) {
        const element = <%= get_unsafe.(this, 'i') %>;
        if (!this.isPrimitive(element)) {
            objArray = true;
            break;
        }
    }

    if (objArray) {
        const visited: Set<Array<T>> = new Set<Array<T>>()
        const result: StringBuilder = new StringBuilder()
        this.joinObject(this, visited, result, sep)
        return result.toString()
    }

    return Array.joinInternal(this.buffer, <%= this_len_int %>, sep === undefined ? "," : sep!);
}
    <% end %>

/**
 * Returns a string representing the specified array and its elements.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `stringify` on.<% end %>
 * @returns { string } A string representing the array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> toString<%= this_generic %>(<%= this_arg.chomp(', ') %>): string {
    return <%= this_call.('join') %>",");
}

/**
 * Returns a string representing the elements of the array. The elements are converted to Strings using their
 * toLocaleString methods.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `toLocaleString` on.<% end %>
 * @param { Object } locales A string with a BCP 47 language tag, or an array of such strings.
 * @param { Object } options An object with configuration properties.
 * @returns { string } A string representing the elements of the array.
 * @throws { Error } Throws an Error if the method is not implemented.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> toLocaleString<%= this_generic %>(<%= this_arg %>locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a string representing the elements of the array. The elements are converted to Strings using their
 * toLocaleString methods.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `toLocaleString` on.<% end %>
 * @param { Object } locales A string with a BCP 47 language tag, or an array of such strings.
 * @returns { string } A string representing the elements of the array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> toLocaleString<%= this_generic %>(<%= this_arg %>locales: Object): string {
    return <%= this_call.('toLocaleString') %>new Object(), new Object())
}

/**
 * Returns a string representing the elements of the array. The elements are converted to Strings using their
 * toLocaleString methods.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `toLocaleString` on.<% end %>
 * @returns { string } A string representing the elements of the array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> toLocaleString<%= this_generic %>(<%= this_arg.chomp(', ') %>): string {
    const sb = new StringBuilder()
    const len = <%= this_len_int %>;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = <%= get_unsafe.(this, 'i') %> as Any;
        if ((null !== x) && (undefined !== x)) {
            sb.append((x! as object).toLocaleString()) // #26217
        }
    }
    return sb.toString()
}

/**
 * Returns a new array with some elements removed and/or replaced at a given index.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `toSpliced` on.<% end %>
 * @param { int } start The zero-based index at which to start changing the array.
 * @returns { Array<T> } A new array with the changes applied.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> toSpliced<%= this_generic %>(<%= this_arg %>start: int): <%= this_type %> {
    return <%= this_call.('toSpliced') %>start, <%= this_len_int %>)
}

/**
 * Returns a new array with some elements removed and/or replaced at a given index.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `toSpliced` on.<% end %>
 * @param { int } start The zero-based index at which to start changing the array.
 * @param { int } delete The number of elements to remove.
 * @param { FixedArray<<%= el_type %>> } items The elements to add to the array.
 * @returns { <%= this_type %> } A new array with the changes applied.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> toSpliced<%= this_generic %>(<%= this_arg %>start: int, delete: int, ...items: FixedArray<<%= el_type %>>): <%= this_type %> {
    const len = <%= this_len_int %>;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res : <%= make_fixed_array %> = <%= make_buffer.('len - delete + items.length') %>;
    for (let i = 0; i < start; i++) {
        res[i] = <%= get_unsafe.(this, 'i') %>
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = <%= get_unsafe.(this, 'i') %>
    }
    return <%= from_buffer.('res') %>;
}

/**
 * Returns a new array with some elements removed and/or replaced at a given index.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `toSpliced` on.<% end %>
 * @param { int } [start] The zero-based index at which to start changing the array.
 * @param { int } [delete] The number of elements to remove.
 * @returns { <%= this_type %> } A new array with the changes applied.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> toSpliced<%= this_generic %>(<%= this_arg %>start?: int, delete?: int): <%= this_type %> {
    const len = <%= this_len_int %>;
    return <%= this_call.('toSpliced') %>asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Determines whether an array includes a certain value among its entries, returning true or false as appropriate.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `includes` on.<% end %>
 * @param { <%= el_type %> } val The value to search for.
 * @param { int } [fromIndex] The position in this array at which to begin searching for value.
 * @returns { boolean } True if the value is found, false otherwise.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> includes<%= this_generic %>(<%= this_arg %>val: <%= el_type %>, fromIndex?: int): boolean {
    const len = <%= this_len_int %>;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
% if ['float', 'double', 'number'].include?(el_type)
    if (isNaN(val)) {
        for (let i = fi; i < len; i++) {
            if (isNaN(<%= get_unsafe.(this, 'i') %>)) {
                return true;
            }
        }
        return false;
    }
% end
% if ['boolean', 'byte', 'short', 'int', 'long', 'char', 'float', 'double', 'number'].include?(el_type)
    for (let i = fi; i < len; i++) {
        if (val == <%= get_unsafe.(this, 'i') %>) {
            return true;
        }
    }
    return false;
% elsif el_type == 'T'
    if (val instanceof String) {
        return this.searchString(val, fi, len)
    } else if (val instanceof Double) {
        return this.searchDouble(val, fi, len)
    } else if (val instanceof Float) {
        return this.searchFloat(val, fi, len)
    } else if (val instanceof Long) {
        return this.searchLong(val, fi, len)
    } else if (val instanceof Int) {
        return this.searchInt(val, fi, len)
    } else if (val === undefined) {
        return this.searchUndefined(fi, len)
    } else if (val == null) {
        return this.searchNull(fi, len)
    } else {
        return this.searchCommon(val, fi, len)
    }
% else
    for (let i = fi; i < len; i++) {
        if (val === <%= get_unsafe.(this, 'i') %>) {
            return true;
        }
    }
    return false;
% end
}

/**
 * Returns the first index at which a given element can be found in the array, or -1 if it is not present.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `indexOf` on.<% end %>
 * @param { <%= el_type %> } val The element to locate in the array.
 * @returns { int } The first index of the element in the array; -1 if not found.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
% if el_type != 'T'
<%= access_public %> indexOf<%= this_generic %>(<%= this_arg %>val: <%= el_type %>, fromIndex?: int): int {
    const normFromIndex = normalizeIndex(asIntOrDefault(fromIndex, 0), <%= this_len_int %>)
    for (let i = normFromIndex; i < <%= this_len_int %>; i++) {
        if (val === <%= get_unsafe.(this, 'i') %>) {
            return i
        }
    }
    return -1
}
% else
<%= access_private %> static native indexOfImpl<<%= el_type %>>(<%= this_arg %>buffer: FixedArray<Any>, actualLength: int, val: <%= el_type %>, fromIndex: int): int;
% end

% if this_array == 'escompat_array'
<%= access_public %> indexOf<%= this_generic %>(<%= this_arg %>val: <%= el_type %>): int {
    return Array.indexOfImpl(this.buffer, <%= this_len_int %>, val, 0)
}

/**
 * Returns the first index at which a given element can be found in the array, or -1 if it is not present.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `indexOf` on.<% end %>
 * @param { <%= el_type %> } val The element to locate in the array.
 * @param { int } [fromIndex] The index to start the search at.
 * @returns { int } The first index of the element in the array; -1 if not found.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> indexOf<%= this_generic %>(<%= this_arg %>val: <%= el_type %>, fromIndex?: int): int {
    return Array.indexOfImpl(this.buffer, <%= this_len_int %>, val, asIntOrDefault(fromIndex, 0))
}
%end

/**
 * Returns a new array with the elements sorted in ascending order.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `toSorted` on.<% end %>
 * @returns { <%= this_type %> } A new sorted array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> toSorted<%= this_generic %>(<%= this_arg.chomp(', ') %>): <%= this_type %> {
    let arr = <%= clone_this %>;
    <%= arr_method_call.('arr', 'sort') %>
    return arr
}

/**
 * Returns a new array with the elements sorted using the provided comparator function.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `toSorted` on.<% end %>
 * @param { function } comparator A function that defines the sort order.
 * @returns { <%= this_type %> } A new sorted array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> toSorted<%= this_generic %>(<%= this_arg %>comparator: (a: <%= el_type %>, b: <%= el_type %>) => int): <%= this_type %> {
    let arr = <%= clone_this %>;
    <%= arr_method_call.('arr', 'sort', 'comparator') %>
    return arr
}

/**
 * Reverses an array in place. The first array element becomes the last, and the last array element becomes the
 * first.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `reverse` on.<% end %>
 * @returns { <%= this_return_type %> } The reversed array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
% if function_type != 'has_native'
<%= access_public %> reverse<%= this_generic %>(<%= this_arg.chomp(', ') %>): <%= this_return_type %> {
    for (let i = 0; i < <%= this_len_int %> / 2; i++) {
        const tmp = <%= get_unsafe.(this, 'i') %>;
        const idx_r = <%= this_len_int %> - 1 - i;
        const val_r = <%= get_unsafe.(this, 'idx_r') %>;
        <%= set_unsafe.(this, 'i', 'val_r') %>;
        <%= set_unsafe.(this, 'idx_r', 'tmp') %>;
    }
    return <%= this %>;
}
% else
<%= access_public %> reverse<%= this_generic %>(): <%= this_return_type %> {
/* otherwise the result will be exactly the same as it is */
    if (<%= this_len_int %> > 1) {
        Array.reverseImpl(this.buffer, <%= this_len_int %>)
    }

    return this
}

<%= access_private %> static native reverseImpl<%= this_generic %>(buffer: FixedArray<Any>, actualLength: int): void;
% end

/**
 * Returns a new array with the elements in reversed order.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `toReversed` on.<% end %>
 * @returns { <%= this_type %> } A new reversed array.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> toReversed<%= this_generic %>(<%= this_arg.chomp(', ') %>): <%= this_type %> {
    let arr : <%= make_fixed_array %> = <%= make_buffer.(this_len_int) %>
    for (let i = 0; i < <%= this_len_int %>; i++) {
        arr[<%= this_len_int %> - 1 - i] = <%= get_unsafe.(this, 'i') %>
    }
    return <%= from_buffer.('arr') %>
}

/**
 * Returns a new Array with the element at the given index replaced with the given value.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `with` on.<% end %>
 * @param { int } index The zero-based index at which to replace the value.
 * @param { <%= el_type %> } value The new value to insert at the given index.
 * @returns { <%= this_type %> } A new array with the element replaced.
 * @throws { RangeError } If the index is out of bounds.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> with<%= this_generic %>(<%= this_arg %>index: int, value: <%= el_type %>): <%= this_type %> {
    if (index < 0) {
        index += <%= this_len_int %>;
    }
    if (index < 0 || index >= <%= this_len_int %>) {
        throw new RangeError("Invalid index")
    }
    let arr = <%= clone_this %>;
    <%= set_unsafe.('arr', 'index', 'value') %>;
    return arr
}

/**
 * Returns a new Array Iterator object that contains the values for each index in the array.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `values` on.<% end %>
 * @returns { IterableIterator<<%= el_type %>> } A new Array Iterator object.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> values<%= this_generic %>(<%= this_arg.chomp(', ') %>): IterableIterator<<%= el_type %>> {
    return new ArrayValuesIterator_<%= el_type %><%= this_iterator_generic || this_generic %>(<%= this %>);
}

/**
 * Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
 *
     <% if this_arg != "" %>* @param { <%= this_type %> } self The array to operate `entries` on.<% end %>
 * @returns {IterableIterator<[number, T]> } A new Array Iterator object.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
<%= access_public %> <%= override %> entries<%= this_generic %>(<%= this_arg.chomp(', ') %>): IterableIterator<[number, <%= el_type %>]> {
    return new ArrayEntriesIterator_<%= el_type %><%= this_iterator_generic || this_generic %>(<%= this %>);
}
