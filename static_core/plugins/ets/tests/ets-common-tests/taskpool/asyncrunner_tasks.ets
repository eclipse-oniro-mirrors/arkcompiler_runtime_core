/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function returnAbc() {
    return (() => 'a')() + (() => 'b')() + (() => 'c')();
}

function sum(a: int, b: int): int {
    return a + b;
}

function max(a: int, b: int): int {
    return (a > b) ? a : b;
}

function launchImpl(func: () => Any): Promise<Any> {
    const job: Job<Any> = launch<Any, () => Any>(
        func
    );
    return new Promise<Any>((resolve, reject) => {
        try {
            let res = job.Await();
            resolve(res);
        } catch (e) {
            reject(e as Error);
        }
    });
}

async function executePeriodicallyTest() {
    CoroutineExtras.setSchedulingPolicy(CoroutineExtras.POLICY_NON_MAIN);
    let runner = new taskpool.AsyncRunner("testRunner", 3);
    let task1 = new taskpool.Task(returnAbc);
    await runner.execute(task1);
    arktest.expectError(() => {
        taskpool.executePeriodically(100, task1);
    }, new Error('taskpool:: The concurrent task has been executed and cannot be executed periodically'));
    try {
        let res2 = await launchImpl(testPeriodFunc);
        arktest.assertEQ(res2, 'success');
    } catch (e) {
        // NOTE(wangzhaoyong, #25035): del try catch when fix stackoverflow and invalid error message
        arktest.assertEQ(e instanceof LinkerUnresolvedClassError, true);
    }
    CoroutineExtras.setSchedulingPolicy(CoroutineExtras.POLICY_ANY);
}

function testPeriodFunc(): Any {
    let task = new taskpool.Task(sum, 80, 90);
    taskpool.executePeriodically(200, task);
    let isTaskCanceled: AtomicFlag = new AtomicFlag(false);
    
    let runner = new taskpool.AsyncRunner("testRunner", 3);
    arktest.expectError(() => {
        runner.execute(task);
    }, new Error('taskpool:: asyncRunner cannot execute executedTask'));
    
    taskpool.cancel(task);
    return 'success';
}

async function orderTest() {
    let resultStr: string = '';
    let func1 = (): string => {
        resultStr += '1';
        return resultStr;
    }
    let func2 = (): string => {
        resultStr += '2';
        return resultStr;
    }
    let func3 = (): string => {
        resultStr += '3';
        return resultStr;
    }
    let runner = new taskpool.AsyncRunner("testRunner", 3);
    let task1 = new taskpool.Task(func1);
    let task2 = new taskpool.Task(func2);
    let task3 = new taskpool.Task(func3);
    let p1 = runner.execute(task1);
    let p2 = runner.execute(task2);
    let p3 = runner.execute(task3);
    let res2 = await p2;
    arktest.assertEQ(res2, '12');
    let res3 = await p3;
    arktest.assertEQ(res3, '123');
    let res1 = await p1;
    arktest.assertEQ(res1, '1');
    arktest.assertEQ(resultStr, '123');
    arktest.assertEQ(task1.isDone(), true);
    arktest.assertEQ(task2.isDone(), true);
    arktest.assertEQ(task3.isDone(), true);
    let longTask = new taskpool.LongTask(returnAbc);
    let res = await runner.execute(longTask);
    arktest.assertEQ(res, 'abc');
}

function executeCommonTest(){
    let runner = new taskpool.AsyncRunner("testRunner", 3);
    let task = new taskpool.Task(returnAbc);
    taskpool.execute(task);
    arktest.expectError(() => { 
        runner.execute(task) 
    }, new Error('taskpool:: asyncRunner cannot execute executedTask'));
}

function executeAsyncRunnerTaskTest() {
    let runner1 = new taskpool.AsyncRunner("testRunner", 3, 5);
    let runner2 = new taskpool.AsyncRunner("testRunner", 3, 5);

    let task = new taskpool.Task(returnAbc);
    runner1.execute(task);
    arktest.expectError(() => { 
        runner2.execute(task) 
    },new Error('taskpool:: asyncRunner cannot execute executedTask'));
}

function executeGroupTaskTest() {
    let runner = new taskpool.AsyncRunner("testRunner", 3, 5);

    let group = new taskpool.TaskGroup();
    let task = new taskpool.Task(returnAbc);
    group.addTask(task);
    arktest.expectError(() => { 
        runner.execute(task) 
    }, new Error('taskpool:: asyncRunner cannot execute groupTask'));
}

async function cancelNonStartedTaskTest() {
    let task = new taskpool.Task(returnAbc);
    let runner = new taskpool.AsyncRunner("testRunner", 3, 5);

    arktest.expectError(() => {
        taskpool.cancel(task); 
        runner.execute(task);
    }, new Error('taskpool:: task is not executed or has been executed'));
    let t1 = new taskpool.Task(sum, 10, 20);
    let res1 = await runner.execute(t1);
    arktest.assertEQ(res1, 30);
    let t2 = new taskpool.Task(max, 80, 30);
    let res2 = await runner.execute(t2);
    arktest.assertEQ(res2, 80);
}

function addDependencyExecutedTaskTest() {
    let task1 = new taskpool.Task(returnAbc);
    let task2 = new taskpool.Task(returnAbc);
    let runner = new taskpool.AsyncRunner("testRunner", 3, 5);
    runner.execute(task2);
    arktest.expectError(() => { task1.addDependency(task2) }, new Error('taskpool:: asyncRunnerTask or seqRunnerTask or executedTask cannot be relied on'));
    arktest.expectError(() => { task2.addDependency(task1) }, new Error('taskpool:: asyncRunnerTask or seqRunnerTask or executedTask cannot addDependency'));
}

async function cancelExecutingTaskTest() {
    let task = new taskpool.Task(returnAbc);
    let runner = new taskpool.AsyncRunner("testRunner", 3, 5);

    let p = runner.execute(task);
    try {
        taskpool.cancel(task);
    } catch (e) {
        let err = e as Error;
        arktest.assertEQ(err.message, 'taskpool:: asyncRunner task has been executed');
        return undefined;
    }
    arktest.expectError(() => { let res = waitForCompletion<Any>(() => p); }, new Error('taskpool:: asyncRunner task has been canceled'));
}

async function cancelExecutedTaskTest() {
    let task = new taskpool.Task(returnAbc);
    let runner = new taskpool.AsyncRunner("testRunner", 3, 5);
    arktest.expectError(() => {
        await runner.execute(task);
        taskpool.cancel(task);
    }, new Error('taskpool:: asyncRunner task has been executed'));
    let t1 = new taskpool.Task(sum, 10, 20);
    let res1 = await runner.execute(t1);
    arktest.assertEQ(res1, 30);
    let t2 = new taskpool.Task(max, 80, 30);
    let res2 = await runner.execute(t2);
    arktest.assertEQ(res2, 80);
}

function addDependentTaskTest() {
    let task1 = new taskpool.Task(returnAbc);
    let task2 = new taskpool.Task(returnAbc);
    task1.addDependency(task2);
    let runner = new taskpool.AsyncRunner("testRunner", 3, 5);
    arktest.expectError(() => { 
        runner.execute(task1) 
    }, new Error('taskpool:: asyncRunner dependent task not allowed.'));
}

async function taskWithDifferentParamsTest() {
    let testWithZeroParam = (): string => {
        return 'testWithZeroParam';
    }
    let testWithOneParam = (num: int): int => {
        return num * 2;
    }
    let testWithThreeParams = (a: number, str: string, b: number): string => {
        let sum: number = a + b;
        return 'testWithThreeParams res: ' + sum;
    }
    let testWithFiveParams = (a: number, b: number, c: number, flag: boolean, str: string): string => {
        let res: number = 0;
        if (flag) {
            res = a + b + c;
        } else {
            res = a * b * c;
        }
        return str + ' res: ' + res;
    }

    let task1 = new taskpool.Task(testWithZeroParam);
    let task2 = new taskpool.Task(testWithOneParam, 25);
    let task3 = new taskpool.Task(testWithThreeParams, 10.0, 'task3', 20.0);
    let task4 = new taskpool.Task(testWithFiveParams, 1.0, 2.0, 3.0, true, 'TEST');

    let runner = new taskpool.AsyncRunner("testRunner", 3);
    let res1 = await runner.execute(task1);
    let res2 = await runner.execute(task2);
    let res3 = await runner.execute(task3);
    let res4 = await runner.execute(task4);

    arktest.assertEQ(res1, 'testWithZeroParam');
    arktest.assertEQ(res2, 50);
    arktest.assertEQ(res3, 'testWithThreeParams res: 30');
    arktest.assertEQ(res4, 'TEST res: 6');

    arktest.assertEQ(task1.isDone(), true);
    arktest.assertEQ(task2.isDone(), true);
    arktest.assertEQ(task3.isDone(), true);
    arktest.assertEQ(task4.isDone(), true);
}

function printArgs(taskName: int){

}

async function testExecute() {
    const runner = new taskpool.AsyncRunner("test", 5);
    let num = 0;
    for(let i =  0; i < 30; i++){
        let task: taskpool.Task = new taskpool.Task(`Task${i}`, printArgs, i);
            await runner.execute(task, taskpool.Priority.HIGH).then((res) => {
            num++;
        }).catch((e) => {
            num++;
        })
    }
    arktest.assertEQ(num, 30);
}

async function testWaitingDiacard() {
    const runner = new taskpool.AsyncRunner("testexecute", 3, 5);
    let num = 0;
    for(let i = 0; i < 30; i++){
        let task: taskpool.Task = new taskpool.Task(`Task${i}`, printArgs, i);
        await runner.execute(task, taskpool.Priority.HIGH).then((res) => {
            num++;
        }).catch((e) => {
            num++;
        })
    }
    arktest.assertEQ(num, 30);
    
}

async function testDiscardHeadStrategy(): Promise<void> {
    const runner = new taskpool.AsyncRunner("discard_head_test", 2, 2);

    const completedTasks: number[] = [];
    const discardedTasks: number[] = [];

    const createTask = (index: number, duration: number = 100): Promise<Any> => {
        const task = new taskpool.Task((index: number, dur: number) => {
            const start = Date.now();
            while (Date.now() - start < 100) {

            }
            completedTasks.push(index);
            return `Task ${index} completed`;
        }, index, duration);
        
        return runner.execute(task).catch((e: Error) => {
            if (e.message.includes("waiting queue dropped head")) {
                discardedTasks.push(index);
                return `Task ${index} discarded`;
            }
            throw e;
        });

    };

    const tasks = [
        createTask(0, 200), // longtask to ensure not executed immediately
        createTask(1, 200), // 
        createTask(2),      // join in waiting queue
        createTask(3),      // 
        createTask(4)       // trigger DISCARD_HEAD and drop task2
    ];

    const results = await Promise.allSettled(tasks);

    arktest.assertEQ(discardedTasks.length, 1, "Exactly one task should be discarded");
    arktest.assertEQ(discardedTasks[0], 2, "Task 2 (head of queue) should be discarded");
}

// test  runningCapacity == 0 || waitingCapacity < 0 in constructor 
async function testEdgeConstructor(): Promise<void> {

    // runningCapacity == 0
    arktest.expectError(() => { 
        new taskpool.AsyncRunner("test2", 0, 2); 
    }, new Error('taskpool:: runningCapacity must be a positive number'));


    // waitingCapacity < 0
    arktest.expectError(() => { 
        new taskpool.AsyncRunner("test2", 2, -2); 
    }, new Error('taskpool:: watingCapacity must be a non-negative number'));
}


function main(): int {
    let asyncRunnerSuite = new arktest.ArkTestsuite('taskpool.AsyncRunner');

    asyncRunnerSuite.addAsyncTest('ExecutePeriodicallyTest', executePeriodicallyTest);
    asyncRunnerSuite.addTest('ExecuteCommonTest', executeCommonTest);
    asyncRunnerSuite.addTest('ExecuteAsyncRunnerTaskTest', executeAsyncRunnerTaskTest);
    asyncRunnerSuite.addTest('ExecuteGroupTaskTest', executeGroupTaskTest);
    asyncRunnerSuite.addAsyncTest('CancelNonStartedTaskTest', cancelNonStartedTaskTest);
    asyncRunnerSuite.addAsyncTest('CancelExecutingTaskTest', cancelExecutingTaskTest);
    asyncRunnerSuite.addAsyncTest('CancelExecutedTaskTest', cancelExecutedTaskTest);
    asyncRunnerSuite.addTest('AddDependentTaskTest', addDependentTaskTest);
    asyncRunnerSuite.addTest('AddDependencyExecutedTaskTest', addDependencyExecutedTaskTest);
    asyncRunnerSuite.addAsyncTest('TaskWithDifferentParamsTest', taskWithDifferentParamsTest);
    asyncRunnerSuite.addAsyncTest('TestExecute', testExecute); 
    asyncRunnerSuite.addAsyncTest('TestDiscardHeadStrategy', testDiscardHeadStrategy);
    asyncRunnerSuite.addAsyncTest('TestEdgeConstructor', testEdgeConstructor);
    asyncRunnerSuite.addAsyncTest('TestWaitingDiacard', testWaitingDiacard); 
    

    let res = asyncRunnerSuite.run();
    CoroutineExtras.stopTaskpool();
    return res;
}