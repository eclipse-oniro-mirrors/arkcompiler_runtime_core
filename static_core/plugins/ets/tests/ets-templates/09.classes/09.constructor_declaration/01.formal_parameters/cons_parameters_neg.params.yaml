# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
  - decl: |-
      class A {
          fld: (null|(p: number) => number)[]
          constructor(p: readonly (null|(p: number) => number)[]) {
              this.fld = p // CTE: cannot assign readonly array to read-write array
          }
      }

  - decl: |-
      class A {
          fld: ReadonlyArray<null|(p: number) => number>
          constructor(p: readonly (null|(p: number) => number)[]) {
              this.fld = p
              p[0] = null // CTE: cannot change an element of readonly array
          }
      }

  - decl: |-
      class A {
          fld: ReadonlyArray<null|(p: number) => number>
          constructor(p: readonly (null|(p: number) => number)[]) {
              this.fld = p
              this.fld[0] = null // CTE: cannot change an element of ReadonlyArray
          }
      }

  - decl: |-
      class A {
          fld: [FixedArray<string>, (p: string) => Array<string>]
          constructor(p: readonly [FixedArray<string>, (p: string) => Array<string>]) {
              this.fld = p // CTE: cannot assign readonly tuple to read-write tuple
          }
      }

  - decl: |-
      class A {
          fld: readonly [FixedArray<string>, (p: string) => Array<string>]
          constructor(p: readonly [FixedArray<string>, (p: string) => Array<string>]) {
              this.fld = p
              p[0] = ['x', 'y']  // CTE: cannot change an element of readonly tuple
          }
      }

  - decl: |-
      class A {
          fld: readonly [FixedArray<string>, (p: string) => Array<string>]
          constructor(p: readonly [FixedArray<string>, (p: string) => Array<string>]) {
              this.fld = p
              this.fld[0] = ['x', 'y']  // CTE: cannot change an element of readonly tuple
          }
      }

  - decl: |-
      class A {
          fld: Array<byte|short|int|undefined>
          constructor(b?: byte, s: short, i?: int) { // CTE: required parameter after optional
              this.fld = [b, s, i]
          }
      }

  - decl: |-
      enum Color { Red, Green, Blue }
      class A {
          p: Color
          q: boolean
          constructor(p: Color = Color.Green, q: boolean) { // CTE: required parameter after optional
              this.p = p
              this.q = q
          }
      }

  - decl: |-
      class A {
          fld: readonly Any[][]
          constructor(...p: readonly Any[][]) {
              this.fld = p
              p[0] = [new Object] // CTE: cannot update readonly array
          }
      }

  - decl: |-
      class A {
          fld: ReadonlyArray<ReadonlyArray<Any>>
          constructor(...p: readonly Array<Array<Any>>) {
              this.fld = p
              p[0] = [new Object] // CTE: cannot update readonly array
          }
      }

  - decl: |-
      class A {
          fld: [string, string, number]
          constructor(...p: [string, string, double]) {
              this.fld = p
          }
      }
    use: |-
      let a = new A('abc', 'def') // CTE: not enough arguments

  - decl: |-
      class A {
          fld: [string, string, number]
          constructor(...p: [string, string, double]) {
              this.fld = p
          }
      }
    use: |-
      let a = new A('abc', 'def', 1.0, 2.0) // CTE: too many arguments

  - decl: |-
      class A {
          fld: [string, string, number]
          constructor(...p: [string, string, double]) {
              this.fld = p
          }
      }
    use: |-
      let a = new A(true, 'abc', 2.0) // CTE: wrong argument type

  - decl: |-
      class A {
          fld: readonly [string|undefined, string|null]
          constructor(...p: readonly [string|undefined, string|null]) {
              this.fld = p
              p[0] = undefined // CTE: cannot update readonly tuple
          }
      }

  - decl: |-
      class A {
          fld: FixedArray<number>
          constructor(...p: FixedArray<number>) {
              this.fld = p
          }
      }
    use: |-
      // CTE: spread argument must correspond to rest parameter
      let a = new A(12.0, ...([ 13.0, 14.0 ] as FixedArray<number>))

  - decl: |-
      class A {
          tup: readonly [boolean, string, number|undefined]
          constructor(...tup: [boolean, string, number|undefined]) {
              this.tup = tup
          }
      }
      let tup: [string, number|undefined] = [ 'abc', undefined ]
    use: |-
      let a = new A(true, ...tup) // CTE: spread argument must correspond to rest parameter

  - decl: |-
      class A {
          tup: readonly [boolean, string, number|undefined]
          constructor(...tup: [boolean, string, number|undefined]) {
              this.tup = tup
          }
      }
      let tup: [string, number|undefined] = [ 'abc', undefined ]
    use: |-
      let a = new A(...tup) // CTE: wrong number of arguments

  - decl: |-
      class A {
          p: Object[]
          constructor(...obj: Object[]) {
              this.p = obj
          }
      }
      let arr: number[] = [0.0, 1.0, 2.0]
    use: |-
      let a = new A(...arr) // CTE: wrong type array
