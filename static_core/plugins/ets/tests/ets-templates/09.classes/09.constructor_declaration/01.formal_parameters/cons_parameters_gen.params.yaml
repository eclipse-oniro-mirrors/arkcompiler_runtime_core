# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    - decl: |-
          enum Color { Red, Green, Blue }
          enum Country { cn = 'China', ru = 'Russia', us = 'USA', fr = 'France'  }

          class A<T, U> {
              color: T
              country: U
              constructor(color: T, country: U) {
                  this.color = color
                  this.country = country
              }
          }
      use: |-
          let a = new A<Color, Country>(Color.Blue, Country.fr)
          arktest.assertEQ(a.color, Color.Blue)
          arktest.assertEQ(a.country, Country.fr)

    # implicit conversion from enum
    - decl: |-
          enum Color { Red, Green, Blue }
          enum Country { cn = 'China', ru = 'Russia', us = 'USA', fr = 'France'  }

          class A<T extends int, U extends string> {
              color: T
              country: U
              constructor(color: T, country: U) {
                  this.color = color
                  this.country = country
              }
          }
      use: |-
          let a = new A<int, string>(Color.Blue, Country.fr) // implicit conversion
          arktest.assertEQ(a.color, 2)
          arktest.assertEQ(a.country, 'France')

    # readonly array
    - decl: |-
          class A<T> {
              fld: ReadonlyArray<T>
              constructor(p: readonly T[]) {
                  this.fld = p
              }
          }
          let arr = [(p: number) => p + 1.0, null, (p: number) => p + 2.0, (p: number) => p + 3.0]
      use: |-
          let a = new A<null|(p: number) => number>(arr)
          arktest.assertEQ(a.fld[0]!(42.0), 43.0)
          arktest.assertEQ(a.fld[1], null)

    - tags: 'compile-only, negative'
      decl: |-
          class A<T> {
              fld: (null|T)[]
              constructor(p: readonly (null|T)[]) {
                  this.fld = p // CTE: cannot assign readonly array to read-write array
              }
          }

    - tags: 'compile-only, negative'
      decl: |-
          class A<T, U> {
              fld: ReadonlyArray<T|U|null>
              constructor(p: readonly (T|U|null)[]) {
                  this.fld = p
                  p[0] = null // CTE: cannot change an element of readonly array
              }
          }

    - tags: 'compile-only, negative'
      decl: |-
          class A<T> {
              fld: ReadonlyArray<T|null>
              constructor(p: readonly (null|T)[]) {
                  this.fld = p
                  this.fld[0] = null // CTE: cannot change an element of ReadonlyArray
              }
          }

    # readonly tuple
    - decl: |-
          class A<T> {
              fld: readonly [FixedArray<T>, (p: T) => Array<T>]
              constructor(p: readonly [FixedArray<T>, (p: T) => Array<T>]) {
                  this.fld = p
              }
          }
          let tup: [FixedArray<string>, (p: string) => Array<string>] =
              [['a', 'b', 'c'], (p: string) => [p]]
      use: |-
          let a = new A<string>(tup)
          arktest.assertEQ(a.fld[1]('hello')[0], 'hello')
          arktest.assertEQ(a.fld, tup)

    - tags: 'compile-only, negative'
      decl: |-
          class A<T, U> {
              fld: [T, U]
              constructor(p: readonly [T, U]) {
                  this.fld = p // CTE: cannot assign readonly tuple to read-write tuple
              }
          }

    - tags: 'compile-only, negative'
      decl: |-
          class A<T extends string[], U> {
              fld: readonly [T, U]
              constructor(p: readonly [T, U]) {
                  this.fld = p
                  p[0] = ['x', 'y']  // CTE: cannot change an element of readonly tuple
              }
          }

    - tags: 'compile-only, negative'
      decl: |-
          class A<T extends string, U> {
              fld: readonly [FixedArray<T>, (p: T) => Array<T>]
              constructor(p: readonly [FixedArray<T>, (p: T) => Array<T>]) {
                  this.fld = p
                  this.fld[0] = ['x', 'y']  // CTE: cannot change an element of readonly tuple
              }
          }

    # optional parameters
    - decl: |-
          class A<T> {
              p: T|boolean
              q: undefined|(p: T) => string
              constructor(p: undefined|T, q?: (p: T) => string) {
                  this.p = p ?? false
                  this.q = q
              }
          }
      use: |-
          let a = new A<boolean>(true, (p: boolean) => p ? 'T' : 'F')
          arktest.assertEQ(a.p, true)
          arktest.assertEQ(a.q!(true), 'T')

          a = new A<boolean>(undefined)
          arktest.assertEQ(a.p, false)
          arktest.assertEQ(a.q, undefined)

          a = new A<boolean>(undefined, undefined)
          arktest.assertEQ(a.p, false)
          arktest.assertEQ(a.q, undefined)

          a = new A<boolean>(false, undefined)
          arktest.assertEQ(a.p, false)
          arktest.assertEQ(a.q, undefined)

    - decl: |-
          class A<T> {
              p: undefined|ReadonlyArray<T>
              constructor(p?: readonly T[]) {
                  this.p = p
              }
          }
      use: |-
          let a = new A<string>(['a', 'b', 'c'])
          arktest.assertEQ(a.p![0], 'a')
          arktest.assertEQ(a.p![2], 'c')

          arktest.assertEQ(new A<number>().p, undefined)
          arktest.assertEQ(new A<undefined>(undefined).p, undefined)

    - decl: |-
          class A<T, U = undefined, V = undefined> {
              fld: Array<T|U|V|undefined>
              constructor(b?: T, s?: U, i?: V) {
                  this.fld = [b, s, i]
              }
          }
          let b = (1).toByte()
          let s = (2).toShort()
      use: |-
          let a1 = new A<byte, short, int>(b, b, b)  // with implicit widening conversion
          arktest.assertEQ(a1.fld[0], 1)
          arktest.assertEQ(a1.fld[1], 1)
          arktest.assertEQ(a1.fld[2], 1)

          let a2 = new A<undefined>()
          arktest.assertEQ(a2.fld[0], undefined)
          arktest.assertEQ(a2.fld[1], undefined)
          arktest.assertEQ(a2.fld[2], undefined)

          let a3 = new A<byte>(b)
          arktest.assertEQ(a3.fld[0], 1)
          arktest.assertEQ(a3.fld[1], undefined)
          arktest.assertEQ(a3.fld[2], undefined)

          let a4 = new A<byte, short>(b, s)
          arktest.assertEQ(a4.fld[0], 1)
          arktest.assertEQ(a4.fld[1], 2)
          arktest.assertEQ(a4.fld[2], undefined)

          let a5 = new A<byte, short, int>(b, s, 42)
          arktest.assertEQ(a5.fld[0], 1)
          arktest.assertEQ(a5.fld[1], 2)
          arktest.assertEQ(a5.fld[2], 42)

          let a6 = new A<undefined>(undefined)
          arktest.assertEQ(a6.fld[0], undefined)
          arktest.assertEQ(a6.fld[1], undefined)
          arktest.assertEQ(a6.fld[2], undefined)

    - decl: |-
          class A<T> {
              fld?: T
              constructor(p?: T|undefined) { // redundant undefined
                  this.fld = p
              }
          }
      use: |-
          arktest.assertEQ(new A<number|string|Error>().fld, undefined)
          arktest.assertEQ(new A<number|string|Error>(undefined).fld, undefined)
          arktest.assertEQ(new A<number|string|Error>(42.0).fld, 42.0)

    - tags: 'compile-only, negative'
      decl: |-
          class A<T, U, V> {
              fld: Array<T|U|V|undefined>
              constructor(b?: T, s: U, i?: V) { // CTE: required parameter after optional
                  this.fld = [b, s, i]
              }
          }

    # optional parameters with default value
    - decl: |-
          class A<T> {
              p: (p: int) => string
              q: (p: T) => string
              constructor(p: (p: int) => string, q: (p: T) => string = (p: T) => 'X' + p) {
                  this.p = p
                  this.q = q
              }
          }
      use: |-
          let a1 = new A<number>(
              (p: int) => 'Z' + p,
              (p: number) => 'A' + p
          )
          arktest.assertEQ(a1.p(42), 'Z42')
          arktest.assertEQ(a1.q(42.0), 'A42')

          let a2 = new A<string>(
              (p: int) => 'Z' + p
          )
          arktest.assertEQ(a2.p(42), 'Z42')
          arktest.assertEQ(a2.q('YZ'), 'XYZ')

    - tags: 'compile-only, negative'
      decl: |-
          enum Color { Red, Green, Blue }
          class A<T> {
              p: Color
              q: T
              constructor(p: Color = Color.Green, q: T) { // CTE: required parameter after optional
                  this.p = p
                  this.q = q
              }
          }

    # rest parameter with [] array
    - decl: |-
          class A<T> {
              fld: T[]
              constructor(...p: T[]) {
                  this.fld = p
              }
          }
      use: |-
          arktest.assertEQ(new A<byte>().fld.length, 0)

          let a = new A<Object>(1, 2.0, '3', [false])
          arktest.assertEQ(a.fld[0], 1)
          arktest.assertEQ(a.fld[1], 2.0)
          arktest.assertEQ(a.fld[2], '3')
          arktest.assertEQ((a.fld[3] as Object[])[0], false)

    - decl: |-
          class A<T> {
              fld: readonly T[][]
              constructor(...p: readonly T[][]) {
                  this.fld = p
              }
          }
      use: |-
          arktest.assertEQ(new A<Object>().fld.length, 0)

          let a = new A<string>(['abc', 'def'])
          arktest.assertEQ(a.fld.length, 1)
          arktest.assertEQ(a.fld[0][0], 'abc')

    - tags: 'compile-only, negative'
      decl: |-
          class A<T extends Object> {
              fld: readonly T[][]
              constructor(...p: readonly T[][]) {
                  this.fld = p
                  p[0] = [new Object] // CTE: cannot update readonly array
              }
          }

    # rest parameter with Array<T> array
    - decl: |-
          class A<T> {
              fld: (T|number|string|Array<boolean>)[]
              constructor(...p: Array<T|number|string|Array<boolean>>) {
                  this.fld = p
              }
          }
      use: |-
          arktest.assertEQ(new A<int>().fld.length, 0)

          let a = new A<int>(1, 2.0, '3', [false])
          arktest.assertEQ(a.fld[0], 1)
          arktest.assertEQ(a.fld[1], 2.0)
          arktest.assertEQ(a.fld[2], '3')
          arktest.assertEQ((a.fld[3] as Array<boolean>)[0], false)

    - decl: |-
          class A<T> {
              fld: ReadonlyArray<ReadonlyArray<T>>
              constructor(...p: readonly Array<Array<T>>) {
                  this.fld = p
              }
          }
      use: |-
          arktest.assertEQ(new A<int>().fld.length, 0)

          let a = new A<string>(['abc', 'def'])
          arktest.assertEQ(a.fld.length, 1)
          arktest.assertEQ(a.fld[0][0], 'abc')

    - tags: 'compile-only, negative'
      decl: |-
          class A<T> {
              fld: ReadonlyArray<ReadonlyArray<T|null>>
              constructor(...p: readonly Array<Array<T|null>>) {
                  this.fld = p
                  p[0] = [null] // CTE: cannot update readonly array
              }
          }

    # rest parameter with FixedArray<T> array
    - decl: |-
          class A<T> {
              fld: FixedArray<T|null>
              constructor(...p: FixedArray<T|null>) {
                  this.fld = p
              }
          }
      use: |-
          arktest.assertEQ(new A<string>().fld.length, 0)

          let a = new A<Object>(1, 2.0, '3', null)
          arktest.assertEQ(a.fld[0], 1)
          arktest.assertEQ(a.fld[1], 2.0)
          arktest.assertEQ(a.fld[2], '3')
          arktest.assertEQ(a.fld[3], null)

    - decl: |-
          class A<T> {
              fld: FixedArray<FixedArray<T>>
              constructor(...p: FixedArray<FixedArray<T>>) {
                  this.fld = p
              }
          }
      use: |-
          let a = new A<string>(['abc', 'def'] as FixedArray<string>)
          arktest.assertEQ(a.fld.length, 1)
          arktest.assertEQ(a.fld[0][0], 'abc')

    # rest parameter with tuple
    - decl: |-
          class A<T> {
              fld: [string, T]
              constructor(...p: [string, T]) {
                  this.fld = p
              }
          }
      use: |-
          let a = new A<(p: boolean) => string>('abc', (p: boolean): string => 'result = ' + p)
          arktest.assertEQ(a.fld[0], 'abc')
          arktest.assertEQ(a.fld[1](true), 'result = true')

    - tags: 'compile-only, negative'
      decl: |-
          class A<T, U> {
              fld: [T, T, U]
              constructor(...p: [T, T, U]) {
                  this.fld = p
              }
          }
      use: |-
          let a = new A<string, number>('abc', 'def') // CTE: not enough arguments

    - tags: 'compile-only, negative'
      decl: |-
          class A<T, U> {
              fld: [T, T, U]
              constructor(...p: [T, T, U]) {
                  this.fld = p
              }
          }
      use: |-
          let a = new A<string, number>('abc', 'def', 1.0, 2.0) // CTE: too many arguments

    - tags: 'compile-only, negative'
      decl: |-
          class A<T, U> {
              fld: [T, T, U]
              constructor(...p: [T, T, U]) {
                  this.fld = p
              }
          }
      use: |-
          let a = new A<string, number>(true, 'abc', 2.0) // CTE: wrong argument type

    - decl: |-
          class A<T, U, V> {
              fld: readonly [T, U|V]
              constructor(...p: readonly [T, U|V]) {
                  this.fld = p
              }
          }
      use: |-
          let a = new A<Any, null, boolean>('abc', null)
          arktest.assertEQ(a.fld[0], 'abc')
          arktest.assertEQ(a.fld[1], null)

    - tags: 'compile-only, negative'
      decl: |-
          class A<T, V, W> {
              fld: readonly [T|undefined, V|W]
              constructor(...p: readonly [T|undefined, V|W]) {
                  this.fld = p
                  p[0] = undefined // CTE: cannot update readonly tuple
              }
          }

    # [] spread to rest
    - decl: |-
          class A<T> {
              p: T[]
              constructor(...any: T[]) {
                  this.p = any
              }
          }
          let arr: Any[] = [0, 1, 2]
      use: |-
          let a = new A<Any>(...arr)
          arktest.assertEQ(a.p[0], 0)
          arktest.assertEQ(a.p[1], 1)
          arktest.assertEQ(a.p[2], 2)

    - tags: 'compile-only, negative'
      decl: |-
          class A<T> {
              p: T[]
              constructor(...obj: T[]) {
                  this.p = obj
              }
          }
          let arr: number[] = [0.0, 1.0, 2.0]
      use: |-
          let a = new A<Object>(...arr) // CTE: wrong type array

    # Array spread to rest
    - decl: |-
          enum Country { cn = 'China', ru = 'Russia', us = 'USA', fr = 'France'  }
          class A<T> {
              i: int
              p: Array<T>
              constructor(i: int, ...p: Array<T>) {
                  this.i = i
                  this.p = p
              }
          }
          let arr: FixedArray<string|Country>[] = [[Country.us, Country.ru], ['br', Country.fr, 'de']]
      use: |-
          let a = new A<FixedArray<string|Country>>(1, ...arr)
          arktest.assertEQ(a.p[0][0], Country.us)
          arktest.assertEQ(a.p[0][1], Country.ru)
          arktest.assertEQ(a.p[1][0], 'br')
          arktest.assertEQ(a.p[1][1], Country.fr)
          arktest.assertEQ(a.p[1][2], 'de')

    - decl: |-
          class A<T, U> {
              q: Array<T|U>
              constructor(p: T|U, ...q: Array<T|U>) {
                  this.q = q
                  this.q.push(p)
              }
          }
      use: |-
          let a = new A<string, number>('d', ...((): Array<string|number> => ['a', 'b', 'c'])())
          arktest.assertEQ(a.q[0], 'a')
          arktest.assertEQ(a.q[1], 'b')
          arktest.assertEQ(a.q[2], 'c')
          arktest.assertEQ(a.q[3], 'd')

    # FixedArray spread to rest
    - decl: |-
          class A<T> {
              fld: FixedArray<T>
              constructor(...p: FixedArray<T>) {
                  this.fld = p
              }
          }
      use: |-
          let a = new A<int>(...((p: int): FixedArray<int> => [p, p, p])(5))
          arktest.assertEQ(a.fld.length, 3)
          arktest.assertEQ(a.fld[0], 5)
          arktest.assertEQ(a.fld[1], 5)
          arktest.assertEQ(a.fld[2], 5)

    - tags: 'compile-only, negative'
      decl: |-
          class A<T> {
              fld: FixedArray<T>
              constructor(...p: FixedArray<T>) {
                  this.fld = p
              }
          }
      use: |-
          // CTE: spread argument must correspond to rest parameter
          let a = new A<number>(12.0, ...([ 13.0, 14.0 ] as FixedArray<number>))

    - decl: |-
          class A<T> {
              p: FixedArray<T>
              constructor(...arr: FixedArray<T>) {
                  this.p = arr
              }
          }
          let arr: FixedArray<Object> = [0.0, 1.0, 2.0]
      use: |-
          let a = new A<Object>(...arr)
          arktest.assertEQ(a.p[0], 0.0)
          arktest.assertEQ(a.p[1], 1.0)
          arktest.assertEQ(a.p[2], 2.0)

    # tuple spread to rest
    - decl: |-
          class A<T, U, V> {
              tup: readonly [() => T, () => U, () => V]
              constructor(...tup: [() => T, () => U, () => V]) {
                  this.tup = tup
              }
          }
          let tup: [() => boolean, () => string, () => number] = [
              () => true,
              () => 'abc',
              () => 42.0
          ]
      use: |-
          let a = new A<boolean, string, number>(...tup)
          arktest.assertEQ(a.tup[0](), true)
          arktest.assertEQ(a.tup[1](), 'abc')
          arktest.assertEQ(a.tup[2](), 42.0)

    - tags: 'compile-only, negative'
      decl: |-
          class A<T, U, V> {
              tup: readonly [T, U, V|undefined]
              constructor(...tup: [T, U, V|undefined]) {
                  this.tup = tup
              }
          }
          let tup: [string, number|undefined] = [ 'abc', undefined ]
      use: |-
          let a = new A<boolean, string, number>(true, ...tup) // CTE: spread argument must correspond to rest parameter

    - tags: 'compile-only, negative'
      decl: |-
          class A<T, U, V> {
              tup: readonly [T, U, V|undefined]
              constructor(...tup: [T, U, V|undefined]) {
                  this.tup = tup
              }
          }
          let tup: [string, number|undefined] = [ 'abc', undefined ]
      use: |-
          let a = new A<boolean, string, number>(...tup) // CTE: wrong number of arguments
