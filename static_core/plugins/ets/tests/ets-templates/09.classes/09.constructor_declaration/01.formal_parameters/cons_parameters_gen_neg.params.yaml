# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    - decl: |-
          class A<T> {
              fld: (null|T)[]
              constructor(p: readonly (null|T)[]) {
                  this.fld = p // CTE: cannot assign readonly array to read-write array
              }
          }

    - decl: |-
          class A<T, U> {
              fld: ReadonlyArray<T|U|null>
              constructor(p: readonly (T|U|null)[]) {
                  this.fld = p
                  p[0] = null // CTE: cannot change an element of readonly array
              }
          }

    - decl: |-
          class A<T> {
              fld: ReadonlyArray<T|null>
              constructor(p: readonly (null|T)[]) {
                  this.fld = p
                  this.fld[0] = null // CTE: cannot change an element of ReadonlyArray
              }
          }

    # readonly tuple
    - decl: |-
          class A<T, U> {
              fld: [T, U]
              constructor(p: readonly [T, U]) {
                  this.fld = p // CTE: cannot assign readonly tuple to read-write tuple
              }
          }

    - decl: |-
          class A<T extends string[], U> {
              fld: readonly [T, U]
              constructor(p: readonly [T, U]) {
                  this.fld = p
                  p[0] = ['x', 'y']  // CTE: cannot change an element of readonly tuple
              }
          }

    - decl: |-
          class A<T extends string, U> {
              fld: readonly [FixedArray<T>, (p: T) => Array<T>]
              constructor(p: readonly [FixedArray<T>, (p: T) => Array<T>]) {
                  this.fld = p
                  this.fld[0] = ['x', 'y']  // CTE: cannot change an element of readonly tuple
              }
          }

    # optional parameters
    - decl: |-
          class A<T, U, V> {
              fld: Array<T|U|V|undefined>
              constructor(b?: T, s: U, i?: V) { // CTE: required parameter after optional
                  this.fld = [b, s, i]
              }
          }

    # optional parameters with default value
    - decl: |-
          enum Color { Red, Green, Blue }
          class A<T> {
              p: Color
              q: T
              constructor(p: Color = Color.Green, q: T) { // CTE: required parameter after optional
                  this.p = p
                  this.q = q
              }
          }

    # rest parameter with [] array
    - decl: |-
          class A<T extends Object> {
              fld: readonly T[][]
              constructor(...p: readonly T[][]) {
                  this.fld = p
                  p[0] = [new Object] // CTE: cannot update readonly array
              }
          }

    # rest parameter with Array<T> array
    - decl: |-
          class A<T> {
              fld: ReadonlyArray<ReadonlyArray<T|null>>
              constructor(...p: readonly Array<Array<T|null>>) {
                  this.fld = p
                  p[0] = [null] // CTE: cannot update readonly array
              }
          }

    # rest parameter with tuple
    - decl: |-
          class A<T, U> {
              fld: [T, T, U]
              constructor(...p: [T, T, U]) {
                  this.fld = p
              }
          }
      use: |-
          let a = new A<string, number>('abc', 'def') // CTE: not enough arguments

    - decl: |-
          class A<T, U> {
              fld: [T, T, U]
              constructor(...p: [T, T, U]) {
                  this.fld = p
              }
          }
      use: |-
          let a = new A<string, number>('abc', 'def', 1.0, 2.0) // CTE: too many arguments

    - decl: |-
          class A<T, U> {
              fld: [T, T, U]
              constructor(...p: [T, T, U]) {
                  this.fld = p
              }
          }
      use: |-
          let a = new A<string, number>(true, 'abc', 2.0) // CTE: wrong argument type

    - decl: |-
          class A<T, V, W> {
              fld: readonly [T|undefined, V|W]
              constructor(...p: readonly [T|undefined, V|W]) {
                  this.fld = p
                  p[0] = undefined // CTE: cannot update readonly tuple
              }
          }

    # [] spread to rest
    - decl: |-
          class A<T> {
              p: T[]
              constructor(...obj: T[]) {
                  this.p = obj
              }
          }
          let arr: number[] = [0.0, 1.0, 2.0]
      use: |-
          let a = new A<string>(...arr) // CTE: wrong type array

    - decl: |-
          class A<T, U, V> {
              tup: readonly [T, U, V|undefined]
              constructor(...tup: [T, U, V|undefined]) {
                  this.tup = tup
              }
          }
          let tup: [string, number|undefined] = [ 'abc', undefined ]
      use: |-
          let a = new A<boolean, string, number>(true, ...tup) // CTE: spread argument must correspond to rest parameter

    - decl: |-
          class A<T, U, V> {
              tup: readonly [T, U, V|undefined]
              constructor(...tup: [T, U, V|undefined]) {
                  this.tup = tup
              }
          }
          let tup: [string, number|undefined] = [ 'abc', undefined ]
      use: |-
          let a = new A<boolean, string, number>(...tup) // CTE: wrong number of arguments
