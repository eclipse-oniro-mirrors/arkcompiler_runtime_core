# Copyright (c) 2025-2026 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

cases:
  - desc: |-
      >-
        Qualification by type is mandatory
        to access the enumeration constant
    check_variants:
      - decl_data: |-
          enum Color { Red, Green, Blue }
      - decl_data: |-
          const enum Color { Red, Green, Blue }
    decl: |-
      [decl_data]
    sub_cases_logic:
      - |-
        let c = Red
      - |-
        let c = Green
      - |-
        let c = Blue
    stdout:
      - |-
        "Semantic error ESE0143: Unresolved reference Red"
      - |-
        "Semantic error ESE0143: Unresolved reference Green"
      - |-
        "Semantic error ESE0143: Unresolved reference Blue"

  - desc: |-
      >-
        Enumeration type enum specifies a distinct user-defined type
        with an associated set of named constants that define its
        possible values.
        If constant expression is omitted, then the value of the enum
        constant is set implicitly to an integer value.
        params: modifying enum named constants values
    check_variants:
      - decl_data: |-
          enum Color { Red, Green, Blue }
      - decl_data: |-
          const enum Color { Red, Green, Blue }
    decl: |-
      [decl_data]
    sub_cases_logic:
      - |-
        Color.Red = 2
      - |-
        Color.Green = 3
      - |-
        Color.Blue = 4
    stdout:
      - |-
        "Semantic error ESE0318: Type 'Int' cannot be assigned to type 'Color'"
      - |-
        "Semantic error ESE0318: Type 'Int' cannot be assigned to type 'Color'"
      - |-
        "Semantic error ESE0318: Type 'Int' cannot be assigned to type 'Color'"

  - desc: |-
      >-
        Enumeration type enum specifies a distinct user-defined type
        with an associated set of named constants that define its
        possible values.
        If constant expression is omitted, then the value of the enum
        constant is set implicitly to an integer value.
        params: modifying enum named constants values
    check_variants:
      - decl_data: |-
          enum Color { Red, Green, Blue }
      - decl_data: |-
          const enum Color { Red, Green, Blue }
    decl: |-
      [decl_data]
    sub_cases_logic:
      - |-
        Color.Red = Color.Blue
      - |-
        Color.Green = Color.Blue
      - |-
        Color.Blue = Color.Red
    stdout:
      - |-
        "Semantic error ESE4002: Cannot assign to a readonly field Red"
      - |-
        "Semantic error ESE4002: Cannot assign to a readonly field Green"
      - |-
        "Semantic error ESE4002: Cannot assign to a readonly field Blue"

  - desc: |-
      >-
        Enumeration type enum specifies a distinct user-defined type
        with an associated set of named constants that define its
        possible values.
        params: modifying enum variable by int
    check_variants:
      - decl_data: |-
          enum Color { Red, Green, Blue }
      - decl_data: |-
          const enum Color { Red, Green, Blue }
    decl: |-
      [decl_data]
    sub_cases_logic:
      - |-
        let r: Color = Color.Red
        r = 3
      - |-
        let g: Color = Color.Green
        g = 4
      - |-
        let b: Color = Color.Blue
        b = 5
    stdout:
      - |-
        "Semantic error ESE0318: Type 'Int' cannot be assigned to type 'Color'"
      - |-
        "Semantic error ESE0318: Type 'Int' cannot be assigned to type 'Color'"
      - |-
        "Semantic error ESE0318: Type 'Int' cannot be assigned to type 'Color'"

  - desc: |-
      >-
        Enumeration type enum specifies a distinct user-defined type
        with an associated set of named constants that define its
        possible values.
        If constant expression is omitted, then the value of the enum
        constant is set implicitly to an integer value.
        params: modifying enum using type assertion
    check_variants:
      - decl_data: |-
          enum Color { Red, Green, Blue }
      - decl_data: |-
          const enum Color { Red, Green, Blue }
    decl: |-
      [decl_data]
    sub_cases_logic:
      - |-
        (Color as Any).Red = 2
      - |-
        (Color as Any).Green = 3
      - |-
        (Color as Any).Blue = 4
    stdout:
      - |-
        "Semantic error ESE0144: Enum name 'Color' used in the wrong context"
      - |-
        "Semantic error ESE0144: Enum name 'Color' used in the wrong context"
      - |-
        "Semantic error ESE0144: Enum name 'Color' used in the wrong context"

  - desc: |-
      >-
        Enumeration type enum specifies a distinct user-defined type
        with an associated set of named constants that define its
        possible values.
        If constant expression is omitted, then the value of the enum
        constant is set implicitly to an integer value.
        params: adding or reading new elements from enum
    check_variants:
      - decl_data: |-
          enum Color { Red, Green, Blue }
      - decl_data: |-
          const enum Color { Red, Green, Blue }
    decl: |-
      [decl_data]
    sub_cases_logic:
      - |-
        Color.Unexist = 5
      - |-
        let v: Color = Color.Unexist
    stdout:
      - |-
        "Semantic error ESE0087: Property 'Unexist' does not exist on type 'Color'"
      - |-
        "Semantic error ESE0087: Property 'Unexist' does not exist on type 'Color'"

  - desc: |-
      >-
        A compile-time error occurs if integer or string type enumeration
        constants are combined in a single enumeration.
    check_variants:
      - decl_data: |-
          enum E { A, B = "hello" }
      - decl_data: |-
          enum E { A = 5, B = "hello" }
    decl: |-
      [decl_data]
    logic: ""
    stdout:
      - |-
        "Semantic error ESE0342: Enumeration members can be initialized only by compile-time expressions and initializers must be of the same type."

  - desc: |-
      >-
        All enumeration constant names must be unique.
        Otherwise, a compile-time error occurs.
    check_variants:
      - decl_data: |-
          enum E { A = 5, A = 77 }
    decl: |-
      [decl_data]
    logic: ""
    stdout:
      - |-
        "Semantic error ESE0351: Variable 'A' has already been declared."

  - desc: |-
      >-
        The value of an enum constant can be set as follows:
        * Explicitly to a numeric constant expression
        (expression of type int or long ) or to a constant expression
        of type string; or
        * Implicitly by omitting the constant expression.
    check_variants:
      - decl_data: |-
          enum Enum { A = 5.5 }
      - decl_data: |-
          enum Enum { A = 5.5f }
      - decl_data: |-
          enum Enum { A = c'5' }
      - decl_data: |-
          enum Enum { A = 5n }
      - decl_data: |-
          enum Enum { A = null }
      - decl_data: |-
          enum Enum { A = undefined }
      - decl_data: |-
          const tuple: [int, int] = [5, 10]
          enum Enum { A = tuple }
    decl: |-
      [decl_data]
    logic: ""
    stdout:
      - |-
        "Expected CTE output is unknown"

  - desc: |-
      >-
        A compile-time error occurs if: at least one initialization expression
        is not a constant expression.
    check_variants:
      - decl_data: |-
          function foo(): long {
            return 5
          }
          enum Enum { A = foo() }
      - decl_data: |-
          enum E { A = 5 as long }
      - decl_data: |-
          enum Enum { A = (5).toLong() }
      - decl_data: |-
          enum Enum { A = (5).toString() }
      - decl_data: |-
          const c = 5 as long
          enum Enum { A = c }
      - decl_data: |-
          const c = (5).toLong()
          enum Enum { A = c }
      - decl_data: |-
          const c = (5).toString()
          enum Enum { A = c }
    decl: |-
      [decl_data]
    logic: ""
    stdout:
      - |-
        "Semantic error ESE0342: Enumeration members can be initialized only by compile-time expressions and initializers must be of the same type."

  - desc: |-
      >-
        A compile-time error occurs if: enumeration values are set explicitly,
        and at least one initialization expression type is other than int, long, or string.
    check_variants:
      - decl_data: |-
          enum Enum { A = 10, B = 5.5 }
      - decl_data: |-
          enum Enum { A = 5.5, B = 10 }
      - decl_data: |-
          enum Enum { A = 10, B = 5.5f }
      - decl_data: |-
          enum Enum { A = 5.5f, B = 10 }
      - decl_data: |-
          enum Enum { A = 10, B = 5n }
      - decl_data: |-
          enum Enum { A = 5n, B = 10 }
      - decl_data: |-
          enum Enum { A = 10, B = c'5' }
      - decl_data: |-
          enum Enum { A = c'5', B = 10 }
      - decl_data: |-
          enum Enum { A = 10, B = undefined }
      - decl_data: |-
          enum Enum { A = undefined, B = 10 }
      - decl_data: |-
          enum Enum { A = 10, B = null }
      - decl_data: |-
          enum Enum { A = null, B = 10 }
      - decl_data: |-
          const tuple: [int, int] = [5, 10]
          enum Enum { A = 10, B = tuple }
      - decl_data: |-
          const tuple: [int, int] = [5, 10]
          enum Enum { A = tuple, B = 10 }
    decl: |-
      [decl_data]
    logic: ""
    stdout:
      - |-
        "Semantic error ESE0342: Enumeration members can be initialized only by compile-time expressions and initializers must be of the same type."
