# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

cases:
  - desc: Create empty 1D Array
    logic: |-
      let a: number[] = []
      arktest.assertEQ(a.length, 0)

  - desc: |-
      Create 1D Array with wrong type values
      tags:
        - negative
        - compile-only
    sub_cases_logic:
      - |-
        let a: Object[] = [1, 3, undefined]
      - |-
        let a: Object[] = [1, null, 3]
      - |-
        let a: int[] = [1, 3, 5.7]
      - |-
        let a: int[] = [1, "abc", 5]
      - |-
        let a: string[] = ["abc", 3, "efg"]
      - |-
        let a: boolean[] = [true, false, "true"]

  - desc: Create 1D Array with the data type int
    logic: |-
      let a: int[] = [5, 3, 7, 9]
      arktest.assertEQ(a.length, 4)
      arktest.assertTrue(a[0] instanceof int)
      arktest.assertEQ(a[0], 5)
      arktest.assertEQ(a[1], 3)
      arktest.assertEQ(a[2], 7)
      arktest.assertEQ(a[3], 9)

  - desc: Create a 2D Array with the data type number
    logic: |-
      let a : number[][] = [[5, 3.7], [7, 8.5], [3, 4]]
      arktest.assertEQ(a.length, 3)
      arktest.assertEQ(a[0].length, 2)
      arktest.assertEQ(a[1].length, 2)
      arktest.assertEQ(a[2].length, 2)
      arktest.assertTrue(a[0][0] instanceof number)
      arktest.assertEQ(a[0][0], 5)
      arktest.assertEQ(a[0][1], 3.7)
      arktest.assertEQ(a[1][0], 7)
      arktest.assertEQ(a[1][1], 8.5)
      arktest.assertEQ(a[2][0], 3)
      arktest.assertEQ(a[2][1], 4)

  - desc: Create a 3D Array with the data type string
    logic: |-
      let a : string[][][] = [
        [["_a", "_b"], ["_c", "_d"]],
        [["_e", "_f"], ["_g", "_h"]],
        [["_i", "_j"], ["_k", "_l"]]
      ]
      arktest.assertEQ(a.length, 3)
      arktest.assertEQ(a[0].length, 2)
      arktest.assertEQ(a[0][0].length, 2)
      arktest.assertEQ(a[0][1].length, 2)
      arktest.assertEQ(a[1].length, 2)
      arktest.assertEQ(a[1][0].length, 2)
      arktest.assertEQ(a[1][1].length, 2)
      arktest.assertEQ(a[2].length, 2)
      arktest.assertEQ(a[2][0].length, 2)
      arktest.assertEQ(a[2][1].length, 2)
      arktest.assertTrue(a[0][0][0] instanceof string)
      arktest.assertEQ(a[0][0][0], "_a")
      arktest.assertEQ(a[0][0][1], "_b")
      arktest.assertEQ(a[0][1][0], "_c")
      arktest.assertEQ(a[0][1][1], "_d")
      arktest.assertEQ(a[1][0][0], "_e")
      arktest.assertEQ(a[1][0][1], "_f")
      arktest.assertEQ(a[1][1][0], "_g")
      arktest.assertEQ(a[1][1][1], "_h")
      arktest.assertEQ(a[2][0][0], "_i")
      arktest.assertEQ(a[2][0][1], "_j")
      arktest.assertEQ(a[2][1][0], "_k")
      arktest.assertEQ(a[2][1][1], "_l")

  - desc: Create 1D Array by shallow copy with spread operator
    logic: |-
      let a: int[] = [1, 2]
      let f: FixedArray<int> = [3, 4]
      let ea: int[] = []
      let ef: FixedArray<int> = []
      let t: int[] = [
        ...ea, ...a, ...ef,
        ...f, ...ea, ...a, ...ef
      ]
      t[0] = 7
      t[3] = 9
      t[4] = 5
      arktest.assertEQ(a.length, 2)
      arktest.assertEQ(f.length, 2)
      arktest.assertEQ(ea.length, 0)
      arktest.assertEQ(ef.length, 0)
      arktest.assertEQ(t.length, 6)
      arktest.assertTrue(t[0] instanceof int)
      arktest.assertEQ(a[0], 1)
      arktest.assertEQ(a[1], 2)
      arktest.assertEQ(f[0], 3)
      arktest.assertEQ(f[1], 4)
      arktest.assertEQ(t[0], 7)
      arktest.assertEQ(t[1], 2)
      arktest.assertEQ(t[2], 3)
      arktest.assertEQ(t[3], 9)
      arktest.assertEQ(t[4], 5)
      arktest.assertEQ(t[5], 2)

  - desc: Create 2D Array by shallow copy with spread operator
    logic: |-
      let a: number[] = [4, 2]
      let f: FixedArray<number> = [7, 8]
      let ea: number[] = []
      let ef: FixedArray<number> = []
      let t: number[][] = [
        [...ea, ...a, ...ef, ...f, ...ea],
        [...ef, ...f, ...ea, ...a, ...ef],
      ]
      t[0][3] = 9
      t[1][2] = 5
      arktest.assertEQ(a.length, 2)
      arktest.assertEQ(f.length, 2)
      arktest.assertEQ(ea.length, 0)
      arktest.assertEQ(ef.length, 0)
      arktest.assertEQ(t.length, 2)
      arktest.assertEQ(t[0].length, 4)
      arktest.assertEQ(t[1].length, 4)
      arktest.assertTrue(t[0][0] instanceof number)
      arktest.assertEQ(a[0], 4)
      arktest.assertEQ(a[1], 2)
      arktest.assertEQ(f[0], 7)
      arktest.assertEQ(f[1], 8)
      arktest.assertEQ(t[0][0], 4)
      arktest.assertEQ(t[0][1], 2)
      arktest.assertEQ(t[0][2], 7)
      arktest.assertEQ(t[0][3], 9)
      arktest.assertEQ(t[1][0], 7)
      arktest.assertEQ(t[1][1], 8)
      arktest.assertEQ(t[1][2], 5)
      arktest.assertEQ(t[1][3], 2)

  - desc: Create 1D Array by shallow copy with spread operator
    decl: |-
      class A {
        v: int = 0
        constructor(v: int = 0){
          this.v = v
        }
      }
      class B extends A {
        constructor(v: int = 0){
          super(-v)
        }
      }
    logic: |-
      let aA: A[] = [new A(2), new A(4), new B(7)]
      let fB: FixedArray<B> = [new B(5), new B(9)]
      let fA: FixedArray<A> = [new B(13), new A(10)]
      let eaA: A[] = []
      let efB: FixedArray<B> = []
      let t: A[] = [
        ...eaA, ...fB, ...efB,
        ...aA, ...eaA, ...fA, ...efB
      ]
      t[0] = new A(8)
      t[3] = new A(15)
      t[6] = new B(5)
      arktest.assertEQ(aA.length, 3)
      arktest.assertEQ(fB.length, 2)
      arktest.assertEQ(fA.length, 2)
      arktest.assertEQ(eaA.length, 0)
      arktest.assertEQ(efB.length, 0)
      arktest.assertEQ(t.length, 7)
      arktest.assertTrue(t[0] instanceof A)
      arktest.assertEQ(aA[0].v, 2)
      arktest.assertEQ(aA[1].v, 4)
      arktest.assertEQ(aA[2].v, -7)
      arktest.assertEQ(fB[0].v, -5)
      arktest.assertEQ(fB[1].v, -9)
      arktest.assertEQ(fA[0].v, -13)
      arktest.assertEQ(fA[1].v, 10)
      arktest.assertEQ(t[0].v, 8)
      arktest.assertTrue(t[1] instanceof B)
      arktest.assertEQ(t[1].v, -9)
      arktest.assertEQ(t[2].v, 2)
      arktest.assertEQ(t[3].v, 15)
      arktest.assertEQ(t[4].v, -7)
      arktest.assertTrue(t[5] instanceof B)
      arktest.assertEQ(t[5].v, -13)
      arktest.assertEQ(t[6].v, -5)

  - desc: Create 1D Array with covariant subtypes
    decl: |-
      class Animal {}
      class Dog extends Animal {
        name: string = ""
        bark(): string {
          return this.name
        }
      }
      class Cat extends Animal {}
    logic: |-
      let animals: Animal[] = [new Animal, {name: "dog"} as Dog, new Cat]
      arktest.assertTrue(animals[0] instanceof Animal)
      arktest.assertTrue(animals[1] instanceof Dog)
      arktest.assertEQ((animals[1] as Dog).bark(), "dog")
      arktest.assertTrue(animals[2] instanceof Cat)

  - desc: |-
      Create 1D Array with not covariant subtypes
      tags:
        - negative
        - compile-only
    decl: |-
      class Animal {}
      class Dog extends Animal {}
      class Cat extends Animal {}
    sub_cases_logic:
      - |-
        let dogs: Dog[] = [new Dog, new Animal, new Dog]
      - |-
        let dogs: Dog[] = [new Dog, new Dog, new Cat]

  - desc: Create 1D Array with covariant function subtypes
    decl: |-
      class A {
        v: int
        constructor(v: int = 0) {
          this.v = v
        }
      }
      class B extends A {
        constructor(v: int = 0) {
          super(-v)
        }
        f(): int {
          return 13
        }
      }
      type HandlerBInt = (a: B, b: int) => A
      type HandlerAInt = (a: A, b: int) => B
      const handlerAInt: HandlerAInt = (a: A, b: int): B => {
        if (a instanceof B){
          return new B(a.f() + b)
        } else {
          return new B(b)
        }
      }
      type HandlerA = (a: A) => A
      const handlerA: HandlerA = (a: A): A => {
        if (a instanceof B){
          return new A(a.f())
        } else {
          return new A
        }
      }
      type HandlerNothing = () => B
      const handlerNothing: HandlerNothing = (): B => {
        return new B(567)
      }
    logic: |-
      let a: HandlerBInt[] = [handlerAInt, handlerA, handlerNothing]
      arktest.assertEQ(a[0](new B, 7).v, -20)
      arktest.assertEQ(a[1](new B, 7).v, 13)
      arktest.assertEQ(a[2](new B, 7).v, -567)

  - desc: |-
      Create 1D Array with not covariant function subtypes
      tags:
        - negative
        - compile-only
    decl: |-
      class A {}
      class B extends A {}
      class C extends A {}
      type HandlerReq = (a: B, b: int) => B
      type HandlerCInt = (a: C, b: int) => B
      const handlerCInt: HandlerCInt = (a: C, b: int): B => {
        return new B
      }
      type HandlerBInt = (a: B, b: int) => A
      const handlerBInt: HandlerBInt = (a: B, b: int): A => {
        return new B
      }
      type HandlerB = (a: B) => A
      const handlerB: HandlerB = (a: B): A => {
        return new B
      }
      type HandlerBIntInt = (a: B, b: int, c: int) => B
      const handlerBIntInt: HandlerBIntInt = (a: B, b: int, c: int): B => {
        return new B
      }
      type HandlerNothing = () => C
      const handlerNothing: HandlerNothing = (): C => {
        return new C
      }
    sub_cases_logic:
      - |-
        let a: HandlerReq[] = [handlerCInt]
      - |-
        let a: HandlerReq[] = [handlerBInt]
      - |-
        let a: HandlerReq[] = [handlerB]
      - |-
        let a: HandlerReq[] = [handlerBIntInt]
      - |-
        let a: HandlerReq[] = [handlerNothing]
