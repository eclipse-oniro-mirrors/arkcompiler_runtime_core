# Copyright (c) 2024-2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
# resizable arrays
    - decl: |-
          let a1: Object|null|undefined = new Object
          function foo(...p: Object[]): number {
              return p.length > 0 ? p.length : -1
          }
      use: |-
          // not array type
          arktest.assertEQ(foo(...a1), -1)
      tags: 'negative, compile-only'

    - decl: |-
          let a1: number[] = [1.0, 2.0]
          function foo(p1: number, p2: number): number {
              return p1 + p2
          }
      use: |-
          // not rest parameters
          arktest.assertEQ(foo(...a1), 3.0)
      tags: 'negative, compile-only'

    - decl: |-
          function foo(...p: Object[]): number {
              return p.length
          }
      use: |-
          // empty arrays
          let a1: Object[] = [], a2: Error[] = []
          arktest.assertEQ(foo(...[...a1, ...a2, new Object(), ...a1]), 1)

    - decl: |-
          function foo(...p: char[]): number {
              return p.length
          }
      use: |-
          // spread of char array
          let a: char[] = [c'b', c'c']
          arktest.assertEQ(foo(...a), 2)

    - decl: |-
          function foo(a: int, ...p: byte[]): int {
              return a + reduce(p, (prev: int, next: byte) => prev + next, 0)
          }
      use: |-
          // spread of byte array
          let a: byte[] = [1 as byte, 2 as byte, 3 as byte]
          arktest.assertEQ(foo(42, ...a), 48)

    - decl: |-
          function foo(a: int, ...p: short[]): int {
              return a + reduce(p, (prev: int, next: short) => prev + next, 0)
          }
      use: |-
          // spread of short array
          let a: short[] = [1 as short, 2 as short, 3 as short]
          arktest.assertEQ(foo(42, ...a), 48)

    - decl: |-
          function foo(a: long, ...p: long[]): long {
              return a + reduce(p, (prev: long, next: long) => prev + next, 0 as long)
          }
      use: |-
          // spread of long array
          let a: long[] = [1 as long, 2 as long, 3 as long]
          arktest.assertEQ(foo(42, ...a), 48)

    - decl: |-
          function foo(a: float, ...p: float[]): float {
              return a + reduce(p, (prev: float, next: float) => prev + next, 0.0f)
          }
      use: |-
          // spread of float array
          let a: float[] = [1.0f, 2.0f, 3.0f]
          arktest.assertEQ(foo(42.0f, ...a), 48.0f)

    - decl: |-
          function foo(a: number, ...p: number[]): number {
              return a + reduce(p, (prev: number, next: number) => prev + next, 0.0)
          }
      use: |-
          // spread of number array
          let a: number[] = [1.0, 2.0, 3.0]
          arktest.assertEQ(foo(42, ...a), 48.0)

    - decl: |-
          type F = (p: number) => number
          function foo(a: number, ...p: F[]): number {
              let res = a
              for (let el of p) res += el(res)
              return res
          }
      use: |-
          // spread of function array
          let a: F[] = [(p: number) => p * 2, (p: number) => p * 3]
          let b: F[] = [(p: number) => p * 4, (p: number) => p * 5]
          arktest.assertEQ(foo(1.0, ...[...a, ...b]), 360.0)

    - decl: |-
          enum Color { Red, Green, Blue }
          function foo(...p: Color[]): Color {
              return p.length ? p[p.length - 1] : Color.Red
          }
      use: |-
          // spread of enums array
          let a: Color[] = [Color.Red, Color.Blue, Color.Green]
          arktest.assertEQ(foo(...a), Color.Green)

    - decl: |-
          function foo(...p: number[]): number {
              return p.length ? p[p.length - 1] : -1.0
          }
      use: |-
          // expression in parentheses
          arktest.assertEQ(foo(...([1.0, 2.0])), 2.0)

    - decl: |-
          function foo(a: int, ...p: Object[]): number {
              return a + p.length
          }
      use: |-
          // ensure-not-nullish expression
          let a1: Object[]|null = [new Object, new Object]
          arktest.assertEQ(foo(5, ...a1!), 7)

    - decl: |-
          function foo(a: int, ...p: Object[]): number {
              return a + p.length
          }
          let a1: Object[]|null = null
          let expectedException = (e: Error): boolean => {return (e instanceof NullPointerError)}
      use: |-
          // ensure-not-nullish expression
          arktest.expectThrow(() => {foo(5, ...a1!) == 7}, expectedException)  // NPE expected

    - decl: |-
          function foo(a: int, ...p: Object[]): number {
              return a + p.length
          }
          let a1: Object[]|null = [new Object, new Object]
      use: |-
          // nullish expression
          arktest.assertEQ(foo(5, ...a1), 7)  // CTE expected
      tags: 'negative, compile-only'

    - decl: |-
          let a1: Object[]|null = null
          let a2: Object[]|null = [new Object, new Object]
          function foo(a: int, ...p: Any[]): number {
              return a + p.length
          }
      use: |-
          // nullish-coalescing expression
          arktest.assertEQ(foo(5, ...(a1 ?? a2)!), 7)

    - decl: |-
          function foo(): number[] {
              return [1.0, 2.0]
          }
          function bar(...p: number[]): number {
              return reduce(p, (prev: number, next: number) => prev + next, 0.0)
          }
      use: |-
          // function call in expression
          arktest.assertEQ(bar(...foo()), 3.0)

    - decl: |-
          function foo(...p: string[]): string {
              return String.join(p, '')
          }
      use: |-
          // function call in expression
          let s = ['h', '', 'el', '', '', 'l', '', 'o']
          arktest.assertEQ(foo(...((s: string[]): string[] => {
                let res: string[] = []
                for (let el of s) if (el.length > 0) res = [...res, el]
                return res
          })(s)), 'hello')

    - decl: |-
          function foo(...p: number[]): number {
              return p.length ? p[p.length - 1] : -1
          }
      use: |-
          // new expression in expression
          arktest.assertEQ(foo(...(new number[256])), 0)

    - decl: |-
          function foo(...p: double[]): double {
              return p[0] + p[1]
          }
      use: |-
          // array index expression
          let a: double[][] = [[2.0, 3.0], []]
          arktest.assertEQ(foo(...a[0]), 5)

    - decl: |-
          function foo(...p: double[]): double {
              return p[0] + p[1] + p[2]
          }
      use: |-
          // tuple index expression
          let a: [string, double[], string] = ['X', [2.0, 3.0, 4.0], 'Z']
          arktest.assertEQ(foo(...a[1]), 9)

    - decl: |-
          function foo(...p: string[]): string {
              return String.join(p, '-')
          }
      use: |-
          // assignment expression in expression
          let a1 = ['1', '2', '3']
          let a2 = ['a', 'b']
          arktest.assertEQ(foo(...(a1 = a2)), 'a-b')

    - decl: |-
          let a1 = ['1', '2', '3']
          let a2 = ['a', 'b']
          function foo(...p: string[]): string {
              return String.join(p, '-')
          }
      use: |-
          // conditional expression in expression
          arktest.assertEQ(foo(...(a1.length > a2.length ? a1 : a2)), '1-2-3')

    - decl: |-
          class A {
              fld: boolean[]
              constructor(p: boolean[], q: boolean[]) {
                  this.fld = [...p, ...q]
              }
              meth(): number {
                  return foo(42, ...this.fld)
              }
          }
          function foo(a: int, ...p: boolean[]): number {
              return a + p.length
          }
      use: |-
          // use this expression
          let a: A = new A([false, false], [true, true])
          arktest.assertEQ(a.meth(), 46)

    - decl: |-
          abstract class A {
              fld: boolean[] = []
              constructor(p: boolean[]) {
                  this.fld = p
              }
              meth(): boolean[] {
                  return this.fld
              }
          }
          class B extends A {
              constructor(p: boolean[], q: boolean[]) {
                  super([...p, ...q])
              }
              bar(): number {
                  return foo(42, ...super.meth())
              }
          }
          function foo(a: int, ...p: boolean[]): number {
              return a + p.length
          }
      use: |-
          // use super expression
          let b: B = new B([false, false], [true, true])
          arktest.assertEQ(b.bar(), 46)

    - decl: |-
          function foo(...p: number[][]): number {
              let res = 0
              for (let el of p) res += el.length
              return res
          }
      use: |-
          // spread of arrays
          let a1: number[][] = [[1.0, 2.0], [], [3.0, 4.0], [5.0]]
          arktest.assertEQ(foo(...a1), 5)

    - decl: |-
          function foo(...p: number[][]): number[] {
              let res: number[] = []
              for (let el of p) res = [...res, ...el]
              return res
          }
          function bar(...p: number[]): number {
              let res = 0.0
              for (let el of p) res += el
              return res
          }
      use: |-
          // spread of arrays, flatten array
          let a1: number[][] = [[1.0, 2.0], [3.0, 4.0]]
          let a2: number[][] = [[5.0, 6.0], []]
          arktest.assertEQ(bar(...[...foo(...a1), ...foo(...a2)]), 21.0)

    - decl: |-
          function foo(...p: (Double|Short|Byte)[]): double {
              let res = 0.0
              for (let el of p) res += (el as Numeric).toDouble()
              return res
          }
      use: |-
          // union of value types in result array
          let a1: Double[] = [1, 2, 3], a2: Short[] = [4, 5], a3: Byte[] = [6]
          let ar = [-10.0, ...a1, ...a1, ...a2, ...a2, ...a3, 10.0, ...a3]
          arktest.assertEQ(foo(...ar), 42.0)

    - decl: |-
          function foo(...p: Array<Object>): double {
              let res = 0.0
              for (let el of p) res += (el as Numeric).doubleValue()
              return res
          }
      use: |-
          // union of value types in result array
          let a1: Double[] = [1, 2, 3], a2: Short[] = [4, 5], a3: Byte[] = [6]
          let ar = [-10.0, ...a1, ...a1, ...a2, ...a2, ...a3, 10.0, ...a3]
          arktest.assertEQ(foo(...ar), 42.0)

    - decl: |-
          function foo(...p: (Int|Number|String|undefined)[]): number {
              return p.length
          }
      use: |-
          // union of reference types in result array
          let a1: (Int|Number|String|undefined)[] = [new Int(), new Int(), undefined, 'Z', 42.0]
          arktest.assertEQ(foo(...a1), 5)

    - decl: |-
          class A<T> {}
          class B<T> {}
          class C<T> {}
          function foo<T, U, V>(...p: (A<T>|B<U>|C<V>|null)[]): number {
              return p.length
          }
      use: |-
          // use generics
          let a1: (A<String>|B<Long>|C<Error>|null)[] = [new A<String>, new B<Long>, new C<Error>]
          arktest.assertEQ(foo<String, Long, Error>(...a1), 3)

    - decl: |-
          let a1 = ['1', '2', '3']
          function foo(...p: string[]): string {
              return String.join(p, '')
          }
      use: |-
          // lambda expression in expression
          arktest.assertEQ(foo(...((): string[] => a1)()), '123')

    - decl: |-
          let a1 = ['1', '2', '3']
          function foo(...p: string[]): string {
              return String.join(p, '')
          }
      use: |-
          // lambda expression in expression
          arktest.assertEQ(foo(...((p: string[], q: string[]): string[] => [...p, ...q])(a1, a1)), '123123')

# tuples
    - decl: |-
          function foo(...p: [number, boolean]): [boolean, number] {
              return [p[1], p[0]]
          }
      use: |-
          // spread a tuple to same type tuple
          let t1: [number, boolean] = [1.0, true]
          let r: [boolean, number] = foo(...t1)
          arktest.assertTrue(r[0] && r[1] == 1.0)

    - decl: |-
          function foo(...p: [number, boolean]): [number, number, boolean, boolean] {
              return [p[0], p[0], p[1], p[1]]
          }
      use: |-
          // spread tuples to different types
          let r: [number, number, boolean, boolean] = foo(...[1.0, true])
          arktest.assertTrue(r[0] == 1.0 && r[1] == 1.0 && r[2] && r[3])

    - decl: |-
          function foo(...p: [byte, short, int, long, float, double, boolean, char, string]): [byte, short, int, long, float, double, boolean, char, string, int] {
                return [...p, 42]
          }
      use: |-
          // spread tuples of all value types
          let r: [byte, short, int, long, float, double, boolean, char, string] =
              [1 as byte, 2 as short, 3, 4 as long, 5.0f, 6.0, true, c'Z', 'X']
          arktest.assertEQ(foo(...r)[9], 42)

    - decl: |-
          function foo(...p: [Object, Error]): int {
              return p[0] != p[1] ? 3 : 0
          }
          let a1: [Object, Error]|null = [new Object, new Error]
      use: |-
          // ensure-not-nullish expression
          arktest.assertEQ(foo(...a1!), 3)

    - decl: |-
          function foo(...p: [Object, Error]): int {
              return p[0] != p[1] ? 3 : 0
          }
          let a1: [Object, Error]|null = null
          let expectedException = (e: Error): boolean => {return (e instanceof NullPointerError)}
      use: |-
          // ensure-not-nullish expression
          arktest.expectThrow(() => {foo(...a1!) == 3}, expectedException) // NPE expected

    - decl: |-
          let a1: [Object, Error]|null = null
          let a2: [Object, Error]|null = [new Object, new Error]
          function foo(...p: [Object, Error]): int {
              return p[0] != p[1] ? 3 : 0
          }
      use: |-
          // nullish-coalescing expression
          arktest.assertEQ(foo(...(a1 ?? a2)!), 3)

    - decl: |-
          let a1: [Object, Error]|null = null
          let a2: [Object, Error]|null = null
          let expectedException = (e: Error): boolean => {return (e instanceof NullPointerError)}
          function foo(...p: [Object, Error]): int {
              return p[0] != p[1] ? 3 : 0
          }
      use: |-
          // nullish-coalescing expression
          arktest.expectThrow(() => {foo(...(a1 ?? a2)!) == 3}, expectedException)

    - decl: |-
          let a1: [Object, Error]|null = null
          let a2: [Object, Error]|null = null
          function foo(...p: [Object, Error]): int {
              return p[0] != p[1] ? 3 : 0
          }
      use: |-
          // nullish-coalescing expression
          arktest.assertEQ(foo(...(a1 ?? a2)), 3)  // CTE, nullish expression
      tags: 'negative, compile-only'

    - decl: |-
          function foo(): [number, string] {
              return [1.0, 'X']
          }
          function bar(...p: [number, string]): [string, number] {
              return [p[1], p[0]]
          }
      use: |-
          // function call in expression
          let r: [string, number] = bar(...foo())
          arktest.assertTrue(r[0] == 'X' && r[1] == 1)

    - decl: |-
          function foo(...p: [double, double]): double {
              return p[0] + p[1]
          }
      use: |-
          // tuple index expression
          let a: [[double, double], [char, char]] = [[2.0, 3.0], [c'Z', c'X']]
          arktest.assertEQ(foo(...a[0]), 5.0)

    - decl: |-
          function foo(...p: [string, int]): int {
              return p[1]
          }
      use: |-
          // assignment expression in expression
          let a1: [string, int] = ['1', 10]
          let a2: [string, int] = ['2', 20]
          arktest.assertEQ(foo(...(a1 = a2)), 20)

    - decl: |-
          let a1: [int, int] = [1, 2]
          let a2: [int, int] = [5, 6]
          function foo(...p: [int, int]): int {
              return p[0] + p[1]
          }
      use: |-
          // conditional expression in expression
          let r = foo(...(a1[0] > a2[0] ? a1 : a2))
          arktest.assertEQ(r, 11)

    - decl: |-
          class A {
              fld: [int, char]
              constructor(p: int, q: char) {
                  this.fld = [p, q]
              }
              meth(): int {
                  return 10 + foo(...this.fld)
              }
          }
          function foo(...p: [int, char]): int {
              return 100 + p[0]
          }
      use: |-
          // use this expression
          let a: A = new A(1, c'Z')
          arktest.assertEQ(a.meth(), 111)

    - decl: |-
          abstract class A {
              fld: [int, char]
              constructor(p: [int, char]) {
                  this.fld = p
              }
              meth(): [int, char] {
                  return this.fld
              }
          }
          class B extends A {
              constructor(p: int, q: char) {
                  super([p, q])
              }
              meth(): [int, char] {
                  this.fld[0] = 10 + foo(...super.meth())
                  return this.fld
              }
          }
          function foo(...p: [int, char]): int {
              return 100 + p[0]
          }
      use: |-
          // use super expression
          let b: B = new B(1, c'Z')
          arktest.assertEQ(b.meth()[0], 111)

    - decl: |-
          class A<T> {}
          class B<T> {}
          function foo<T, U>(...p: [A<T>, B<U>]): boolean {
              return p[0] == p[1]
          }
      use: |-
          // use generics
          let a1: [A<Long>, B<Error>] = [new A<Long>, new B<Error>]
          arktest.assertFalse(foo<Long, Error>(...a1))

    - decl: |-
          let a2: [int, int] = [6, 5]
          function foo(...p: [int, int]): string {
              return '' + p[0] + p[1]
          }
      use: |-
          // lambda expression in expression
          let r = foo(...((p: [int, int]): [int, int] => [p[1], p[0]])(a2))
          arktest.assertEQ(r, '56')

    - decl: |-
          let r1: Record<int, string> = {1: '1', 3: '3'}
          let r2: Record<int, string> = {2: '2'}
          function foo(...p: Record<int, string>[]): number {
              arktest.assertEQ(p[0][1], '1')
              return p.length
          }
      use: |-
          arktest.assertEQ(foo(...[r1, r2]), 2)

    - decl: |-
          function foo(...p: Object[]): number {
              return p.length
          }
      use: |-
          let r: Record<int, string> = {1: '1', 3: '3'}
          arktest.assertEQ(foo(...r), 2)

# fixed arrays
    - decl: |-
          function foo(...p: Array<Object>): number {
              return p.length
          }
      use: |-
          // empty arrays
          let a1: FixedArray<Object> = [], a2: FixedArray<Error> = []
          arktest.assertEQ(foo(...[...a1, ...a2, new Object(), ...a1]), 1)

    - decl: |-
          function foo(...p: FixedArray<char>): number {
              return p.length
          }
      use: |-
          // spread of char array
          let a: FixedArray<char> = [c'b', c'c']
          arktest.assertEQ(foo(...a), 2)

    - decl: |-
          function foo(a: int, ...p: Array<byte>): int {
              return a + reduce(p, (prev: int, next: byte) => prev + next, 0)
          }
      use: |-
          // spread of byte array
          let a: FixedArray<byte> = [1 as byte, 2 as byte, 3 as byte]
          arktest.assertEQ(foo(42, ...a), 48)

    - decl: |-
          function foo(a: int, ...p: FixedArray<short>): int {
              return a + reduce(p, (prev: int, next: short) => prev + next, 0)
          }
      use: |-
          // spread of short array
          let a: FixedArray<short> = [1 as short, 2 as short, 3 as short]
          arktest.assertEQ(foo(42, ...a), 48)

    - decl: |-
          function foo(a: long, ...p: FixedArray<long>): long {
              return a + reduce(p, (prev: long, next: long) => prev + next, 0 as long)
          }
      use: |-
          // spread of long array
          let a: FixedArray<long> = [1 as long, 2 as long, 3 as long]
          arktest.assertEQ(foo(42, ...a), 48)

    - decl: |-
          function foo(a: float, ...p: FixedArray<float>): float {
              return a + reduce(p, (prev: float, next: float) => prev + next, 0.0f)
          }
      use: |-
          // spread of float array
          let a: FixedArray<float> = [1.0f, 2.0f, 3.0f]
          arktest.assertEQ(foo(42.0f, ...a), 48.0f)

    - decl: |-
          function foo(a: number, ...p: number[]): number {
              return a + reduce(p, (prev: number, next: number) => prev + next, 0.0)
          }
      use: |-
          // spread of number array
          let a: FixedArray<number> = [1.0, 2.0, 3.0]
          arktest.assertEQ(foo(42, ...a), 48.0)

    - decl: |-
          type F = (p: number) => number
          function foo(a: number, ...p: FixedArray<F>): number {
              let res = a
              for (let el of p) res += el(res)
              return res
          }
      use: |-
          // spread of function array
          let a: FixedArray<F> = [(p: number) => p * 2, (p: number) => p * 3]
          let b: FixedArray<F> = [(p: number) => p * 4, (p: number) => p * 5]
          arktest.assertEQ(foo(1.0, ...[...a, ...b]), 360.0)

    - decl: |-
          enum Color { Red, Green, Blue }
          function foo(...p: Color[]): Color {
              return p.length ? p[p.length - 1] : Color.Red
          }
      use: |-
          // spread of enums array
          let a: FixedArray<Color> = [Color.Red, Color.Blue, Color.Green]
          arktest.assertEQ(foo(...a), Color.Green)

    - decl: |-
          function foo(...p: FixedArray<Object>): number {
              return p.length ? p[p.length - 1] : -1.0
          }
      use: |-
          // expression in parentheses
          arktest.assertEQ(foo(...([1.0, 2.0])), 2.0)

    - decl: |-
          function foo(a: int, ...p: FixedArray<Object>): int {
              return a + p.length
          }
      use: |-
          // ensure-not-nullish expression
          let a1: FixedArray<Object>|null = [new Object, new Object]
          arktest.assertEQ(foo(5, ...a1!), 7)

    - decl: |-
          function foo(a: int, ...p: FixedArray<Object>): int {
              return a + p.length
          }
          let a1: FixedArray<Object>|null = null
          let expectedException = (e: Error): boolean => {return (e instanceof NullPointerError)}
      use: |-
          // ensure-not-nullish expression
          arktest.expectThrow(() => {foo(5, ...a1!) == 7}, expectedException)  // NPE expected

    - decl: |-
          function foo(a: int, ...p: FixedArray<Object>): number {
              return a + p.length
          }
          let a1: FixedArray<Object>|null = [new Object, new Object]
      use: |-
          // nullish expression
          arktest.assertEQ(foo(5, ...a1), 7)  // CTE expected
      tags: 'negative, compile-only'

    - decl: |-
          let a1: FixedArray<Object>|null = null
          let a2: FixedArray<Object>|null = [new Object, new Object]
          function foo(a: int, ...p: FixedArray<Object>): int {
              return a + p.length
          }
      use: |-
          // nullish-coalescing expression
          arktest.assertEQ(foo(5, ...(a1 ?? a2)!), 7)

    - decl: |-
          function foo(): FixedArray<number> {
              return [1.0, 2.0]
          }
          function bar(...p: FixedArray<number>): number {
              return reduce(p, (prev: number, next: number) => prev + next, 0.0)
          }
      use: |-
          // function call in expression
          arktest.assertEQ(bar(...foo()), 3.0)

    - decl: |-
          function foo(...p: FixedArray<int>): int {
              return reduce(p, (p: int, c: int) => p + c, 0)
          }
      use: |-
          // function call in expression
          let s: FixedArray<int> = [1, -1, 2, -2, -3, 3, -4, 4]
          arktest.assertEQ(foo(...((s: FixedArray<int>): FixedArray<int> => {
                let res: FixedArray<int> = []
                for (let el of s) if (el > 0) res = [...res, el]
                return res
          })(s)), 10)

    - decl: |-
          function foo(...p: FixedArray<number>): number {
              return p.length ? p[p.length - 1] : -1
          }
      use: |-
          // new expression in expression
          arktest.assertEQ(foo(...new number[256]), 0)

    - decl: |-
          function foo(...p: FixedArray<double>): double {
              return p[0] + p[1]
          }
      use: |-
          // array index expression
          let a: FixedArray<FixedArray<double>> = [[2.0, 3.0], []]
          arktest.assertEQ(foo(...a[0]), 5)

    - decl: |-
          function foo(...p: Array<double>): double {
              return p[0] + p[1] + p[2]
          }
      use: |-
          // tuple index expression
          let a: [string, FixedArray<double>, string] = ['X', [2.0, 3.0, 4.0], 'Z']
          arktest.assertEQ(foo(...a[1]), 9)

    - decl: |-
          function foo(...p: long[]): string {
              return reduce(p, (p: string, c: long) => p + c, '')
          }
      use: |-
          // assignment expression in expression
          let a1: FixedArray<long> = [1, 2, 3]
          let a2: FixedArray<long> = [4, 5]
          arktest.assertEQ(foo(...(a1 = a2)), '45')

    - decl: |-
          let a1: FixedArray<byte> = [1, 2, 3]
          let a2: FixedArray<byte> = [4, 5]
          function foo(...p: FixedArray<byte>): string {
              return reduce(p, (p: string, c: byte) => p + c, '')
          }
      use: |-
          // conditional expression in expression
          arktest.assertEQ(foo(...(a1.length > a2.length ? a1 : a2)), '123')

    - decl: |-
          class A {
              fld: FixedArray<boolean>
              constructor(p: FixedArray<boolean>, q: FixedArray<boolean>) {
                  this.fld = [...p, ...q]
              }
              meth(): number {
                  return foo(42, ...this.fld)
              }
          }
          function foo(a: int, ...p: FixedArray<boolean>): number {
              return a + p.length
          }
      use: |-
          // use this expression
          let a: A = new A([false, false], [true, true])
          arktest.assertEQ(a.meth(), 46)

    - decl: |-
          abstract class A {
              fld: FixedArray<boolean> = []
              constructor(p: FixedArray<boolean>) {
                  this.fld = p
              }
              meth(): FixedArray<boolean> {
                  return this.fld
              }
          }
          class B extends A {
              constructor(p: FixedArray<boolean>, q: FixedArray<boolean>) {
                  super([...p, ...q])
              }
              bar(): number {
                  return foo(42, ...super.meth())
              }
          }
          function foo(a: int, ...p: FixedArray<boolean>): number {
              return a + p.length
          }
      use: |-
          // use super expression
          let b: B = new B([false, false], [true, true])
          arktest.assertEQ(b.bar(), 46)

    - decl: |-
          function foo(...p: FixedArray<FixedArray<number>>): number {
              let res = 0
              for (let el of p) res += el.length
              return res
          }
      use: |-
          // spread of arrays
          let a1: FixedArray<FixedArray<number>> = [[1.0, 2.0], [], [3.0, 4.0], [5.0]]
          arktest.assertEQ(foo(...a1), 5)

    - decl: |-
          function foo(...p: FixedArray<FixedArray<number>>): FixedArray<number> {
              let res: FixedArray<number> = []
              for (let el of p) res = [...res, ...el]
              return res
          }
          function bar(...p: FixedArray<number>): number {
              let res = 0.0
              for (let el of p) res += el
              return res
          }
      use: |-
          // spread of arrays, flatten array
          let a1: FixedArray<FixedArray<number>> = [[1.0, 2.0], [3.0, 4.0]]
          let a2: FixedArray<FixedArray<number>> = [[5.0, 6.0], []]
          arktest.assertEQ(bar(...[...foo(...a1), ...foo(...a2)]), 21.0)

    - decl: |-
          function foo(...p: Array<Double|Short|Byte>): double {
              let res = 0.0
              for (let el of p) res += (el as Numeric).toDouble()
              return res
          }
      use: |-
          // union of value types in result array
          let a1: FixedArray<Double> = [1, 2, 3], a2: FixedArray<Short> = [4, 5], a3: FixedArray<Byte> = [6]
          let ar = [-10.0, ...a1, ...a1, ...a2, ...a2, ...a3, 10.0, ...a3]
          arktest.assertEQ(foo(...ar), 42.0)

    - decl: |-
          function foo(...p: Array<Double|Short|Byte>): double {
              let res = 0.0
              for (let el of p) res += (el as Numeric).doubleValue()
              return res
          }
      use: |-
          // union of value types in result array
          let a1: FixedArray<Double> = [1, 2, 3], a2: FixedArray<Short> = [4, 5], a3: FixedArray<Byte> = [6]
          let ar = [-10.0, ...a1, ...a1, ...a2, ...a2, ...a3, 10.0, ...a3]
          arktest.assertEQ(foo(...ar), 42.0)

    - decl: |-
          function foo(...p: FixedArray<Int|Number|String|undefined>): number {
              return p.length
          }
      use: |-
          // union of reference types in result array
          let a1: FixedArray<Int|Number|String|undefined> = [new Int(), new Int(), undefined, 'Z', 42.0]
          arktest.assertEQ(foo(...a1), 5)

    - decl: |-
          class A<T> {}
          class B<T> {}
          class C<T> {}
          function foo<T, U, V>(...p: FixedArray<A<T>|B<U>|C<V>|null>): number {
              return p.length
          }
      use: |-
          // use generics
          let a1: FixedArray<A<String>|B<Long>|C<Error>|null> = [new A<String>, new B<Long>, new C<Error>]
          arktest.assertEQ(foo<String, Long, Error>(...a1), 3)

    - decl: |-
          let a1: FixedArray<string> = ['1', '2', '3']
          function foo(...p: FixedArray<string>): string {
              return [...p].reduce((p: string, c: string) => p + c, '')
          }
      use: |-
          // lambda expression in expression
          arktest.assertEQ(foo(...((): FixedArray<string> => a1)()), '123')

    - decl: |-
          let a1: FixedArray<string> = ['1', '2', '3']
          function foo(...p: Array<string>): string {
              return p.reduce((p: string, c: string) => p + c, '')
          }
      use: |-
          // lambda expression in expression
          arktest.assertEQ(foo(...((p: FixedArray<string>, q: FixedArray<string>): Array<string> => [...p, ...q])(a1, a1)), '123123')

# iterables
    - decl: |-
          function foo(...p: string[]): string {
              return String.join(p, '-')
          }
          let a = 'iterable'
      use: |-
          // spread of iterable of strings
          arktest.assertEQ(foo(...a), 'i-t-e-r-a-b-l-e')

    - decl: |-
          function foo(...p: Array<[int, boolean]>): string {
              let res = ''
              for (let e of p) {
                  res += e[0] + ':' + e[1] + ','
              }
              return res
          }
          let a: Record<int, boolean> = {
              1: true,
              2: false,
          }
      use: |-
          // spread of iterable of tuples
          arktest.assertEQ(foo(...a), '1:true,2:false,')

# unions
    - decl: |-
          function foo(...p: Object[]): string {
              return ''.concat(...p.map((p: Any) => '' + p))
          }
          let a: Array<string>|Array<number> = ['1', '2', '3']
      use: |-
          // union of arrays in spread expression
          arktest.assertEQ(foo(...a), '123')

    - decl: |-
          function foo(...p: (number|string)[]): string {
              return '' + p[0] + p[1]
          }
          let a: [number, string]|[string, number] = [2.0, '1']
      use: |-
          // union of tuples in spread expression
          arktest.assertEQ(foo(...a), '21')

    - decl: |-
          function foo(...p: Object[]): string {
              return ''.concat(...p.map((p: Any) => '' + p))
          }
          let a: FixedArray<string>|FixedArray<number> = [1.0, 2.0, 3.0]
      use: |-
          // union of fixed arrays in spread expression
          arktest.assertEQ(foo(...a), '123')

    - decl: |-
          function foo(...p: (int|number|string)[]): string {
              return '' + p[0] + p[1]
          }
          let a: Array<string>|[string, int] = ['1', '2', '3']
      use: |-
          // union of array and tuple in spread expression
          arktest.assertEQ(foo(...a), '12')

    - decl: |-
          function foo(...p: Array<int|string>): string {
              return '' + p[0] + p[1]
          }
          let a: Array<string>|[string, int] = ['1', 2]
      use: |-
          // union of array and tuple in spread expression
          arktest.assertEQ(foo(...a), '12')

    - decl: |-
          function foo(...p: Object[]): string {
              return '' + p[0] + p[1]
          }
          let a: Array<string>|FixedArray<int>|[string, int]|[int, string] = ['1', '2', '3']
      use: |-
          // union of arrays and tuples in spread expression
          arktest.assertEQ(foo(...a), '12')

    - decl: |-
          function foo(...p: Array<string|int>): string {
              return '' + p[0] + p[1]
          }
          let a: Array<string>|FixedArray<int>|[string, int]|[int, string] = [1, 2, 3]
      use: |-
          // union of arrays and tuples in spread expression
          arktest.assertEQ(foo(...a), '12')

    - decl: |-
          function foo(...p: (int|string)[]): string {
              return '' + p[0] + p[1]
          }
          let a: Array<string>|FixedArray<int>|[string, int]|[int, string] = ['1', 2]
      use: |-
          // union of arrays and tuples in spread expression
          arktest.assertEQ(foo(...a), '12')

    - decl: |-
          function foo(...p: string[]): string {
              return ''.concat(...p.map((p: Any) => '' + p))
          }
          let a: Array<string>|Iterable<string> = ['1', '2', '3']
      use: |-
          // union of array and iterable in spread expression
          arktest.assertEQ(foo(...a), '123')

    - decl: |-
          function foo(...p: Array<string>): string {
              return ''.concat(...p.map((p: Any) => '' + p + '-'))
          }
          let a: Array<string>|Iterable<string> = 'iterable'
      use: |-
          // union of array and iterable in spread expression
          arktest.assertEQ(foo(...a), 'i-t-e-r-a-b-l-e-')

    - decl: |-
          function foo(...p: Object[]): string {
              return '' + p[0]
          }
          let a: Iterable<[string, int]>|Iterable<string>|[string, int] = { 'a': 1, 'b': 2 } as Record<string, int>
      use: |-
          // union of array, iterables, and tuple in spread expression
          arktest.assertEQ(foo(...a), 'a,1')

    - decl: |-
          function foo(...p: Object[]): string {
              return '' + p[0]
          }
          let a: Iterable<[string, int]>|Iterable<string>|[string, int] = 'xyz'
      use: |-
          // union of array, iterables, and tuple in spread expression
          arktest.assertEQ(foo(...a), 'x')

    - decl: |-
          function foo(...p: (string|[string, int]|int])[]): string {
              return '' + p[0]
          }
          let a: FixedArray<string>|Iterable<[string, int]>|[string, int] = ['xyz', 'abc']
      use: |-
          // union of array, iterables, and tuple in spread expression
          arktest.assertEQ(foo(...a), 'xyz')

    - decl: |-
          function foo(...p: Array<Object>): string {
              return '' + p[0]
          }
          let a: FixedArray<string>|Iterable<[string, int]>|Iterable<string>|[string, int] = ['xyz', 42]
      use: |-
          // union of array, iterables, and tuple in spread expression
          arktest.assertEQ(foo(...a), 'xyz')
