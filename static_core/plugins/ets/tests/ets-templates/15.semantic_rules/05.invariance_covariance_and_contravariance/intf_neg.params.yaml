# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    # subtyping in classes, call context
    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<T> {}  // invariance
          let holderA: Holder<A> = {} as Holder<A>
      use: |-
          ((p: Holder<B>) => {})(holderA)

    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<T> {}  // invariance
          let holderB: Holder<B> = {} as Holder<B>
      use: |-
          ((p: Holder<A>) => {})(holderB)

    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<out T> {}  // covariance
          let holderA: Holder<A> = {} as Holder<A>
      use: |-
          ((p: Holder<B>) => {})(holderA)

    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<in T> {}  // contravariance
          let holderB: Holder<B> = {} as Holder<B>
      use: |-
          ((p: Holder<A>) => {})(holderB)

    # subtyping in classes, assignment
    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<T> {}  // invariance
          let holderA: Holder<A> = {} as Holder<A>
      use: |-
          holderA = {} as Holder<B>

    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<T> {}  // invariance
          let holderB: Holder<B> = {} as Holder<B>
      use: |-
          holderB = {} as Holder<A>

    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<out T> {}  // covariance
          let holderB: Holder<B> = {} as Holder<B>
      use: |-
          holderB = {} as Holder<A>

    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<in T> {}  // contravariance
          let holderA: Holder<A> = {} as Holder<A>
      use: |-
          holderA = {} as Holder<B>

    # subtyping in classes/interfaces, call context
    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<T> {}  // invariance
          let holderI: Holder<I> = {} as Holder<I>
      use: |-
          ((p: Holder<B>) => {})(holderI)

    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<T> {}  // invariance
          let holderB: Holder<B> = {} as Holder<B>
      use: |-
          ((p: Holder<I>) => {})(holderB)

    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<out T> {}  // covariance
          let holderI: Holder<I> = {} as Holder<I>
      use: |-
          ((p: Holder<B>) => {})(holderI)

    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<in T> {}  // contravariance
          let holderB: Holder<B> = {} as Holder<B>
      use: |-
          ((p: Holder<I>) => {})(holderB)

    # subtyping in classes/interfaces, assignment
    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<T> {}  // invariance
          let holderI: Holder<I> = {} as Holder<I>
      use: |-
          holderI = {} as Holder<B>

    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<T> {}  // invariance
          let holderB: Holder<B> = {} as Holder<B>
      use: |-
          holderB = {} as Holder<I>

    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<out T> {}  // covariance
          let holderB: Holder<B> = {} as Holder<B>
      use: |-
          holderB = {} as Holder<I>

    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<in T> {}  // contravariance
          let holderI: Holder<I> = {} as Holder<I>
      use: |-
          holderI = {} as Holder<B>

    # subtyping in interfaces, call context
    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<T> {}  // invariance
          let holderI: Holder<I> = {} as Holder<I>
      use: |-
          ((p: Holder<J>) => {})(holderI)

    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<T> {}  // invariance
          let holderJ: Holder<J> = {} as Holder<J>
      use: |-
          ((p: Holder<I>) => {})(holderJ)

    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<out T> {}  // covariance
          let holderI: Holder<I> = {} as Holder<I>
      use: |-
          ((p: Holder<J>) => {})(holderI)

    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<in T> {}  // contravariance
          let holderJ: Holder<J> = {} as Holder<J>
      use: |-
          ((p: Holder<I>) => {})(holderJ)

    # subtyping in interfaces, assignment
    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<T> {}  // invariance
          let holderI: Holder<I> = {} as Holder<I>
      use: |-
          holderI = {} as Holder<J>

    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<T> {}  // invariance
          let holderJ: Holder<J> = {} as Holder<J>
      use: |-
          holderJ = {} as Holder<I>

    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<out T> {}  // covariance
          let holderJ: Holder<J> = {} as Holder<J>
      use: |-
          holderJ = {} as Holder<I>

    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<in T> {}  // contravariance
          let holderI: Holder<I> = {} as Holder<I>
      use: |-
          holderI = {} as Holder<J>

    # subtyping in functions, call context
    - decl: |-
          interface Holder<T> {} // invariance
          let holderSuper = {} as Holder<(p: string, q: number) => Object>
      use: |-
          ((p: Holder<() => string>) => {})(holderSuper)

    - decl: |-
          interface Holder<T> {} // invariance
          let holderSub = {} as Holder<() => string>
      use: |-
          ((p: Holder<(p: string, q: number) => Object>) => {})(holderSub)

    - decl: |-
          interface Holder<out T> {} // covariance
          let holderSuper = {} as Holder<(p: string, q: number) => Object>
      use: |-
          ((p: Holder<() => string>) => {})(holderSuper)

    - decl: |-
          interface Holder<in T> {} // contravariance
          let holderSub = {} as Holder<() => string>
      use: |-
          ((p: Holder<(p: string, q: number) => Object>) => {})(holderSub)

    # subtyping in functions, assignment
    - decl: |-
          interface Holder<T> {} // invariance
          let holderSuper = {} as Holder<(p: string, q: number) => Object>
      use: |-
          holderSuper = {} as Holder<() => string>

    - decl: |-
          interface Holder<T> {} // invariance
          let holderSub = {} as Holder<() => string>
      use: |-
          holderSub = {} as Holder<(p: string, q: number) => Object>

    - decl: |-
          interface Holder<out T> {} // covariance
          let holderSub = {} as Holder<() => string>
      use: |-
          holderSub = {} as Holder<(p: string, q: number) => Object>

    - decl: |-
          interface Holder<in T> {} // contravariance
          let holderSuper = {} as Holder<(p: string, q: number) => Object>
      use: |-
          holderSuper = {} as Holder<() => string>

    # subtyping in unions, call context
    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSuper: Holder<string|number|boolean|null> = {} as Holder<string|number|boolean|null>
      use: |-
          ((p: Holder<string|boolean|null>) => {})(holderSuper)

    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSub: Holder<string|boolean|null> = {} as Holder<string|boolean|null>
      use: |-
          ((p: Holder<string|number|boolean|null>) => {})(holderSub)

    - decl: |-
          interface Holder<out T> {}  // covariance
          let holderSuper: Holder<string|number|boolean|null> = {} as Holder<string|number|boolean|null>
      use: |-
          ((p: Holder<string|boolean|null>) => {})(holderSuper)

    - decl: |-
          interface Holder<in T> {}  // contravariance
          let holderSub: Holder<string|boolean|null> = {} as Holder<string|boolean|null>
      use: |-
          ((p: Holder<string|number|boolean|null>) => {})(holderSub)

    # subtyping in unions, assignment
    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSuper: Holder<string|number|boolean|null> = {} as Holder<string|number|boolean|null>
      use: |-
          holderSuper = {} as Holder<string|boolean|null>

    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSub: Holder<string|boolean|null> = {} as Holder<string|boolean|null>
      use: |-
          holderSub = {} as Holder<string|number|boolean|null>

    - decl: |-
          interface Holder<out T> {}  // covariance
          let holderSub: Holder<string|boolean|null> = {} as Holder<string|boolean|null>
      use: |-
          holderSub = {} as Holder<string|number|boolean|null>

    - decl: |-
          interface Holder<in T> {}  // contravariance
          let holderSuper: Holder<string|number|boolean|null> = {} as Holder<string|number|boolean|null>
      use: |-
          holderSuper = {} as Holder<string|boolean|null>

    # subtyping in FixedArrays, call context
    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSuper: Holder<FixedArray<Object>> = {} as Holder<FixedArray<Object>>
      use: |-
          ((p: Holder<FixedArray<string>>) => {})(holderSuper)

    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSub: Holder<FixedArray<string>> = {} as Holder<FixedArray<string>>
      use: |-
          ((p: Holder<FixedArray<Object>>) => {})(holderSub)

    - decl: |-
          interface Holder<out T> {}  // covariance
          let holderSuper: Holder<FixedArray<Object>> = {} as Holder<FixedArray<Object>>
      use: |-
          ((p: Holder<FixedArray<string>>) => {})(holderSuper)

    - decl: |-
          interface Holder<in T> {}  // contravariance
          let holderSub: Holder<FixedArray<string>> = {} as Holder<FixedArray<string>>
      use: |-
          ((p: Holder<FixedArray<Object>>) => {})(holderSub)

    # subtyping in FixedArrays, assignment
    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSuper: Holder<FixedArray<Object>> = {} as Holder<FixedArray<Object>>
      use: |-
          holderSuper = {} as Holder<FixedArray<string>>

    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSub: Holder<FixedArray<string>> = {} as Holder<FixedArray<string>>
      use: |-
          holderSub = {} as Holder<FixedArray<Object>>

    - decl: |-
          interface Holder<out T> {}  // covariance
          let holderSub: Holder<FixedArray<string>> = {} as Holder<FixedArray<string>>
      use: |-
          holderSub = {} as Holder<FixedArray<Object>>

    - decl: |-
          interface Holder<in T> {}  // contravariance
          let holderSuper: Holder<FixedArray<Object>> = {} as Holder<FixedArray<Object>>
      use: |-
          holderSuper = {} as Holder<FixedArray<string>>

    # subtyping in literals, call context
    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSuper: Holder<string> = {} as Holder<string>
      use: |-
          ((p: Holder<"ABC">) => {})(holderSuper)

    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSub: Holder<"ABC"> = {} as Holder<"ABC">
      use: |-
          ((p: Holder<string>) => {})(holderSub)

    - decl: |-
          interface Holder<out T> {}  // covariance
          let holderSuper: Holder<string> = {} as Holder<string>
      use: |-
          ((p: Holder<"ABC">) => {})(holderSuper)

    - decl: |-
          interface Holder<in T> {}  // contravariance
          let holderSub: Holder<"ABC"> = {} as Holder<"ABC">
      use: |-
          ((p: Holder<string>) => {})(holderSub)

    # subtyping in literals, assignment
    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSuper: Holder<string> = {} as Holder<string>
      use: |-
          holderSuper = {} as Holder<"ABC">

    - decl: |-
          interface Holder<T> {}  // invariance
          let holderSub: Holder<"ABC"> = {} as Holder<"ABC">
      use: |-
          holderSub = {} as Holder<string>

    - decl: |-
          interface Holder<out T> {}  // covariance
          let holderSub: Holder<"ABC"> = {} as Holder<"ABC">
      use: |-
          holderSub = {} as Holder<string>

    - decl: |-
          interface Holder<in T> {}  // contravariance
          let holderSuper: Holder<string> = {} as Holder<string>
      use: |-
          holderSuper = {} as Holder<"ABC">
