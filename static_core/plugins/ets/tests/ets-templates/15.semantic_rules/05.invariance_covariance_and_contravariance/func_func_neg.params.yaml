# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    # assignment, contravariance in arguments, function type argument, case 1
    - decl: |-
          let superFoo: (p: (p: A) => Any) => Any = (p: (p: A) => Any): Any => 10
          let subFoo: (p: (p: B) => Any) => Any = (p: (p: B) => Any): Any => 20
      use: |-
          subFoo = superFoo

    # assignment, contravariance in arguments, function type argument, case 2
    - decl: |-
          let superFoo: (p: (p: string|number|undefined) => Any) => Any = (p: (p: string|number|undefined) => Any): Any => 10
          let subFoo: (p: (p: string|number) => Any) => Any = (p: (p: string|number) => Any): Any => 20
      use: |-
          subFoo = superFoo

    # assignment, contravariance in arguments, function type argument, case 3
    - decl: |-
          let superFoo: (p: (p: (p: Object) => Any) => Any) => Any = (p: (p: (p: Object) => Any) => Any): Any => 10
          let subFoo: (p: (p: (p: Any) => Object) => Any) => Any = (p: (p: (p: Any) => Object) => Any): Any => 20
      use: |-
          subFoo = superFoo

    # assignment, covariance in return type, function type return, case 1
    - decl: |-
          let sup: (p: A) => Object = (p: A): Object => a
          let sub: (p: A) => boolean = (p: A): boolean => p === b

          // covariance in return type
          let superFoo: (p: Object) => ((p: A) => Object) = (p: Object): ((p: A) => Object) => sup
          let subFoo: (p: Object) => ((p: A) => boolean) = (p: Object): ((p: A) => boolean) => sub
      use: |-
          subFoo = superFoo

    # assignment, covariance in return type, function type return, case 2
    - decl: |-
          let sup: (p: A) => string|boolean|number|null = (p: A): string|boolean|number|null => null
          let sub: (p: A) => boolean|number = (p: A): boolean|number => p === b

          // covariance in return type
          let superFoo: (p: Object) => ((p: A) => string|boolean|number|null) = (p: Object): ((p: A) => string|boolean|number|null) => sup
          let subFoo: (p: Object) => ((p: A) => boolean|number) = (p: Object): ((p: A) => boolean|number) => sub
      use: |-
          subFoo = superFoo'

    # assignment, covariance in return type, function type return, case 3
    - decl: |-
          let sup: (p: A) => ((p: string) => number) = (p: A): ((p: string) => number) => (p: string): number => 10
          let sub: (p: A) => ((p: Object) => number) = (p: A): ((p: Object) => number) => (p: Object): number => 20

          // covariance in return type
          let superFoo: (p: Object) => ((p: A) => ((p: string) => number)) = (p: Object): ((p: A) => ((p: string) => number)) => sup
          let subFoo: (p: Object) => ((p: A) => ((p: Object) => number)) = (p: Object): ((p: A) => ((p: Object) => number)) => sub
      use: |-
          subFoo = superFoo

    # call context, contravariance in arguments, function type argument, case 1
    - decl: |-
          let superFoo: (p: (p: A) => Any) => Any = (p: (p: A) => Any): Any => 10
      use: |-
          // subtype is (p: (p: B) => Any) => Any
          ((p: ((p: (p: B) => Any) => Any)) => {})(superFoo)

    # call context, covariance in return type, function type return, case 1
    - decl: |-
          let sup: (p: A) => Object = (p: A): Object => a

          // covariance in return type
          let superFoo: (p: Object) => ((p: A) => Object) = (p: Object): ((p: A) => Object) => sup
      use: |-
          // subtype is (p: Object) => ((p: A) => boolean)
          ((p: ((p: Object) => ((p: A) => boolean))) => {})(superFoo)
