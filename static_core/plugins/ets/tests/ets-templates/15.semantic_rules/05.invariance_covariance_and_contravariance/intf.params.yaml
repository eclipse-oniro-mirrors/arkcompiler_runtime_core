# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    # subtyping in classes, call context
    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<out T> {  // covariance
              readonly f: T
          }
          let b = new B
          let holderB: Holder<B> = { f: b } as Holder<B>
      use: |-
          ((p: Holder<A>) => {
              arktest.assertEQ(p.f, b)
          })(holderB)

    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let b = new B
          let res: Any
          let holderA: Holder<A> = new CHolder<A>
      use: |-
          ((p: Holder<B>) => {
              p.meth(b)
              arktest.assertEQ(res, b)
          })(holderA)

    # subtyping in classes, assignment
    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<out T> {  // covariance
              readonly f: T
          }
          let a = new A
          let b = new B
          let holderA: Holder<A> = { f: a } as Holder<A>
      use: |-
          holderA = { f: b } as Holder<B>
          arktest.assertEQ(holderA.f, b)

    - decl: |-
          class A {}
          class B extends A {}
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let b = new B
          let res: Any
          let holderB: Holder<B> = new CHolder<B>
      use: |-
          holderB = new CHolder<A>
          holderB.meth(b)
          arktest.assertEQ(res, b)

    # subtyping in classes/interfaces, call context

    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<out T> {  // covariance
              readonly f: T
          }
          let b = new B
          let holderB: Holder<B> = { f: b } as Holder<B>
      use: |-
          ((p: Holder<I>) => {
              arktest.assertEQ(p.f, b)
          })(holderB)

    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let b = new B
          let res: Any
          let holderI: Holder<I> = new CHolder<I>
      use: |-
          ((p: Holder<B>) => {
              p.meth(b)
              arktest.assertEQ(res, b)
          })(holderI)

    # subtyping in classes/interfaces, assignment

    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<out T> {  // covariance
              readonly f: T
          }
          let i = {} as I
          let b = new B
          let holderI: Holder<I> = { f: i } as Holder<I>
      use: |-
          holderI = { f: b } as Holder<B>
          arktest.assertEQ(holderI.f, b)

    - decl: |-
          interface I {}
          class B implements I {}
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let b = new B
          let res: Any
          let holderB: Holder<B> = new CHolder<B>
      use: |-
          holderB = new CHolder<I>
          holderB.meth(b)
          arktest.assertEQ(res, b)

    # subtyping in interfaces, call context
    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<out T> {  // covariance
              readonly f: T
          }
          let j = {} as J
          let holderJ: Holder<J> = { f: j } as Holder<J>
      use: |-
          ((p: Holder<I>) => {
              arktest.assertEQ(p.f, j)
          })(holderJ)

    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let j = {} as J
          let res: Any
          let holderI: Holder<I> = new CHolder<I>
      use: |-
          ((p: Holder<J>) => {
              p.meth(j)
              arktest.assertEQ(res, j)
          })(holderI)

    # subtyping in interfaces, assignment

    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<out T> { // covariance
              readonly f: T
          }
          let i = {} as I
          let j = {} as J
          let holderI: Holder<I> = { f: i } as Holder<I>
      use: |-
          holderI = { f: j } as Holder<J>
          arktest.assertEQ(holderI.f, j)

    - decl: |-
          interface I {}
          interface J extends I {}
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let j = {} as J
          let res: Any
          let holderJ: Holder<J> = new CHolder<J>
      use: |-
          holderJ = new CHolder<I>
          holderJ.meth(j)
          arktest.assertEQ(res, j)

    # subtyping in functions, call context
    - decl: |-
          interface Holder<out T> { // covariance
              readonly f: T
          }
          let fSub: () => string = () => "ABC"
          let holderSub = { f: fSub } as Holder<() => string>
      use: |-
          ((p: Holder<(p: string, q: number) => Object>) => {
              arktest.assertEQ(p.f("", 0.0), "ABC")
          })(holderSub)

    - decl: |-
          interface Holder<in T> { // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let fSub: () => string = () => "ABC"
          let res:Any
          let holderSuper = new CHolder<(p: string, q: number) => Object>
      use: |-
          ((p: Holder<() => string>) => {
              p.meth(fSub)
              arktest.assertEQ(res, fSub)
          })(holderSuper)

    # subtyping in functions, assignment

    - decl: |-
          interface Holder<out T> { // covariance
              readonly f: T
          }
          let fSup: (p: string, q: number) => Object = (p: string, q: number): Object => p
          let fSub: () => string = () => "ABC"
          let holderSuper = { f: fSup } as Holder<(p: string, q: number) => Object>
      use: |-
          holderSuper = { f: fSub } as Holder<() => string>
          arktest.assertEQ(holderSuper.f, fSub)

    - decl: |-
          interface Holder<in T> { // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let fSub: () => string = () => "ABC"
          let res: Any
          let holderSub = new CHolder<() => string>
      use: |-
          holderSub = new CHolder<(p: string, q: number) => Object>
          holderSub.meth(fSub)
          arktest.assertEQ(res, fSub)

    # subtyping in unions, call context

    - decl: |-
          interface Holder<out T> {  // covariance
              readonly f: T
          }
          let sbn: string|boolean|null = "A"
          let holderSub: Holder<string|boolean|null> = { f: sbn } as Holder<string|boolean|null>
      use: |-
          ((p: Holder<string|number|boolean|null>) => {
              arktest.assertEQ(p.f, "A")
          })(holderSub)

    - decl: |-
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let sbn: string|boolean|null = "A"
          let holderSuper: Holder<string|number|boolean|null> = new CHolder<string|number|boolean|null>
      use: |-
          ((p: Holder<string|boolean|null>) => {
              p.meth(sbn)
              arktest.assertEQ(res, "A")
          })(holderSuper)

    # subtyping in unions, assignment

    - decl: |-
          interface Holder<out T> {  // covariance
              readonly f: T
          }
          let sup: string|number|boolean|null = "A"
          let sub: string|boolean|null = "B"
          let holderSuper: Holder<string|number|boolean|null> = { f: sup } as Holder<string|number|boolean|null>
      use: |-
          holderSuper = { f: sub } as Holder<string|boolean|null>
          arktest.assertEQ(holderSuper.f, "B")

    - decl: |-
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let sub: string|boolean|null = "B"
          let holderSub: Holder<string|boolean|null> = new CHolder<string|boolean|null>
      use: |-
          holderSub = new CHolder<string|number|boolean|null>
          holderSub.meth(sub)
          arktest.assertEQ(res, "B")

    # subtyping in FixedArrays, call context
    - decl: |-
          interface Holder<out T> {  // covariance
              readonly f: T
          }
          let sub: FixedArray<string> = ["B"]
          let holderSub: Holder<FixedArray<string>> = { f: sub } as Holder<FixedArray<string>>
      use: |-
          ((p: Holder<FixedArray<Object>>) => {
              arktest.assertEQ(p.f, sub)
          })(holderSub)

    - decl: |-
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let sub: FixedArray<string> = ["B"]
          let holderSuper: Holder<FixedArray<Object>> = new CHolder<FixedArray<Object>>
      use: |-
          ((p: Holder<FixedArray<string>>) => {
              p.meth(sub)
              arktest.assertEQ(res, sub)
          })(holderSuper)

    # subtyping in FixedArrays, assignment

    - decl: |-
          interface Holder<out T> {  // covariance
              readonly f: T
          }
          let sub: FixedArray<string> = ["B"]
          let sup: FixedArray<Object> = [new Object]
          let holderSuper: Holder<FixedArray<Object>> = { f: sup } as Holder<FixedArray<Object>>
      use: |-
          holderSuper = { f: sub } as Holder<FixedArray<string>>
          arktest.assertEQ(holderSuper.f, sub)

    - decl: |-
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let sub: FixedArray<string> = ["B"]
          let holderSub: Holder<FixedArray<string>> = new CHolder<FixedArray<string>>
      use: |-
          holderSub = new CHolder<FixedArray<Object>>
          holderSub.meth(sub)
          arktest.assertEQ(res, sub)

    # subtyping in literals, call context

    - decl: |-
          interface Holder<out T> {  // covariance
              readonly f: T
          }
          let holderSub: Holder<"ABC"> = { f: "ABC" } as Holder<"ABC">
      use: |-
          ((p: Holder<string>) => {
              arktest.assertEQ(p.f, "ABC")
          })(holderSub)

    - decl: |-
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let holderSuper: Holder<string> = new CHolder<string>
      use: |-
          ((p: Holder<"ABC">) => {
              p.meth("ABC")
              arktest.assertEQ(res, "ABC")
          })(holderSuper)

    # subtyping in literals, assignment

    - decl: |-
          interface Holder<out T> {  // covariance
              readonly f: T
          }
          let holderSuper: Holder<string> = { f: "A" } as Holder<string>
      use: |-
          holderSuper = { f: "ABC" } as Holder<"ABC">
          arktest.assertEQ(holderSuper.f, "ABC")

    - decl: |-
          interface Holder<in T> {  // contravariance
              meth(p: T)
          }
          class CHolder<in T> implements Holder<T> {
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let holderSub: Holder<"ABC"> = new CHolder<"ABC">
      use: |-
          holderSub = new CHolder<string>
          holderSub.meth("ABC")
          arktest.assertEQ(res, "ABC")
