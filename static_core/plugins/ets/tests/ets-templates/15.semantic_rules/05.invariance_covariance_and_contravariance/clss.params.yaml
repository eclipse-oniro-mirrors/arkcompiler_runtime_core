# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    # subtyping in classes, call context
    - decl: |-
          class A {}
          class B extends A {}
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let b = new B
          let boxB: BBox<B> = new BBox<B>(b)
      use: |-
          ((p: BBox<A>) => {
              arktest.assertEQ(p.f, b)
          })(boxB)

    - decl: |-
          class A {}
          class B extends A {}
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let b = new B
          let res: Any
          let boxA: BBox<A> = new BBox<A>
      use: |-
          ((p: BBox<B>) => {
              p.meth(b)
              arktest.assertEQ(res, b)
          })(boxA)

    # subtyping in classes, assignment

    - decl: |-
          class A {}
          class B extends A {}
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let a = new A
          let b = new B
          let boxA: BBox<A> = new BBox<A>(a)
      use: |-
          boxA = new BBox<B>(b)
          arktest.assertEQ(boxA.f, b)

    - decl: |-
          class A {}
          class B extends A {}
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let b = new B
          let res: Any
          let boxB: BBox<B> = new BBox<B>
      use: |-
          boxB = new BBox<A>
          boxB.meth(b)
          arktest.assertEQ(res, b)

    # subtyping in classes/interfaces, call context

    - decl: |-
          interface I {}
          class B implements I {}
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let b = new B
          let boxB: BBox<B> = new BBox<B>(b)
      use: |-
          ((p: BBox<I>) => {
              arktest.assertEQ(p.f, b)
          })(boxB)

    - decl: |-
          interface I {}
          class B implements I {}
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let b = new B
          let res: Any
          let boxI: BBox<I> = new BBox<I>
      use: |-
          ((p: BBox<B>) => {
              p.meth(b)
              arktest.assertEQ(res, b)
          })(boxI)

    # subtyping in classes/interfaces, assignment

    - decl: |-
          interface I {}
          class B implements I {}
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let i = {} as I
          let b = new B
          let boxI: BBox<I> = new BBox<I>(i)
      use: |-
          boxI = new BBox<B>(b)
          arktest.assertEQ(boxI.f, b)

    - decl: |-
          interface I {}
          class B implements I {}
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let b = new B
          let res: Any
          let boxB: BBox<B> = new BBox<B>
      use: |-
          boxB = new BBox<I>
          boxB.meth(b)
          arktest.assertEQ(res, b)

    # subtyping in interfaces, call context

    - decl: |-
          interface I {}
          interface J extends I {}
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let j = {} as J
          let boxJ: BBox<J> = new BBox<J>(j)
      use: |-
          ((p: BBox<I>) => {
              arktest.assertEQ(p.f, j)
          })(boxJ)

    - decl: |-
          interface I {}
          interface J extends I {}
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let j = {} as J
          let res: Any
          let boxI: BBox<I> = new BBox<I>
      use: |-
          ((p: BBox<J>) => {
              p.meth(j)
              arktest.assertEQ(res, j)
          })(boxI)

    # subtyping in interfaces, assignment

    - decl: |-
          interface I {}
          interface J extends I {}
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let i = {} as I
          let j = {} as J
          let boxI: BBox<I> = new BBox<I>(i)
      use: |-
          boxI = new BBox<J>(j)
          arktest.assertEQ(boxI.f, j)

    - decl: |-
          interface I {}
          interface J extends I {}
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let j = {} as J
          let res:Any
          let boxJ: BBox<J> = new BBox<J>
      use: |-
          boxJ = new BBox<I>
          boxJ.meth(j)
          arktest.assertEQ(res, j)

    # subtyping in functions, call context
    - decl: |-
          class BBox<out T> { // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let fSub: () => string = () => "ABC"
          let boxSub = new BBox<() => string>(fSub)
      use: |-
          ((p: BBox<(p: string, q: number) => Object>) => {
              arktest.assertEQ(p.f("", 0.0), "ABC")
          })(boxSub)

    - decl: |-
          class BBox<in T> { // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let fSub: () => string = () => "ABC"
          let res:Any
          let boxSup = new BBox<(p: string, q: number) => Object>
      use: |-
          ((p: BBox<() => string>) => {
              p.meth(fSub)
              arktest.assertEQ(res, fSub)
          })(boxSup)

    # subtyping in functions, assignment

    - decl: |-
          class BBox<out T> { // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let fSup: (p: string, q: number) => Object = (p: string, q: number): Object => p
          let fSub: () => string = () => "ABC"
          let boxSup = new BBox<(p: string, q: number) => Object>(fSup)
      use: |-
          boxSup = new BBox<() => string>(fSub)
          arktest.assertEQ(boxSup.f, fSub)

    - decl: |-
          class BBox<in T> { // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let fSub: () => string = () => "ABC"
          let res: Any
          let boxSub = new BBox<() => string>
      use: |-
          boxSub = new BBox<(p: string, q: number) => Object>
          boxSub.meth(fSub)
          arktest.assertEQ(res, fSub)

    # subtyping in unions, call context

    - decl: |-
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let sbn: string|boolean|null = "A"
          let boxSub: BBox<string|boolean|null> = new BBox<string|boolean|null>(sbn)
      use: |-
          ((p: BBox<string|number|boolean|null>) => {
              arktest.assertEQ(p.f, "A")
          })(boxSub)

    - decl: |-
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let sbn: string|boolean|null = "A"
          let boxSup: BBox<string|number|boolean|null> = new BBox<string|number|boolean|null>
      use: |-
          ((p: BBox<string|boolean|null>) => {
              p.meth(sbn)
              arktest.assertEQ(res, "A")
          })(boxSup)

    # subtyping in unions, assignment

    - decl: |-
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let sup: string|number|boolean|null = "A"
          let sub: string|boolean|null = "B"
          let boxSup: BBox<string|number|boolean|null> = new BBox<string|number|boolean|null>(sup)
      use: |-
          boxSup = new BBox<string|boolean|null>(sub)
          arktest.assertEQ(boxSup.f, "B")

    - decl: |-
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let sub: string|boolean|null = "B"
          let boxSub: BBox<string|boolean|null> = new BBox<string|boolean|null>
      use: |-
          boxSub = new BBox<string|number|boolean|null>
          boxSub.meth(sub)
          arktest.assertEQ(res, "B")

    # subtyping in FixedArrays, call context

    - decl: |-
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let sub: FixedArray<string> = ["B"]
          let boxSub: BBox<FixedArray<string>> = new BBox<FixedArray<string>>(sub)
      use: |-
          ((p: BBox<FixedArray<Object>>) => {
              arktest.assertEQ(p.f, sub)
          })(boxSub)

    - decl: |-
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let sub: FixedArray<string> = ["B"]
          let boxSup: BBox<FixedArray<Object>> = new BBox<FixedArray<Object>>
      use: |-
          ((p: BBox<FixedArray<string>>) => {
              p.meth(sub)
              arktest.assertEQ(res, sub)
          })(boxSup)

    # subtyping in FixedArrays, assignment

    - decl: |-
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let sub: FixedArray<string> = ["B"]
          let sup: FixedArray<Object> = [new Object]
          let boxSup: BBox<FixedArray<Object>> = new BBox<FixedArray<Object>>(sup)
      use: |-
          boxSup = new BBox<FixedArray<string>>(sub)
          arktest.assertEQ(boxSup.f, sub)

    - decl: |-
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let sub: FixedArray<string> = ["B"]
          let boxSub: BBox<FixedArray<string>> = new BBox<FixedArray<string>>
      use: |-
          boxSub = new BBox<FixedArray<Object>>
          boxSub.meth(sub)
          arktest.assertEQ(res, sub)

    # subtyping in literals, call context

    - decl: |-
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let boxSub: BBox<"ABC"> = new BBox<"ABC">("ABC")
      use: |-
          ((p: BBox<string>) => {
              arktest.assertEQ(p.f, "ABC")
          })(boxSub)

    - decl: |-
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let boxSup: BBox<string> = new BBox<string>
      use: |-
          ((p: BBox<"ABC">) => {
              p.meth("ABC")
              arktest.assertEQ(res, "ABC")
          })(boxSup)

    # subtyping in literals, assignment

    - decl: |-
          class BBox<out T> {  // covariance
              readonly f: T
              constructor(p: T) {
                  this.f = p
              }
          }
          let boxSup: BBox<string> = new BBox<string>("A")
      use: |-
          boxSup = new BBox<"ABC">("ABC")
          arktest.assertEQ(boxSup.f, "ABC")

    - decl: |-
          class BBox<in T> {  // contravariance
              meth(p: T) {
                  res = p
              }
          }
          let res: Any
          let boxSub: BBox<"ABC"> = new BBox<"ABC">
      use: |-
          boxSub = new BBox<string>
          boxSub.meth("ABC")
          arktest.assertEQ(res, "ABC")
