# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

cases:
  # in global var
  - base: class A<T,S>
    derived: class B<T,S>
    clause: extends
    decl: |-
      let t: A<D,E>
    use:
      call_base: (t = new A<D,E>)
      call_derived: (t = new B<D,E>)
      type_base: A
      type_derived: B

  - base: class A<T,S>
    derived: class B<T,S>
    clause: extends
    decl: |-
      let t: Object     
    use:
      call_base: (t = new Object)
      call_derived: (t = new B<D,E>)
      type_base: Object
      type_derived: B

  - base: interface A<T,S>
    derived: class B<T,S>
    clause: implements
    decl: |-
      let a: A<D,E>
      let s: B<D,E> = new B<D,E>
      let t: A<D,E>
    decl2: t = {}
    use:
      call_base: (a = t)
      call_derived: (a = t = s)
      type_base: A
      type_derived: B

  - base: interface A<T,S>
    derived: interface B<T,S>
    clause: extends
    decl: |-
      let a: A<D,E>
      let s: B<D,E>
      let t: A<D,E>
      class X<T,S> implements A<T,S> {}
      class Y<T,S> implements B<T,S> {}
      t = new X<D,E>
      s = new Y<D,E>     
    use:
      call_base: (a = t)
      call_derived: (a = s)
      type_base: A
      type_derived: B

  - base: interface A<T,S>
    derived: class B<T,S>
    clause: implements
    decl: |-
      let a: Object  
      let s: A<D,E> = new B<D,E>; 
    use:
      call_base: (a = new Object)
      call_derived: (a = s)
      type_base: Object
      type_derived: B

  # in function signature
  - base: class A<T,S>
    derived: class B<T,S>
    clause: extends
    decl: |-
      function foo(t: A<D,E>): A<D,E> {
        return t
      }      
    use:
      call_base: foo(new A<D,E>)
      call_derived: foo(new B<D,E>)
      type_base: A
      type_derived: B

  - base: class A<T,S>
    derived: class B<T,S>
    clause: extends
    decl: |-
      function foo(t: Object): Object {
        return t
      }      
    use:
      call_base: foo(new Object)
      call_derived: foo(new B<D,E>)
      type_base: Object
      type_derived: B

  - base: interface A<T,S>
    derived: class B<T,S>
    clause: implements
    decl: |-
      function foo(t: A<D,E>): A<D,E> {
        return t
      }
      let s: B<D,E> = new B<D,E>
      let t: A<D,E>
    decl2: t = {}
    use:
      call_base: foo(t)
      call_derived: foo(t = s)
      type_base: A
      type_derived: B

  - base: interface A<T,S>
    derived: interface B<T,S>
    clause: extends
    decl: |-
      function foo(t: A<D,E>): A<D,E> {
        return t
      }
      let t: A<D,E>
      let s: B<D,E>
      class X<T,S> implements A<T,S> {}
      class Y<T,S> implements B<T,S> {}
      t = new X<D,E>
      s = new Y<D,E>      
    use:
      call_base: foo(t)
      call_derived: foo(s)
      type_base: A
      type_derived: B

  - base: interface A<T,S>
    derived: class B<T,S>
    clause: implements
    decl: |-
      function foo(t: Object): Object {
        return t
      }    
      let s: A<D,E> = new B<D,E>; 
    use:
      call_base: foo(new Object)
      call_derived: foo(s)
      type_base: Object
      type_derived: B

  # in class method signature
  - base: class A<T,S>
    derived: class B<T,S>
    clause: extends
    decl: |-
      class C {
        foo(t: A<D,E>): A<D,E> {
          return t
        } 
      }
    use:
      call_base: new C().foo(new A<D,E>)
      call_derived: new C().foo(new B<D,E>)
      type_base: A
      type_derived: B

  - base: class A<T,S>
    derived: class B<T,S>
    clause: extends
    decl: |-
      class C {
        foo(t: Object): Object {
          return t
        } 
      }     
    use:
      call_base: new C().foo(new Object)
      call_derived: new C().foo(new B<D,E>)
      type_base: Object
      type_derived: B

  - base: interface A<T,S>
    derived: class B<T,S>
    clause: implements
    decl: |-
      class C {
        foo(t: A<D,E>): A<D,E> {
          return t
        } 
      }
      let s: B<D,E> = new B<D,E>
      let t: A<D,E>
    decl2: t = {}
    use:
      call_base: new C().foo(t)
      call_derived: new C().foo(t = s)
      type_base: A
      type_derived: B

  - base: interface A<T,S>
    derived: interface B<T,S>
    clause: extends
    decl: |-
      class C {
        foo(t: A<D,E>): A<D,E> {
          return t
        } 
      }
      let s: B<D,E>
      let t: A<D,E>
      class X<T,S> implements A<T,S> {}
      class Y<T,S> implements B<T,S> {}
      t = new X<D,E>
      s = new Y<D,E>      
    use:
      call_base: new C().foo(t)
      call_derived: new C().foo(s)
      type_base: A
      type_derived: B

  - base: interface A<T,S>
    derived: class B<T,S>
    clause: implements
    decl: |-
      class C {
        foo(t: Object): Object {
          return t
        } 
      }    
      let s: A<D,E> = new B<D,E>; 
    use:
      call_base: new C().foo(new Object)
      call_derived: new C().foo(s)
      type_base: Object
      type_derived: B
      
  # in class static method signature
  - base: class A<T,S>
    derived: class B<T,S>
    clause: extends
    decl: |-
      class C {
        static foo(t: A<D,E>): A<D,E> {
          return t
        } 
      }
    use:
      call_base: C.foo(new A<D,E>)
      call_derived: C.foo(new B<D,E>)
      type_base: A
      type_derived: B

  - base: class A<T,S>
    derived: class B<T,S>
    clause: extends
    decl: |-
      class C {
        static foo(t: Object): Object {
          return t
        } 
      }     
    use:
      call_base: C.foo(new Object)
      call_derived: C.foo(new B<D,E>)
      type_base: Object
      type_derived: B

  - base: interface A<T,S>
    derived: class B<T,S>
    clause: implements
    decl: |-
      class C {
        static foo(t: A<D,E>): A<D,E> {
          return t
        } 
      }
      let s: B<D,E> = new B<D,E>
      let t: A<D,E>
    decl2: t = {}
    use:
      call_base: C.foo(t)
      call_derived: C.foo(t = s)
      type_base: A
      type_derived: B

  - base: interface A<T,S>
    derived: interface B<T,S>
    clause: extends
    decl: |-
      class C {
        static foo(t: A<D,E>): A<D,E> {
          return t
        } 
      }
      let s: B<D,E>
      let t: A<D,E>
      class X<T,S> implements A<T,S> {}
      class Y<T,S> implements B<T,S> {}
      t = new X<D,E>
      s = new Y<D,E>      
    use:
      call_base: C.foo(t)
      call_derived: C.foo(s)
      type_base: A
      type_derived: B

  - base: interface A<T,S>
    derived: class B<T,S>
    clause: implements
    decl: |-
      class C {
        static foo(t: Object): Object {
          return t
        } 
      }    
      let s: A<D,E> = new B<D,E>; 
    use:
      call_base: C.foo(new Object)
      call_derived: C.foo(s)
      type_base: Object
      type_derived: B

  # in class field and constructor
  - base: class A<T,S>
    derived: class B<T,S>
    clause: extends
    decl: |-
      class C {
        a: A<D,E>
        constructor(a: A<D,E>) {
          this.a = a
        }
      }  
    use:
      call_base: new C(new A<D,E>).a
      call_derived: new C(new B<D,E>).a
      type_base: A
      type_derived: B

  - base: class A<T,S>
    derived: class B<T,S>
    clause: extends
    decl: |-
      class C {
        a: Object
        constructor(a: Object) {
          this.a = a
        }
      }     
    use:
      call_base: new C(new Object).a
      call_derived: new C(new B<D,E>).a
      type_base: Object
      type_derived: B

  - base: interface A<T,S>
    derived: class B<T,S>
    clause: implements
    decl: |-
      class C {
        a: A<D,E>
        constructor(a: A<D,E>) {
          this.a = a
        }
      }  
      let s: B<D,E> = new B<D,E>
      let t: A<D,E>
    decl2: t = {}
    use:
      call_base: new C(t).a
      call_derived: new C(t = s).a
      type_base: A
      type_derived: B

  - base: interface A<T,S>
    derived: interface B<T,S>
    clause: extends
    decl: |-
      class C {
        c: A<D,E>
        constructor(c: A<D,E>) {
          this.c = c
        }
      }  
      let s: B<D,E>
      let t: A<D,E>
      class X<T,S> implements A<T,S> {}
      class Y<T,S> implements B<T,S> {}
      t = new X<D,E>
      s = new Y<D,E>      
    use:
      call_base: new C(t).c
      call_derived: new C(s).c
      type_base: A
      type_derived: B

  - base: interface A<T,S>
    derived: class B<T,S>
    clause: implements
    decl: |-
      class C {
        a: Object
        constructor(a: Object) {
          this.a = a
        }
      }  
      let s: A<D,E> = new B<D,E>; 
    use:
      call_base: new C(new Object).a
      call_derived: new C(s).a
      type_base: Object
      type_derived: B
