# Copyright (c) 2021-2026 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    - decl: |-
          // value types
          class A {
              t: string = ""
              constructor(p: boolean) { this.t = "boolean" }
              constructor(p: byte) { this.t = "byte" }
              constructor(p: short) { this.t = "short" }
              constructor(p: int) { this.t = "int" }
              constructor(p: long) { this.t = "long" }
              constructor(p: char) { this.t = "char" }
              constructor(p: float) { this.t = "float" }
              constructor(p: double) { this.t = "double" }
              constructor(p: Object) { this.t = "should never be called" }
          }
      use: |-
          arktest.assertEQ(new A(new Byte(-1 as byte)).t, "byte")
          arktest.assertEQ(new A(new Short(-1 as short)).t, "short")
          arktest.assertEQ(new A(new Int(-1 as int)).t, "int")
          arktest.assertEQ(new A(new Long(-1 as long)).t, "long")
          arktest.assertEQ(new A(new Char(c'A')).t, "char")
          arktest.assertEQ(new A(new Boolean(false)).t, "boolean")
          arktest.assertEQ(new A(new Float(3.14.toFloat())).t, "float")
          arktest.assertEQ(new A(new Double(3.14)).t, "double")
          arktest.assertEQ(new A(-1 as long).t, "long")
          arktest.assertEQ(new A(-1).t, "byte")
          arktest.assertEQ(new A(-1 as short).t, "short")
          arktest.assertEQ(new A(-1 as byte).t, "byte")
          arktest.assertEQ(new A(c'A').t, "char")
          arktest.assertEQ(new A(false).t, "boolean")
          arktest.assertEQ(new A(3.14).t, "double")
          arktest.assertEQ(new A(3.14.toFloat()).t, "float")

    - decl: |-
          // value types with sub/superclass
          class B {
              t: string = ""
              constructor(p: boolean) { this.t = "boolean" }
              constructor(p: byte) { this.t = "byte" }
              constructor(p: short) { this.t = "short" }
              constructor(p: int) { this.t = "int" }
              constructor(p: long) { this.t = "long" }
              constructor(p: char) { this.t = "char" }
              constructor(p: float) { this.t = "float" }
              constructor(p: double) { this.t = "double" }
              constructor(p: Any) { this.t = "Any" }
          }
          class A extends B {
              constructor(p: char) { super(p) }
              constructor(p: byte) { super(p) }
              constructor(p: short) { super(p) }
              constructor(p: int) { super(p) }
              constructor(p: long) { super(p) }
              constructor(p: float) { super(p) }
              constructor(p: double) { super(p) }
              constructor(p: boolean) { super(p) }
              constructor(p: Any) { super(p) }
          }
      use: |-
          arktest.assertEQ(new A(-1).t, "byte")
          arktest.assertEQ(new A(-1 as long).t, "long")
          arktest.assertEQ(new A(-1 as short).t, "short")
          arktest.assertEQ(new A(-1 as byte).t, "byte")
          arktest.assertEQ(new A(c'A').t, "char")
          arktest.assertEQ(new A(false).t, "boolean")
          arktest.assertEQ(new A(3.14).t, "double")
          arktest.assertEQ(new A(3.14f).t, "float")

    - decl: |-
          // enums
          enum Color { Red, Green = 82, Blue }
          enum Size { S = "small", M = "medium", L = "large" }
          class A {
              t: string = ""
              constructor(p: Color) { this.t = "Color" }
              constructor(p: short) { this.t = "short" }
              constructor(p: Size) { this.t = "Size" }
              constructor(p: string) { this.t = "string" }
              constructor(p: Any) { this.t = "Any" }
          }
      use: |-
          arktest.assertEQ(new A(-1).t, "short")
          arktest.assertEQ(new A(-2 as short).t, "short")
          arktest.assertEQ(new A(-3 as byte).t, "short")
          arktest.assertEQ(new A(-4 as int).t, "Any")
          arktest.assertEQ(new A(Color.Red).t, "Color")
          arktest.assertEQ(new A("small").t, "string")
          arktest.assertEQ(new A(Size.S).t, "Size")

    - decl: |-
          // arrays
          enum Color { Red, Green = 82, Blue }
          enum Size { S="small", M="medium", L="large" }
          class A {
              t: string = ""
              constructor() {}
              constructor(p: FixedArray<A>) { this.t = "A" }
              constructor(p: FixedArray<Color>) { this.t = "Color" }
              constructor(p: FixedArray<Size>) { this.t = "Size" }
              constructor(p: FixedArray<Boolean>) { this.t = "Boolean" }
              constructor(p: FixedArray<Byte>) { this.t = "Byte" }
              constructor(p: FixedArray<Short>) { this.t = "Short" }
              constructor(p: FixedArray<Int>) { this.t = "Int" }
              constructor(p: FixedArray<Long>) { this.t = "Long" }
              constructor(p: FixedArray<Float>) { this.t = "Float" }
              constructor(p: FixedArray<Double>) { this.t = "Double" }
              constructor(p: FixedArray<Char>) { this.t = "Char" }
              constructor(p: FixedArray<Object>) { this.t = "Object" }
              constructor(p: Object) { this.t = "should never be called" }
          }
      use: |-
          arktest.assertEQ(new A([(-1).toByte()]).t, "Byte")
          arktest.assertEQ(new A([(-1).toShort()]).t, "Short")
          arktest.assertEQ(new A([(-1).toInt()]).t, "Int")
          arktest.assertEQ(new A([(-1).toLong()]).t, "Long")
          arktest.assertEQ(new A([c'A']).t, "Char")
          arktest.assertEQ(new A([false]).t, "Boolean")
          arktest.assertEQ(new A([3.14f]).t, "Float")
          arktest.assertEQ(new A([3.14]).t, "Double")
          arktest.assertEQ(new A([new Byte((-1).toByte())]).t, "Byte")
          arktest.assertEQ(new A([new Short((-1).toShort())]).t, "Short")
          arktest.assertEQ(new A([new Int(-1)]).t, "Int")
          arktest.assertEQ(new A([new Long((-1).toLong())]).t, "Long")
          arktest.assertEQ(new A([new Char(c'A')]).t, "Char")
          arktest.assertEQ(new A([new Boolean(false)]).t, "Boolean")
          arktest.assertEQ(new A([new Float(3.14f)]).t, "Float")
          arktest.assertEQ(new A([new Double(3.14)]).t, "Double")
          arktest.assertEQ(new A([new Object()]).t, "Object")
          arktest.assertEQ(new A([Color.Red]).t, "Color")
          arktest.assertEQ(new A([Size.M]).t, "Size")
          arktest.assertEQ(new A(new A[1]).t, "A")

    - decl: |-
          // tuple and array
          type T = [number, number]
          type R = number[]
          class B {
              t: string = ""
              constructor() {}
              protected constructor(p: R) { this.t = "R" }
              protected constructor(p: T) { this.t = "T" }
          }
          class A extends B {
              constructor() { super() }
              constructor(p: R) { super(p) }
              constructor(p: T) { super(p) }
          }
          let t: T = [0.0, 0.0]
          let r: R = [0.0, 0.0]
      use: |-
          arktest.assertEQ(new A().t, "")
          arktest.assertEQ(new A(r).t, "R")
          arktest.assertEQ(new A(t).t, "T")

          // local variable, smart-casting case
          let v: T|R = [0.0]
          arktest.assertEQ(new A(v).t, "R")
          v = [0.0, 0.0, 0.0]
          arktest.assertEQ(new A(v).t, "R")

    - decl: |-
          // unions
          type USN = string | number
          type USB = string | boolean
          class A {
              t: string = ""
              getType(): string {
                  return this.t
              }
              constructor() {}
              constructor(p: string) { this.t = "string" }
              constructor(p: number) { this.t = "number" }
              constructor(p: boolean) { this.t = "boolean" }
              constructor(p: USN) { this.t = "USN" }
              constructor(p: USB) { this.t = "USB" }
              constructor(p: Object) { this.t = "should never be called" }
          }
          let usn: USN = "abc"
          let usb: USB = true
      use: |-
          arktest.assertEQ(new A(new Boolean(false)).t, "boolean")
          arktest.assertEQ(new A("").t, "string")
          arktest.assertEQ(new A(1.0).t, "number")
          usn = "abc"
          arktest.assertEQ(new A(usn).t, "USN")
          usn = 42.0
          arktest.assertEQ(new A(usn).t, "USN")
          usb = true
          arktest.assertEQ(new A(usb).t, "USB")
          usb = "xyz"
          arktest.assertEQ(new A(usb).t, "USB")

    - decl: |-
          // function types
          type F1=(p: number) => string
          type F2=(p: number, q: number) => string
          class A {
              t: string = ""
              constructor() {}
              constructor(p: () => void) { this.t = "void-void" }
              constructor(p: F1) { this.t = "F1" }
              constructor(p: F2) { this.t = "F2" }
              constructor(p: Object) { this.t = "should never be called" }
          }
          function fff2(v: number, w: number): string {
              return "" + v + w
          }
          function fff1(v: number): string {
              return "" + v
          }
          function foo() {
              arktest.assertTrue(false)
          }
          let f1: F1 = fff1
      use: |-
          arktest.assertEQ(new A(foo).t, "void-void")
          arktest.assertEQ(new A(fff1).t, "F1")
          arktest.assertEQ(new A(f1).t, "F1")
          arktest.assertEQ(new A(fff2).t, "F2")

    - decl: |-
          // nullish types
          type S=string
          type SN=string|null
          type SU=string|undefined
          type SNU=string|null|undefined
          class A {
              t: string = ""
              constructor() {}
              constructor(p: S) { this.t = "S" }
              constructor(p: SN) { this.t = "SN" }
              constructor(p: Any) { this.t = "Any" }
          }
          let s: S = ""
          let sn: SN = ""
          let su: SU = ""
          let snu: SNU = ""
      use: |-
          s = ""
          arktest.assertEQ(new A(s).t, "S")
          sn = ""
          arktest.assertEQ(new A(sn).t, "SN")
          sn = null
          arktest.assertEQ(new A(sn).t, "SN")
          su = ""
          arktest.assertEQ(new A(su).t, "Any")
          su = undefined
          arktest.assertEQ(new A(su).t, "Any")
          snu = ""
          arktest.assertEQ(new A(snu).t, "Any")
          snu = null
          arktest.assertEQ(new A(snu).t, "Any")
          snu = undefined
          arktest.assertEQ(new A(snu).t, "Any")

          // local variable, smart-casting
          let v: SNU = ""
          arktest.assertEQ(new A(v).t, "S")
          v = null
          arktest.assertEQ(new A(v).t, "SN")
          v = undefined
          arktest.assertEQ(new A(v).t, "Any")
