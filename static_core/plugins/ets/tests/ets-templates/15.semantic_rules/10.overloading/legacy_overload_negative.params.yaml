# Copyright (c) 2021-2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
  # functions
  - decl: |-
      // same sinature with parameters
      function foo(a: int): void {}
      function foo(a: int): void {}

  - decl: |-
      // explicit void return type
      function foo(): void {}
      function foo() {}

  - decl: |-
      // different return type
      function foo(): Object { return new Object(); }
      function foo(): void {}

  - decl: |-
      // optional parameter
      function foo(value: string): string { return value }
      function foo(value?: string): string { return value ? value : 'null' }

  - decl: |-
      // nullable parameter
      function foo(a: int): void {}
      function foo(a: int|null): void {}

  - decl: |-
      // type parameter and ref
      class C {}
      function foo<T>(i: T): void {}
      function foo(i: C): void {}

  - decl: |-
      // different type arguments
      function foo<T>(i: T): void {}
      function foo<V>(i: V): void {}

  - decl: |-
      // different lists of type arguments
      function foo<T>(): void {}
      function foo<V,U>(): void {}

  - decl: |-
      class X {}
      class Y {}
      class Z {}
      // naming formal parameters or type variables differently
      function foo<T extends X, U extends Y, V extends Z>(t: T, u: U, v: V): V { return v; }
      function foo<U extends X, V extends Y, T extends Z>(u: U, v: V, t: T): V { return v; }

  - decl: |-
      class X {}
      class Y {}
      class Z {}
      function foo<T extends X, U extends Y, V extends Z>(t: T, u: U, v: V): T { return t; }
      function foo<T extends X, U extends Y>(t: T, u: U, v: Object): T { return t; }
      function foo<T extends X>(t: T, u: Object, v: Object): T { return t; }
      function foo(t: Object, u: Object, v: Object): Object { return new Object(); }

  - decl: |-
      class Y {}
      // naming formal parameters or return types differently
      function foo<X extends Y>(a: int, b: long, c: double, d: X): X { return d; }
      function foo<Z extends Y>(q: int, r: long, v: double, w: Z): Z { return w; }

  - decl: |-
      class Z {}
      function foo<X extends Z>(a: int, b: long, c: double, d: X): X { return d; }
      function foo<X extends Z>(a: long, b: long, c: double, d: X): X { return d; }

  - decl: |-
      type T1 = int
      type T2 = long
      type T3 = double
      type T5 = Object

      // using type aliases
      function foo(a: int, b: long, c: double, d: Object): Object { return new Object(); }
      function foo(t1: T1, t2: T2, t3: T3, t5: T5): T5 { return new Object(); }

  - decl: |-
      // rest parameters
      function foo(a: int[]): void {}
      function foo(...a: int[]): void {}

  - decl: |-
      // array parameters
      function foo(a: FixedArray<Object>) {}
      function foo(a: FixedArray<FixedArray<Object>>) {}

  - decl: |-
      // enum parameters
      enum Color { Red, Green, Blue }
      enum Size { S, M, L, XL }
      function foo(a: Color): Color { return a; }
      function foo(a: Size): Size { return a; }

  # class methods
  - decl: |-
      // same sinature with parameters
      class A {
        met(a: int): void {}
        met(a: int): void {}
      }

  - decl: |-
      // different return type
      class A {
          public met(): int { return 1; }
          public met(): long { return 1 as long; }
      }

  - decl: |-
      // different access modifier
      class A {
          public met(a: Object) {}
          private met(b: Object) {}
      }

  - decl: |-
      // obtional parameter
      class A {
          met(value: string): string { return value }
          met(value?: string): string { return value ? value : 'null' }
      }

  - decl: |-
      // nullable parameter
      class A {
          met(value: string): string { return value }
          met(value: string|null): string { return value ? value : 'null' }
      }

  - decl: |-
      // type parameter and ref
      class C {}
      class A {
        met<T>(i: T): void {}
        met(i: C): void {}
      }

  - decl: |-
      // different type arguments
      class A {
        met<T>(i: T): void {}
        met<V>(i: V): void {}
      }

  - decl: |-
      // different lists of type arguments
      class A {
        met<T>(): void {}
        met<V,U>(): void {}
      }

  - decl: |-
      class X {}
      class Y {}
      // different return type variable
      class A<T extends X, U extends Y> {
          public met(a: T): T { return a; }
          public met(a: T): Y { return new Y(); }
      }

  - decl: |-
      // using type alias
      type T1 = int
      class A {
          public met(a: int): int { return a; }
          public met(b: T1): T1 { return b; }
      }

  - decl: |-
      // rest parameters
      class A {
          public met(a: int[]): void {}
          public met(...a: int[]): void {}
      }

  - decl: |-
      // array parameters
      class A {
          public met(a: FixedArray<Object>) {}
          public met(a: FixedArray<FixedArray<Object>>) {}
      }

  - decl: |-
      // enum parameters
      enum Color { Red, Green, Blue }
      enum Size { S, M, L, XL }
      class A {
          met(a: Color): Color { return a; }
          met(a: Size): Size { return a; }
      }

  # class constructors
  - decl: |-
      // different access modifiers
      class A {
          public constructor () {}
          private constructor () {}
      }

  - decl: |-
      // different access modifiers
      class A {
          public constructor (a: int) {}
          public constructor (a: int) {}
      }

  - decl: |-
      // rest parameters
      class A {
          public constructor (a: int[]) {}
          public constructor (...a: int[]) {}
      }

  - decl: |-
      // optional parameter
      class A {
          public constructor (value: string) { return value }
          public constructor (value?: string) { return value ? value : 'null' }
      }

  - decl: |-
      // nullable parameter
      class A {
          public constructor (value: string) { return value }
          public constructor (value: string|null) { return value ? value : 'null' }
      }

  - decl: |-
      // type parameter and ref
      class C {}
      class A {
        constructor<T>(i: T): void {}
        constructor(i: C): void {}
      }

  - decl: |-
      // different type arguments
      class A {
        constructor<T>(i: T): void {}
        constructor<V>(i: V): void {}
      }

  - decl: |-
      // different lists of type arguments
      class A {
        constructor<T>(): void {}
        constructor<V,U>(): void {}
      }

  - decl: |-
      class X {}
      class Y {}
      // different formal parameter names
      class A<T extends X, U extends Y> {
          public constructor (a: T, b: U) {}
          public constructor (c: T, d: U) {}
      }

  - decl: |-
      // using type alias
      type T1 = int[]
      class A {
          public constructor (a: int[]) {}
          public constructor (b: T1) {}
      }

  - decl: |-
      // array parameters
      class A {
          public constructor (a: FixedArray<Object>) {}
          public constructor (a: FixedArray<FixedArray<Object>>) {}
      }

  - decl: |-
      // enum parameters
      enum Color { Red, Green, Blue }
      enum Size { S, M, L, XL }
      class A {
          constructor(a: Color) {}
          constructor(a: Size) {}
      }
