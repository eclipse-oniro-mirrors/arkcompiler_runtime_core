# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    - descr: Simple overload
      decl: |-
        interface I1 {
          foo(v1: number, v2: string): number { return 1 }
        }
        interface I2 {
          foo(v1: string, v2: number): number { return 2 }
        }
        class C1 implements I1, I2 {
          foo(v1: number, v2: number): number { return 3 }
        }
      call: |-
        let c1 = new C1;
        arktest.assertEQ(c1.foo(1, 'str'), 1, 'foo1 call expected');
        arktest.assertEQ(c1.foo('str', 1), 2, 'foo2 call expected');
        arktest.assertEQ(c1.foo(1, 2), 3, 'foo3 call expected');

    - descr: Simple overload with override
      decl: |-
        interface I1 {
          foo(v1: number, v2: string): number { return 1 }
        }
        interface I2 {
          foo(v1: string, v2: number): number { return 2 }
        }
        class C1 implements I1, I2 {
          foo(v1: number, v2: string): number { return 3 } // overrides foo1
        }
      call: |-
        let c1 = new C1;
        arktest.assertEQ(c1.foo(1, 'str'), 3, 'foo3 call expected');
        arktest.assertEQ(c1.foo('str', 1), 2, 'foo2 call expected');

    - descr: Multiple overload
      decl: |-
        interface I1 {
          foo(): number { return 1 }
          foo(v1: string): string { return '2' }
        }
        interface I2 {
          foo(v1: string, v2: number): number { return 3 }
          foo(v1: string, v2: number, v3: string): string { return '4' }
          foo(v1: number, v2: string): number { return 5 }
        }
        class C1 implements I1, I2 {
          foo(v1: string, v2: number): number { return 6 } // overrides foo3
          foo(v1: number, v2: number): number { return 7 }
          foo(v1: string, v2: string): string { return '8' }
        }
      call: |-
        let c1 = new C1;
        arktest.assertEQ(c1.foo(), 1, 'foo1 call expected');
        arktest.assertEQ(c1.foo('str'), '2', 'foo2 call expected');
        arktest.assertEQ(c1.foo('str', 1), 6, 'foo6 call expected');
        arktest.assertEQ(c1.foo('str', 1, 'str'), '4', 'foo4 call expected');
        arktest.assertEQ(c1.foo(1, 'str'), 5, 'foo5 call expected');
        arktest.assertEQ(c1.foo(1, 2), 7, 'foo7 call expected');
        arktest.assertEQ(c1.foo('str1', 'str2'), '8', 'foo8 call expected');

    - descr: Simple overload with rest param
      decl: |-
        interface I1 {
          foo(v1: number): number { return 1 }
        }
        interface I2 {
          foo(v1: number, ...v2: number[]): number { return 2 }
          foo(v1: string): number { return 3 }
        }
        class C1 implements I1, I2 {
          foo(v1: string, ...v2: string[]): number { return 4 }
        }
      call: |-
        let c1 = new C1;
        arktest.assertEQ(c1.foo(1), 1, 'foo1 call expected');
        arktest.assertEQ(c1.foo(1, 2), 2, 'foo2 with rest param call expected');
        arktest.assertEQ(c1.foo('str'), 4, 'foo4 call expected');
        arktest.assertEQ(c1.foo('str1', 'str2'), 4, 'foo4 with rest param call expected');

    - descr: Simple overload of rest param
      decl: |-
        interface I1 {
          foo(v1: number, ...v2: number[]): number { return 1 }
        }
        interface I2 {
          foo(v1: number): number { return 2 }
        }
        class C1 implements I1, I2 {
          foo(v1: number): number { return 3 } // overrides foo2
        }
      call: |-
        let c1 = new C1;
        arktest.assertEQ(c1.foo(1), 3, 'foo3 call expected');
        arktest.assertEQ(c1.foo(1, 2), 1, 'foo1 with rest param call expected');

    - descr: Simple overload with optional param
      decl: |-
        interface I1 {
          foo(v1: number): number { return 1 }
        }
        interface I2 {
          foo(v1: number, v2: number = 2): number { return 2 }
        }
        class C1 implements I1, I2 {
          foo(v1: number, v2: number = 3, v3: number = 4): number { return 3 }
        }
      call: |-
        let c1 = new C1;
        arktest.assertEQ(c1.foo(1), 3, 'foo3 call expected');
        arktest.assertEQ(c1.foo(1, 2), 3, 'foo3 with optional param call expected');
        arktest.assertEQ(c1.foo(1, 2, 3), 3, 'foo3 with optional param call expected');

    - descr: Simple overload of optional param
      decl: |-
        interface I1 {
          foo(v1: number, v2: number = 3, v3: number = 4): number { return 1 }
        }
        interface I2 {
          foo(v1: number, v2: number = 5): number { return 2 }
        }
        class C1 implements I1, I2 {
          foo(v1: number): number { return 3 }
        }
      call: |-
        let c1 = new C1;
        arktest.assertEQ(c1.foo(1), 3, 'foo3 call expected');
        arktest.assertEQ(c1.foo(1, 2), 1, 'foo1 with optional param call expected');
        arktest.assertEQ(c1.foo(1, 2, 3), 1, 'foo1 with optional param call expected');

    - descr: Simple overload
      decl: |-
        class A1 {}
        class A2 extends A1 {}
        class A3 extends A2 {}
        interface I1 {
          foo(v: A1): string { return 'foo1' }
        }
        interface I2 {
          foo(v: A2): int { return 2 }
        }
        class C1 implements I1, I2 {
          foo(v: A3): int | string { return 3 }
        }
      call: |-
        let a1 = new A1;
        let a2 = new A2;
        let a3 = new A3;
        let c1 = new C1;
        arktest.assertEQ(c1.foo(a1), 'foo1', 'foo1 call expected');
        arktest.assertEQ(c1.foo(a2), 'foo1', 'foo1 call expected');
        arktest.assertEQ(c1.foo(a3), 3, 'foo3 call expected');

    - descr: Overload and override
      decl: |-
        class A1 {}
        class A2 extends A1 {}
        class A3 extends A2 {}
        interface I1 {
          foo(v: A1): string { return 'foo1' }
        }
        interface I2 {
          foo(v: A3): string { return 'foo2' }
        }
        class C1 implements I1, I2 {
          foo(v: A2): string { return 'foo3' } // override foo2
        }
      call: |-
        let a1 = new A1;
        let a2 = new A2;
        let a3 = new A3;
        let c1 = new C1;
        arktest.assertEQ(c1.foo(a1), 'foo1', 'foo1 call expected');
        arktest.assertEQ(c1.foo(a2), 'foo3', 'foo3 call expected');
        arktest.assertEQ(c1.foo(a3), 'foo3', 'foo3 call expected');

    - descr: Override and overload
      decl: |-
        class A1 {}
        class A2 extends A1 {}
        class A3 extends A2 {}
        interface I1 {
          foo(v: A3): string { return 'foo1' }
        }
        interface I2 {
          foo(v: A1): string { return 'foo2' }
        }
        class C1 implements I1, I2 {
          foo(v: A2): string { return 'foo3' } // override foo1
        }
      call: |-
        let a1 = new A1;
        let a2 = new A2;
        let a3 = new A3;
        let c1 = new C1;
        arktest.assertEQ(c1.foo(a1), 'foo2', 'foo2 call expected');
        arktest.assertEQ(c1.foo(a2), 'foo3', 'foo3 call expected');
        arktest.assertEQ(c1.foo(a3), 'foo3', 'foo3 call expected');
