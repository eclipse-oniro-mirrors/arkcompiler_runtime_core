# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    # generic class
    - decl: |-
          class A<T> {
              cast(p: Object): T {
                  return p as T
              }
          }

          let obj: Object = new Error('abc')
      use: |-
          let x = new A<Error>().cast(obj)
          arktest.assertTrue(x instanceof Error)
          arktest.assertEQ(x.message, 'abc')

    - decl: |-
          class A<T> {
              cast(p: Object): T {
                  return p as T
              }
          }
      use: |-
          let a = new A<Error>
          arktest.expectThrow(
              () => { a.cast('abc') },
              (e) => e instanceof ClassCastError
          )

    # generic method
    - decl: |-
          class A {
              cast<T>(p: Object): T {
                  return p as T
              }
          }

          let obj: Object = new Error('abc')
      use: |-
          let x = new A().cast<Error>(obj)
          arktest.assertTrue(x instanceof Error)
          arktest.assertEQ(x.message, 'abc')

    - decl: |-
          class A {
              cast<T>(p: Object): T {
                  return p as T
              }
          }
      use: |-
          let a = new A
          arktest.expectThrow(
              () => { a.cast<Error>('abc') },
              (e) => e instanceof ClassCastError
          )

    # Arrays
    - tags: no-warmup
      decl: |-
          let obj: Array<string> = ['a']
      use: |-
          let x = ((): Object => obj)() as Array<string>
          arktest.assertEQ(x[0], 'a')
          x[0] = 'b'
          arktest.assertEQ(x[0], 'b')

    - decl: |-
          let obj: Array<string> = ['a']
      use: |-
          let x = ((): Object => obj)() as Array<number>
          let num: number
          arktest.expectThrow(
              () => { num = x[0]  },
              (e) => e instanceof ClassCastError
          )

    - tags: no-warmup
      decl: |-
          let obj: Array<'a'|'b'> = ['a']
      use: |-
          let x = ((): Object => obj)() as Array<string>
          arktest.assertEQ(x[0], 'a')
          x[0] = 'c'
          arktest.assertEQ(x[0], 'c')


    - decl: |-
          let obj: Array<'a'|'b'> = ['a']
      use: |-
          let x = ((): Object => obj)() as Array<number>
          let num: number
          arktest.expectThrow(
              () => { num = x[0] },
              (e) => e instanceof ClassCastError
          )

    - tags: no-warmup
      decl: |-
          let obj: Array<string|boolean|null> = ['a', true, null]
      use: |-
          let x = ((): Object => obj)() as Array<string|boolean|null|number>
          arktest.assertEQ(x[0], 'a')
          arktest.assertEQ(x[1], true)
          arktest.assertEQ(x[2], null)
          x[2] = 1.0
          arktest.assertEQ(x[2], 1.0)

    # FixedArray
    - tags: no-warmup
      decl: |-
          let obj: FixedArray<string> = ['a']
      use: |-
          let x = ((): Object => obj)() as FixedArray<string>
          arktest.assertEQ(x[0], 'a')
          x[0] = 'b'
          arktest.assertEQ(x[0], 'b')

    - tags: no-warmup
      decl: |-
          let obj: FixedArray<'a'|'b'> = ['a']
      use: |-
          let x = ((): Object => obj)() as FixedArray<string>
          arktest.assertEQ(x[0], 'a')
          x[0] = 'c'
          arktest.assertEQ(x[0], 'c')

    - decl: |-
          let obj: FixedArray<string> = ['a']
      use: |-
          let fn: FixedArray<number>
          arktest.expectThrow(
              () => { fn = ((): Object => obj)() as FixedArray<number> },
              (e) => e instanceof ClassCastError
          )

    # union type
    - tags: no-warmup
      decl: |-
          let obj: Array<string>|Promise<number>|undefined = ['a']
      use: |-
          let v = ((): Any => obj)() as Array<'a'|'b'>
          arktest.assertEQ(v[0], 'a')
          v[0] = 'b'
          arktest.assertEQ(v[0], 'b')

    - decl: |-
          let obj: Array<string>|Promise<number>|undefined = ['a']
      use: |-
          let x = ((): Any => obj)() as Array<boolean>
          let bool: boolean
          arktest.expectThrow(
              () => { bool = x[0] },
              (e) => e instanceof ClassCastError
          )

    # tuples
    - tags: no-warmup
      decl: |-
          let obj: [Array<number>, Record<string, number>] = [[1.0], {'a': 2.0}]
      use: |-
          let x = ((): Any => obj)() as [Array<number>, Record<string, number>]
          arktest.assertEQ(x[0][0], 1.0)
          arktest.assertEQ(x[1]['a'], 2.0)
          x[0][0] += 1.0
          arktest.assertEQ(x[0][0], 2.0)
          x[1]['b'] = 3.0
          arktest.assertEQ(x[1]['b'], 3.0)

    - decl: |-
          let obj: [Array<number>, Record<string, number>] = [[1.0], {'a': 2.0}]
      use: |-
          let x = ((): Any => obj)() as [Array<string>, Record<string, number>]
          arktest.expectThrow(
              () => { x[0][0]! },
              (e) => e instanceof ClassCastError
          )

    - decl: |-
          class A<T, U> {
              fld: [T, U]
              constructor(p: T, q: U) {
                  this.fld = [p, q]
              }
              cast(p: Object) {
                  this.fld = p as [T, U]
              }
          }
          let obj: A<string, boolean> = new A<string, boolean>('a', true)
      use: |-
          let t: [string, boolean] = ['b', false]
          obj.cast(((): Object => t)())
          arktest.assertEQ(obj.fld[0], 'b')
          arktest.assertEQ(obj.fld[1], false)

    - decl: |-
          class A<T, U> {
              fld: [T, U]
              constructor(p: T, q: U) {
                  this.fld = [p, q]
              }
              cast(p: Object) {
                  this.fld = p as [T, U]
              }
          }
          let obj: A<string, boolean> = new A<string, boolean>('a', true)
      use: |-
          let t: [string, number] = ['b', 1.0]
          obj.cast(((): Object => t)())
          arktest.expectThrow(
              () => { obj.fld[1]! },
              (e) => e instanceof ClassCastError
          )

    # enums
    - decl: |-
          enum Color { Red, Green, Blue }
          let obj: Color = Color.Red
      use: |-
          let x = ((): Any => obj)() as Color
          arktest.assertEQ(x, Color.Red)

    - decl: |-
          enum Color { Red, Green, Blue }
          let obj: Color = Color.Red
      use: |-
          let x: int
          arktest.expectThrow(
              () => { x = ((): Any => obj)() as int },
              (e) => e instanceof ClassCastError
          )

    # string literals
    - decl: |-
          let obj: 'a'|'bb' = 'bb'
      use: |-
          let x = ((): Any => obj)() as string
          arktest.assertEQ(x, 'bb')
          x = 'c'
          arktest.assertEQ(x, 'c')

    - decl: |-
          let obj: 'a'|'bb' = 'bb'
      use: |-
          let x: int
          arktest.expectThrow(
              () => { x = ((): Any => obj)() as int },
              (e) => e instanceof ClassCastError
          )

    # functions
    - decl: |-
          type F1<T, U> = (p: T, q: U) => T

          function foo1<T, U>(p: T, q: U): T {
              return p
          }

          let obj: F1<string, number> = foo1<string, number>
      use: |-
          let x = ((): Any => obj)() as F1<string, number>
          arktest.assertEQ(x('a', 1.0), 'a')

    - decl: |-
          type F1<T, U> = (p: T, q: U) => T
          type F2<T, U> = (p: T, q: U) => U

          function foo1<T, U>(p: T, q: U): T {
              return p
          }

          let obj: F1<string, number> = foo1<string, number>
      use: |-
          let x = ((): Any => obj)() as F2<string, number>
          arktest.expectThrow(
              () => { x('a', 1.0) },
              (e) => e instanceof ClassCastError
          )

    # invariant type parameter
    - decl: |-
          class A<T> {
              fld: T
              constructor(p: T) {
                  this.fld = p
              }
          }
          class X {}
          class Y extends X {}

          let x = new X
          let obj: A<X>|A<Y>|A<A<X>>|A<A<Y>> = new A<X>(x)
      use: |-
          let v = ((): Object => obj)() as A<X>
          arktest.assertEQ(v.fld, x)

    - decl: |-
          class A<T> {
              fld: T
              constructor(p: T) {
                  this.fld = p
              }
          }
          class X {}
          class Y extends X {}

          let obj: A<X>|A<Y>|A<A<X>>|A<A<Y>> = new A<X>(new X)
      use: |-
          let v = ((): Object => obj)() as A<Y>
          arktest.expectThrow(
              () => { v.fld! },
              (e) => e instanceof ClassCastError
          )

    - decl: |-
          class A<T> {
              fld: T
              constructor(p: T) {
                  this.fld = p
              }
          }
          class X {}
          class Y {}

          let obj: A<X>|A<Y>|A<A<X>>|A<A<Y>> = new A<Y>(new Y)
      use: |-
          let v = ((): Object => obj)() as A<X>
          arktest.expectThrow(
              () => { v.fld! },
              (e) => e instanceof ClassCastError
          )

    # covariant type parameter
    - decl: |-
          class A<out T> {
              readonly fld: T
              constructor(p: T) {
                  this.fld = p
              }
          }
          class X {}
          class Y extends X {}

          let y = new Y
          let obj: A<X>|A<Y>|A<A<X>>|A<A<Y>> = new A<Y>(y)
      use: |-
          let v = ((): Object => obj)() as A<Y>
          arktest.assertEQ(v.fld, y)

    - decl: |-
          class A<out T> {
              readonly fld: T
              constructor(p: T) {
                  this.fld = p
              }
          }
          class X {}
          class Y extends X {}

          let y = new Y
          let obj: A<X>|A<Y>|A<A<X>>|A<A<Y>> = new A<Y>(y)
      use: |-
          let v = ((): Object => obj)() as A<X>
          arktest.assertEQ(v.fld, y)

    - decl: |-
          class A<out T> {
              readonly fld: T
              constructor(p: T) {
                  this.fld = p
              }
          }
          class X {}
          class Y extends X {}

          let obj: A<X>|A<Y>|A<A<X>>|A<A<Y>> = new A<X>(new X)
      use: |-
          let v = ((): Object => obj)() as A<Y>
          arktest.expectThrow(
              () => { v.fld! },
              (e) => e instanceof ClassCastError
          )

    # contravariant type parameter
    - decl: |-
          class A<in T> {
              meth(p: T) {
                  res = p
              }
          }
          class X {}
          class Y extends X {}

          let res: Any
          let x = new X
          let obj: A<X>|A<Y>|A<A<X>>|A<A<Y>> = new A<X>()
      use: |-
          let v = ((): Object => obj)() as A<X>
          v.meth(x)
          arktest.assertEQ(res, x)

    - decl: |-
          class A<in T> {
              meth(p: T) {
                  res = p
              }
          }
          class X {}
          class Y extends X {}

          let res: Any
          let y = new Y
          let obj: A<X>|A<Y>|A<A<X>>|A<A<Y>> = new A<X>()
      use: |-
          let v = ((): Object => obj)() as A<Y>
          v.meth(y)
          arktest.assertEQ(res, y)

    - decl: |-
          class A<in T> {
              meth(p: T) {
                  res = p
              }
          }
          class X {}
          class Y extends X {}

          let res: Any
          let x = new X
          let obj: A<X>|A<Y>|A<A<X>>|A<A<Y>> = new A<Y>()
      use: |-
          let v = ((): Object => obj)() as A<X>
          v.meth(x)
          arktest.assertEQ(res, x)
