# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

cases:
  # Fixed Array Subtyping
  - type1: 'FixedArray<"a"|"b"|"c">'
    value: '["a", "b", "c"]'
    type2: 'FixedArray<string>'
  
  - type1: 'FixedArray<B>'
    value: '[new B(), new B("John")]'
    type2: 'FixedArray<A>'
  
  - decl:  'class E<in T> {}'
    type1: 'FixedArray<E<A>>'
    value: '[new E<A>(), new E<A>()]'
    type2: 'FixedArray<E<B>>'
  
  - decl:  'class E<out T> {}'
    type1: 'FixedArray<E<B>>'
    value: '[new E<B>(), new E<B>()]'
    type2: 'FixedArray<E<A>>'

  # Union Type Subtyping
  - type1: 'string'
    value: '"hello"'
    type2: 'number | string'
  
  - type1: '"success" | "loading"'
    value: '"success"'
    type2: '"error" | "loading" | "success"'
  
  - type1: 'B'
    value: 'new B()'
    type2: 'A | B'
  
  - decl:  'class E<out T> {}'
    type1: 'E<B>'
    value: 'new E<B>()'
    type2: 'E<A>'

  - decl:  'class E<in T> {}'
    type1: 'E<A>'
    value: 'new E<A>()'
    type2: 'E<B>'

  # Literal Type subtyping
  - type1: '"hello"'
    value: '"hello"'
    type2: 'string'

  - decl:  'class E<out T> {}'
    type1: 'E<"hello">'
    value: 'new E<"hello">()'
    type2: 'E<string>'

  - decl:  'class E<in T> {}'
    type1: 'E<string>'
    value: 'new E<string>()'
    type2: 'E<"hello">'

  # Function Types
  - type1: '(p: A) => B'
    value: '(p: A): B => { return new B()}'
    type2: '(p: B) => A'

  - type1: '(p?: A) => B'
    value: '(p?: A): B => { return new B()}'
    type2: '(p?: B) => A'

  - type1: '(q: A) => B'
    value: '(q: A): B => { return new B()}'
    type2: '(q: B, p?: A) => A'
  
  - decl:  'class E<in T> {}'
    type1: '(p: E<B>) => E<A>'
    value: '(p: E<B>): E<A> => { return new E<A>()}'
    type2: '(p: E<A>) => E<B>'

  - decl:  'class E<out T> {}'
    type1: '(p: E<A>) => E<B>'
    value: '(p: E<A>): E<B> => { return new E<B>()}'
    type2: '(p: E<B>) => E<A>'

  # Object Type subtyping
  - type1: 'A'
    value: '{name: "Alice"}'
    type2: 'Object'

  - decl:  'class E<out T> {}'
    type1: 'E<B>'
    value: 'new E<B>()'
    type2: 'Object'

  - decl:  'class E<in T> {}'
    type1: 'E<A>'
    value: 'new E<A>()'
    type2: 'Object'

