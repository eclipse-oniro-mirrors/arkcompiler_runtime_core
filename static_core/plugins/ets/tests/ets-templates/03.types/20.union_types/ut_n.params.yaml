# Copyright (c) 2021-2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    # Examples from Specification

    - decl: |-
          type BadUnion4 = 1 | 2   // Compile-time error
      use: ''
      stdout: |-
        "Syntax error ESY0138: Invalid Type."

    - decl: |-
          type BadUnion5 = 1 | 2.0   // Compile-time error
      use: ''
      stdout: |-
        "Syntax error ESY0138: Invalid Type."

    - decl: |-
          type BadUnion6 = 1 | 1.0  // Compile-time error
      use: ''
      stdout: |-
        "Syntax error ESY0138: Invalid Type."

    # Circular references
    - decl: |-
          type UT = number | string | UT  // CTE: circular reference
      use: ''
      stdout: |-
        "Semantic error ESE0311: Circular type alias reference"

    - decl: |-
          type UT1 = number | string | UT2
          type UT2 = number | string | UT3
          type UT3 = number | string | UT1  // CTE: circular reference
      use: ''
      stdout: |-
        "Semantic error ESE0311: Circular type alias reference"

    # Union type arrays
    - decl: |-
          type UT1 = string | boolean
      use: |-
          let v: UT1[] = new UT1[2]  // CTE: must be nullable union type in arrays
      stdout: |-
        " Semantic error ESE0051: Cannot use array creation expression with non-constructable element type which is non-assignable from undefined."

    # Wrong literals in union
    - decl: |-
          type UT = string | 1 | boolean  // CTE: numeric literal not allowed
      use: ''
      stdout: |-
        "Syntax error ESY0138: Invalid Type."

    - decl: |-
          type UT = number | null | c'A'  // CTE: char literals not allowed
      use: ''
      stdout: |-
        "Syntax error ESY0138: Invalid Type."

    - decl: |-
          type UT = number | true | string  // CTE: boolean literals not allowed
      use: ''
      stdout: |-
        "Syntax error ESY0138: Invalid Type."

    - decl: |-
          enum Color { Red, Green, Blue }
          type UT = number | Color.Blue | "A"  // CTE: enum literals not allowed
      use: ''
      stdout: |-
        "Semantic error ESE0070: 'Blue' type does not exist."

    # Wrong type assignments
    - decl: |-
          type UT = string | boolean | null
      use: |-
          let v: UT = undefined  // CTE: wrong value
      stdout: |-
        "Semantic error ESE0318: Type 'undefined' cannot be assigned to type 'String|Boolean|null'"

    - decl: |-
          type UT = number | boolean | undefined
      use: |-
          let v: UT = null  // CTE: wrong value
      stdout: |-
        "Semantic error ESE0318: Type 'null' cannot be assigned to type 'Double|Boolean|undefined'"

    - decl: |-
          type UT = 'A' | 'B' | 'c'
      use: |-
          let v: UT = 'C'  // CTE: wrong literal
      stdout: |-
        "Semantic error ESE0318: Type '\"C\"' cannot be assigned to type '\"A\"|\"B\"|\"c\"'"

    - decl: |-
          type UT = string | number | null
      use: |-
          let v: UT = true  // CTE: wrong literal
      stdout: |-
        "Semantic error ESE0318: Type 'Boolean' cannot be assigned to type 'String|Double|null'"

    - decl: |-
          type AB = 'A' | 'B'
          type CD = 'C' | 'D'
          type ABCD = AB | CD | null | undefined
      use: |-
          let v: ABCD = ''  // CTE: wrong literal
      stdout: |-
        "Semantic error ESE0318: Type '\"\"' cannot be assigned to type 'null|undefined|\"A\"|\"B\"|\"C\"|\"D\"'"

    - decl: |-
          type UT = string | boolean | null
          function foo(): UT | undefined {
              return undefined
          }
      use: |-
          let v: UT = foo()  // CTE: wrong type
      stdout: |-
        "Semantic error ESE0318: Type 'undefined|String|Boolean|null' cannot be assigned to type 'String|Boolean|null'"

    - decl: |-
          type UT = '1' | '2' | number
          function foo(): string | number {
              return '1'
          }
      use: |-
          let v: UT = foo()  // CTE: wrong type
      stdout: |-
        "Semantic error ESE0318: Type 'String|Double' cannot be assigned to type '\"1\"|\"2\"|Double'"

    - decl: |-
          type UT = string | boolean
      use: |-
          let v: UT[] = ['hello', 42]  // CTE: wrong element type
      stdout: |-
        "Semantic error ESE0227: Array element at index 1 with type 'Int' is not compatible with the target array element type 'String|Boolean'"

    - decl: |-
          type UT = string[] | boolean
      use: |-
          let v: UT = [1, 2, 3]  // CTE: wrong elements type
      stdout: |-
        "Semantic error ESE0227: Array element at index 0 with type 'Int' is not compatible with the target array element type 'String'"

    - decl: |-
          type UT = Error[] | number[] | null
      use: |-
          let v: UT = [true, false, false]  // CTE: wrong elements type
      stdout: |-
        "Semantic error ESE0318: Type 'Array<Boolean>' cannot be assigned to type 'Array<Error>|Array<Double>|null'"

    - decl: |-
          type UT = string | number | undefined
          class C {
              a: UT
          }
      use: |-
          let c: C = new C()
          c.a = false  // CTE: wrong type
      stdout: |-
        "Semantic error ESE0318: Type 'Boolean' cannot be assigned to type 'String|Double|undefined'"

    - decl: |-
          class B {}
          class C {}
          type UT = B | C[]
      use: |-
          let v: UT = new B[0]  // CTE: wrong type
      stdout: |-
        "Semantic error ESE0318: Type 'Array<B>' cannot be assigned to type 'B|Array<C>'"

    - decl: |-
          type UT = number | string
          class C<T> {
              fld: T | undefined
          }
      use: |-
          let c: C<UT> = new C<UT>()
          c.fld = new Object()  // CTE: wrong type
      stdout: |-
        "Semantic error ESE0318: Type 'Object' cannot be assigned to type 'undefined|Double|String'"

    - decl: |-
          enum Color { Red, Green, Blue }
          enum Size { S, M, L, XL }
      use: |-
          let v: Color|string = Size.XL  // CTE: wrong type
      stdout: |-
        "Semantic error ESE0318: Type 'Size' cannot be assigned to type 'Color|String'"

    - decl: |-
          type F1 = () => number
          type F2 = (p: string) => string
      use: |-
          let v: F1|F2|number = (p: string): number => { return 0 }  // CTE: wrong type
      stdout: |-
        "Semantic error ESE0318: Type '((p1: String) => Double)' cannot be assigned to type '((() => Double))|(((p1: String) => String))|Double'"

    - decl: |-
          interface I {}
          interface J {}
      use: |-
          let v: I|J = new Object()  // CTE: wrong type
      stdout: |-
        "Semantic error ESE0318: Type 'Object' cannot be assigned to type 'I|J'"

    - decl: |-
          type UT = Record<number, string> | Record<string, number>
      use: |-
          let a: UT = { 1: 2 }  // CTE: wrong type
      stdout: |-
        "Semantic error ESE0061: Ambiguous reference to 'Record<Double,String>|Record<String,Double>'"

    - decl: |-
          type UT = [boolean, boolean, string] | boolean[]
      use: |-
          let v: UT = ['true', true, false]  // CTE: wrong type
      stdout: |-
        "Semantic error ESE0318: Type 'Array<String|Boolean>' cannot be assigned to type '[Boolean, Boolean, String]|Array<Boolean>'"

    # Wrong type arguments
    - decl: |-
          class A {}
          class B extends A {}
          class C extends A {}
          type UT = B | C

          function foo<T extends A|null>(p: T): string {
              return p instanceof B ? 'B' : 'C'
          }
      use: |-
          arktest.assertNE(foo<UT>(new Object()), 'C')  // CTE: wrong argument type
      stdout: |-
        "Semantic error ESE0127: No matching call signature for foo(Object)"

    - decl: |-
          function foo(p: boolean|int): string {
              return p instanceof Int ? 'I' : 'B'
          }
      use: |-
          arktest.assertNE(foo(42.5), 'B')  // CTE: wrong argument type
      stdout: |-
        "Semantic error ESE0127: No matching call signature for foo(Double)"

    # Wrong comparing
    - decl: |-
          type strs = "abc" | "def"
          let str: strs = "abc"
      use: |-
          arktest.assertTrue(str == "ghi")  // CTE: wrong comparing
      stdout: |-
        "Semantic error ESE0105: Operator '==' cannot be applied to types '\"abc\"|\"def\"' and '\"ghi\"'."

    - decl: |-
          type strs = "abc" | "def"
          let str: strs = "abc"
      use: |-
          arktest.assertTrue(str === "ghi")  // CTE: wrong comparing
      stdout: |-
        "Semantic error ESE0105: Operator '===' cannot be applied to types '\"abc\"|\"def\"' and '\"ghi\"'."
