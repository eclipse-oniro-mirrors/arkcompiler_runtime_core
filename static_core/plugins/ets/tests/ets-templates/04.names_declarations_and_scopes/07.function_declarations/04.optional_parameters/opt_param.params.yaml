# Copyright (c) 2021-2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    # optional with default value
    - decl: |-
          // primitive default
          function pair(x: number, y: number = 7.0): number {
              return x + y;
          }
      call: |-
          arktest.assertEQ(3.0, pair(1.0, 2.0))
          arktest.assertEQ(8.0, pair(1.0))

    - decl: |-
          // check primitive defaults
          function foo(a: byte = 1, b: short = 2, c: int = 3, d: long = 4, e: float = 5.0, f: double = 6.0, g: boolean = true, h: char = c'W') {
              arktest.assertEQ( a, 1 )
              arktest.assertEQ( b, 2 )
              arktest.assertEQ( c, 3 )
              arktest.assertEQ( d, 4 )
              arktest.assertEQ( e, 5.0 )
              arktest.assertEQ( f, 6.0 )
              arktest.assertTrue( g )
              arktest.assertEQ( h, c'W' )
          }
      call: foo()

    - decl: |-
          // omitting different arguments
          function foo(a: int = 1, b: int = 2, c: int = 3): int {
              return a + b + c
          }
      call: |-
          arktest.assertEQ( foo(11, 12, 13), 36 )
          arktest.assertEQ( foo(11), 16 )
          arktest.assertEQ( foo(), 6 )

    - decl: |-
          // expression as default value
          let z = 9, y = 8, x = 7
          function foo(a: int = z + y * x) {
              arktest.assertEQ( a, 65 )
          }
      call: foo()

    - decl: |-
          // expressions as default values
          let z: Object[] = [new Boolean(true)], y = "string", x: Object|null = null
          function foo(a: Object = z, b: string[] = [y], c: Object|null = x) {
              arktest.assertTrue( a === z )
              arktest.assertTrue( b.length == 1 && b[0] == "string" )
              arktest.assertTrue( c === null )
          }
      call: foo()

    - decl: |-
          // check that expression is not computed if argument is provided
          let counter = 0
          class A {
              fld: number

              constructor(p: number) {
                  counter++;
                  this.fld = p;
              }

              res(x: number): number {
                  return this.fld + x;
              }
          }

          function foo(a: number = new A(33.0).res(42.0)): number {
              return a;
          }
      call: |-
          arktest.assertEQ( foo(3.0), 3.0 )
          arktest.assertEQ( counter, 0 )

    - decl: |-
          // check that expression is computed if argument is not provided
          let counter = 0
          class A {
              fld: number

              constructor(p: number) {
                  counter++;
                  this.fld = p;
              }

              res(x: number): number {
                  return this.fld + x;
              }
          }

          function foo(a: number = new A(33.0).res(42.0)): number {
              return a;
          }
      call: |-
          arktest.assertEQ( foo(), 75.0 )
          arktest.assertTrue( counter > 0 )

    - decl: |-
          // IIFE as default value
          function foo(a: number = ((p: number): number => { return 2.0 * p })(42.0)): number {
              return a;
          }
      call: |-
          arktest.assertEQ( foo(33.0), 33.0 )
          arktest.assertEQ( foo(), 84.0 )

    # optional with null
    - decl: |-
          // expect NPE if argument omitted
          function foo(a: int, b?: Int): int {
              return a + b!
          }
      call: |-
          arktest.assertEQ( foo(1, 2), 3 )
          let expectedException = (e: Error): boolean => { return (e instanceof NullPointerError) }
          arktest.expectThrow(() => { foo(1) }, expectedException)

    - decl: |-
          type XYZ=number
          function foo(p?: XYZ) {}  // primitive with alias
      call: foo(1.55)

    - decl: |-
          // check type of argument with default
          function foo(a?: Object) {
              arktest.assertTrue( a instanceof Object|undefined )
          }
      call: |-
          foo(new Object())
          foo()

    - decl: |-
          // check type of argument with default
          function foo(a: Object|null = null) {
              arktest.assertTrue( a instanceof Object|null )
          }
      call: |-
          foo(new Object())
          foo(null)
          foo()

    - decl: |-
          // check that argument with undefined-default can be assigned a not undefined value
          type f = (p: number) => number[]
          function foo(a?: f) {
              arktest.assertTrue( a === undefined )
              a = (t: number): number[] => { return [t]; }
              let x = a!(42.0)
              arktest.assertTrue( x instanceof number[] && x[0] == 42.0 )
          }
      call: foo()

    - decl: |-
          // check that argument with undefined-default optional can be assigned an undefined value
          type f = (p: number) => number[]
          function foo(a?: f) {
              let x = a!(42.0)
              arktest.assertTrue( x instanceof number[] && x[0] == 42.0 )
              a = undefined
              arktest.assertTrue( a === undefined )
          }
      call: |-
          foo((t: number): number[] => { return [t]; })

    - decl: |-
          // check that argument with undefined-default optional can be assigned an undefined value
          function foo(s?: string) {
              arktest.assertEQ( s, 'abc' )
              s = undefined
              arktest.assertTrue( s === undefined )
          }
      call: foo('abc')

    - decl: |-
          // check nullable type with undefined-default optional
          function foo(s?: string|null): string|null|undefined {
              return s === null ? 'null' : s
          }
      call: |-
          arktest.assertEQ( foo(''), '' )
          arktest.assertEQ( foo('abc'), 'abc' )
          arktest.assertEQ( foo(), undefined )
          arktest.assertEQ( foo(null), 'null' )

    # mixed optionality
    - decl: |-
          function foo(a: string, b: string = 'an', c?: string, d: string = 'ing'): string {
              return a + b + (c === undefined ? 'undefined' : c) + d
          }
      call: |-
          arktest.assertEQ( foo(''), 'anundefineding' )
          arktest.assertEQ( foo('c', 'lean', ''), 'cleaning' )
          arktest.assertEQ( foo('ark', ' ', 'compile', 'r'), 'ark compiler' )
          // TODO: function call with empty placeholders for optional parameters are not supported yet
          //assertEQ( foo('underst', , 'd'), 'understanding' )

    - decl: |-
          function foo(p?: int): int {
              return p === undefined ? 0 : 2 * p;
          }
      call: |-
          arktest.assertEQ(0, foo())
          arktest.assertEQ(2, foo(1))

    - decl: |-
          function foo(i: int, j: int, k?: boolean): boolean {
              return !k;
          }
      call: |-
         arktest.assertTrue(foo(1, 2))
         arktest.assertFalse(foo(2, 1, true))

    - decl: |-
          function foo(e?: string): string | undefined {
              return e
          }
      call: |-
         arktest.assertEQ(undefined, foo())
         arktest.assertEQ('test', foo('test'))

    - decl: |-
          enum Color {Red, Green, Blue}
          function foo(c?: Color) {}
      call: foo(Color.Blue)

    - decl: |-
          enum Color {Red, Green, Blue}
          type XYZ=Color
          function foo(c?: XYZ) {}
      call: foo(Color.Blue)

    - decl: |-
        type OptL = () => int
        function test(i: int, ov: OptL = () => 0): int {
            return ov()
        }
      call: |-
        arktest.assertEQ(0, test(1))
        arktest.assertEQ(42, test(2, () => 42))

    - decl: |-
        interface DefaultMethodDecl {
          test(x: number, y: number = 7.0): number {
              return x + y;
          }
        }
        class OptionalMethodOwner implements DefaultMethodDecl {
        }
      call: |-
        const test = new OptionalMethodOwner
        arktest.assertEQ(3.0, test.test(1.0, 2.0))
        arktest.assertEQ(8.0, test.test(1.0))

    - decl: |-
        class OptionalMethodOwner {
          test(x: number, y: number = 7.0): number {
              return x + y;
          }
        }
      call: |-
        const test = new OptionalMethodOwner
        arktest.assertEQ(3.0, test.test(1.0, 2.0))
        arktest.assertEQ(8.0, test.test(1.0))

    - decl: |-
        class OptionalStaticMethodOwner {
          static test(x: number, y: number = 7.0): number {
              return x + y;
          }
        }

      call: |-
        arktest.assertEQ(3.0, OptionalStaticMethodOwner.test(1.0, 2.0))
        arktest.assertEQ(8.0, OptionalStaticMethodOwner.test(1.0))

    - decl: |-
        type OptL = () => int
        class OptionalMethodOwner {
          test(i: int, ov: OptL = () => 0): int {
              return ov()
          }
        }

      call: |-
        const test = new OptionalMethodOwner
        arktest.assertEQ(0, test.test(1))
        arktest.assertEQ(42, test.test(2, () => 42))

    - decl: |-
        type OptL = () => int
        class OptionalMethodOwner {
          static test(i: int, ov: OptL = () => 0): int {
              return ov()
          }
        }

      call: |-
        arktest.assertEQ(0, OptionalMethodOwner.test(1))
        arktest.assertEQ(42, OptionalMethodOwner.test(2, () => 42))

    - decl: |-
        type OptL = (input?: int) => int
      call: |-
        let lc: OptL = (input: int = 42) => input
        arktest.assertEQ(12, lc(12))
        arktest.assertEQ(42, lc())

    - decl: |-
        type OptL = (input?: int) => int
      call: |-
        let lc: (input?: int) => int = (input: int = 42) => input
        arktest.assertEQ(12, lc(12))
        arktest.assertEQ(42, lc())

    - decl: |-
        type OptL = (input?: int) => int
      call: |-
          let lc: (input: int | undefined) => int = (input: int = 42) => input
          arktest.assertEQ(12, lc(12))
          arktest.assertEQ(42, lc())

    - decl: |-
        function foo(a?: number, ...rest: string[]): boolean {
          return a === undefined && rest.length === 0
        }
      call: |-
        arktest.assertTrue(foo())

    - decl: |-
        function foo(a?: number, ...rest: readonly string[]): boolean {
          return a === undefined && rest.length === 0
        }
      call: |-
        arktest.assertTrue(foo())

    - decl: |-
        function foo(a?: number, ...rest: Array<String>): boolean {
          return a === undefined && rest.length === 0
        }
      call: |-
        arktest.assertTrue(foo())

    - decl: |-
        function foo(a?: number, ...rest: Array<String>): boolean {
          return a === undefined && rest.length === 0
        }
      call: |-
        const call: (...rest: Array<string>) => boolean = foo
        arktest.assertTrue(call())


    - decl: |-
        class AFoo {
          static foo(a?: number, ...rest: string[]): boolean {
            return a === undefined && rest.length === 0
          }
        }
      call: |-
        arktest.assertTrue(AFoo.foo())

    - decl: |-
      call: |-
        let res = ((a?: number, ...rest:  string[]): boolean => { return true })()
        arktest.assertTrue(res)

    - decl: |-
        function foo(a: int[] = [1], b: string[] = ['1']): string {
            return '' + a[0] + b[0]
        }
      call: |-
        arktest.assertEQ(foo([5], ['6']), '56')
        arktest.assertEQ(foo([5]), '51')
        arktest.assertEQ(foo(), '11')
        arktest.assertEQ(foo([5], undefined), '51')
        arktest.assertEQ(foo(undefined, ['6']), '16')
        arktest.assertEQ(foo(undefined, undefined), '11')
