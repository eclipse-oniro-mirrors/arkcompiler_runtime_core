/**
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
export declare let p1: CP1;
export declare function foo1(a: CP2): CP3;
export declare let p5: CP4 | CP5;
export declare function foo5(a: CP6 | CP7): CP8 | CP9;
export declare let p6: IP1;
export declare function foo6(a: IP2): IP3;
export declare let p8: NN1.C1;
export declare let p9: Promise<CP10>;
export declare let p10: Promise<IP5>;
export declare let p3: E5;
export declare function foo3(a: E6): E7;
export declare let p12: Promise<E8>;
declare interface I0 {
    I0Method(a: string): string;
}
declare interface I1 {
    I1Method(a: number): number;
}
declare class Base {
    public get a(): number;
    public set a(value: number);
    public constructor(a: number);
}
export declare class Derived extends Base implements I0, I1 {
    public I0Method(a: string): string;
    public I1Method(a: number): number;
    public get b(): number;
    public set b(value: number);
    public constructor(a: number, b: number);
}
export declare class C1 {
    public get a(): CC1;
    public set a(value: CC1);
    public foo(a: CC2): CC3;
    constructor();
}
export declare interface I2 {
    a: CI1;
    foo(a: CI2): CI3;
}
export declare class C4<T extends CC4> {
    constructor();
}
export declare class C5 extends CC5 implements IP4 {
    constructor();
}
declare class CC1 {
    constructor();
}
declare class CC2 {
    constructor();
}
declare class CC3 {
    constructor();
}
declare class CC4 {
    constructor();
}
declare class CC5 {
    constructor();
}
declare class CP1 {
    constructor();
}
declare class CP2 {
    constructor();
}
declare class CP3 {
    constructor();
}
declare class CP4 {
    constructor();
}
declare class CP5 {
    constructor();
}
declare class CP6 {
    constructor();
}
declare class CP7 {
    constructor();
}
declare class CP8 {
    constructor();
}
declare class CP9 {
    constructor();
}
declare class CP10 {
    constructor();
}
declare class CI1 {
    constructor();
}
declare class CI2 {
    constructor();
}
declare class CI3 {
    constructor();
}
declare interface IP1 {
}
declare interface IP2 {
}
declare interface IP3 {
}
declare interface IP4 {
}
declare interface IP5 {
}
declare class Want {
    constructor();
}
export type ValueType = number | string | boolean | image.PixelMap | Want | ArrayBuffer | object | null | undefined;
declare enum E5 {
    A = 0,
}
declare enum E6 {
    A = 0,
}
declare enum E7 {
    A = 0,
}
declare enum E8 {
    A = 0,
}
type BaseType = string;
type SubType<T> = BaseType | ((item: T, index: number) => void);
type PropertyType<T> = SubType<T> | ((item: T, index: number) => string);
type InterfacePropertyType = string;
type InterfaceFunctionParamType = number;
type InterfaceFunctionReturnType = boolean;
declare interface InterfacePropertyInterface {
}
declare interface InterfaceFunctionParamInterface {
}
declare interface InterfaceFunctionReturnInterface {
}
declare class InterfacePropertyClass {
    constructor();
}
declare class InterfaceFunctionParamClass {
    constructor();
}
declare class InterfaceFunctionReturnClass {
    constructor();
}
declare interface BaseInterface {
}
declare interface SubInterface extends BaseInterface {
}
declare interface PropertyInterface extends SubInterface {
    t: InterfacePropertyType;
    i: InterfacePropertyInterface;
    c: InterfacePropertyClass;
    fti(p: InterfaceFunctionParamType): InterfaceFunctionReturnInterface;
    fic(p: InterfaceFunctionParamInterface): InterfaceFunctionReturnClass;
    fct(p: InterfaceFunctionParamClass): InterfaceFunctionReturnType;
}
declare class PropertyInterfaceImplementation implements PropertyInterface {
    public fti(p: InterfaceFunctionParamType): InterfaceFunctionReturnInterface;
    public fic(p: InterfaceFunctionParamInterface): InterfaceFunctionReturnClass;
    public fct(p: InterfaceFunctionParamClass): InterfaceFunctionReturnType;
    constructor();
    public get t(): InterfacePropertyType;
    public set t(value: InterfacePropertyType);
    public get i(): InterfacePropertyInterface;
    public set i(value: InterfacePropertyInterface);
    public get c(): InterfacePropertyClass;
    public set c(value: InterfacePropertyClass);
}
type ClassPropertyType = string;
type ClassFunctionParamType = number;
type ClassFunctionReturnType = boolean;
declare interface ClassPropertyInteface {
}
declare interface ClassFunctionParamInterface {
}
declare interface ClassFunctionReturnInterface {
}
declare class ClassPropertyClass {
    constructor();
}
declare class ClassFunctionParamClass {
    constructor();
}
declare class ClassFunctionReturnClass {
    constructor();
}
declare interface ImplementedByBase1 {
}
declare interface ImplementedByBase2 {
}
declare interface ImplementedBySub {
}
declare interface ImplementedByProperty {
}
declare class BaseClass implements ImplementedByBase1, ImplementedByBase2 {
    constructor();
}
declare class SubClass extends BaseClass implements ImplementedBySub {
    constructor();
}
declare class PropertyClass extends SubClass implements ImplementedByProperty {
    public get t(): ClassPropertyType;
    public set t(value: ClassPropertyType);
    public get i(): ClassPropertyInteface;
    public set i(value: ClassPropertyInteface);
    public get c(): ClassPropertyClass;
    public set c(value: ClassPropertyClass);
    public fti(p: ClassFunctionParamType): ClassFunctionReturnInterface;
    public fic(p: ClassFunctionParamInterface): ClassFunctionReturnClass;
    public fct(p: ClassFunctionParamClass): ClassFunctionReturnType;
    constructor();
}
export declare class ExportedClass {
    public get t(): PropertyType<boolean>;
    public set t(value: PropertyType<boolean>);
    public get i(): PropertyInterface;
    public set i(value: PropertyInterface);
    public get c(): PropertyClass;
    public set c(value: PropertyClass);
    constructor();
}
declare namespace NN1 {
    class C1 {
        constructor();
    }
}
declare namespace image {
    interface PixelMap {
    }
}
