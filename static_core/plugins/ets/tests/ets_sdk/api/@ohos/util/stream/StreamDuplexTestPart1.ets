/*
 * Copyright (C) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the 'License')
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { BusinessError } from "@ohos.base";
import { stream } from "@ohos.util.stream";

const mustChecks: Array<Function> = new Array<Function>();
function main(): int {
    const suite = new arktest.ArkTestsuite("Stream API tests")

    suite.addTest("Duplex finish event should not be triggered", testDuplexFinishEventNotTriggered);
    suite.addTest("Duplex writableFinished state validation", testDuplexWritableFinishedState);
    suite.addTest("Duplex basic read and write functionality", testDuplexBasicReadWrite);
    suite.addTest("Duplex read with valid size", testDuplexReadWithValidSize);
    suite.addTest("Duplex error handling during write", testDuplexErrorHandlingOnWrite);
    suite.addTest("Duplex read and write with synchronous data", testDuplexReadWriteWithSyncData);

    return suite.run();
}

async function mustCallCheckAll() {
    return new Promise<void>((resolve, reject) => {
        setTimeout(() => {
            try {
                mustChecks.forEach(check => {
                    check.unsafeCall();
                });
                mustChecks.length = 0;
                resolve(undefined);
            } catch (e: Error) {
                reject(e)
            }
        }, 2000)
    })
}

function mustCallObjectArray(fn?: Function, times: number = 1) {
    let callCount = 0;
    let wrappedFn: Function = (...args: Object[]): void => {
        callCount++;
        fn?.unsafeCall(args);
    }

    mustChecks.push(() => {
        if (callCount !== times) {
            throw new Error(`Function was expected to be called ${times} times, but was called ${callCount} times.`);
        }
    });
    return wrappedFn;
}

function mustCallArgSize(fn?: Function, times: number = 1) {
    let callCount = 0;
    let wrappedFn = (size: number) => {
        callCount++;
        fn?.unsafeCall(size);
    }
    mustChecks.push(() => {
        if (callCount !== times) {
            throw new Error(`Function was expected to be called ${times} times, but was called ${callCount} times.`);
        }
    });
    return wrappedFn;
}

function mustCall(fn?: Function, times: number = 1) {
    let callCount = 0;
    let wrappedFn: Function = (err: Error | undefined | null): void => {
        callCount++;
        fn?.unsafeCall(err);
    }

    mustChecks.push((): void => {
        if (callCount !== times) {
            throw new Error(`Function was expected to be called ${times} times, but was called ${callCount} times. `);
        }
    });
    return wrappedFn;
}

function mustCallNoArgs(fn?: Function, times: number = 1) {
    let callCount = 0;
    let wrappedFn: Function = (): void => {
        callCount++;
        fn?.unsafeCall();
    }

    mustChecks.push((): void => {
        if (callCount !== times) {
            throw new Error(`Function was expected to be called ${times} times, but was called ${callCount} times. `);
        }
    });
    return wrappedFn;
}

// Test cases ported from ArkTS 1.0:testStreamDuplexEnd001
function testDuplexFinishEventNotTriggered() {
    let finishCalled = false;
    class MyDuplex extends stream.Duplex {
        constructor() {
            super();
        }
        doRead(size: number) {
        }
    }
    let duplex = new MyDuplex();
    duplex.on('finish', () => {
        finishCalled = true;
    })
    duplex.resume();
    duplex.push(null);
    arktest.assertFalse(finishCalled);
}

// Test cases ported from ArkTS 1.0:testStreamDuplexWritableFinished002
function testDuplexWritableFinishedState() {
    class MyDuplex extends stream.Duplex {
        constructor() {
            super();
        }
        doWrite(chunk: string | Uint8Array, encoding: string, callback: Function) {
            arktest.assertFalse(this.writableFinished, "writableFinished should be false");
            callback.unsafeCall();
        }
    }
    let duplex = new MyDuplex();
    let func: Function =  mustCallNoArgs((): void => {
        arktest.assertTrue(duplex.writableFinished, "writableFinished should be true");
    })
    duplex.on('finish', func);
    duplex.end('testing finished state', 'utf8', mustCall((err: Error | undefined | null): void => {
        arktest.assertTrue(duplex.writableFinished, "writableFinished should be true");
    }));
    arktest.expectNoThrow(() => { await mustCallCheckAll(); });
}

// Test cases ported from ArkTS 1.0:testStreamDuplex001
function testDuplexBasicReadWrite() {
    let written: string | Uint8Array;
    let read: Object;
    class MyDuplex extends stream.Duplex {
        constructor() {
            super();
        }
        doRead(size: number) {
        }
        doWrite(chunk: string | Uint8Array, encoding: string, callback: Function): void {
            written = chunk;
            callback.unsafeCall();
        }
    }
    let duplex = new MyDuplex();
    arktest.assertTrue(duplex instanceof stream.Duplex, "duplex instanceof Duplex should be true");
    duplex.on('data', (...param: Object[]): void => {
        if (param.length > 0 && param[0] instanceof Object) {
            read = param[0];
        }
    });
    duplex.push('read');
    duplex.end('written');
    setTimeout(() => {
        arktest.assertEQ(read.toString(), 'read');
        arktest.assertEQ(written, 'written');
    }, 0);
}

// Test cases ported from ArkTS 1.0:testStreamDuplex002
function testDuplexReadWithValidSize() {
    class MyDuplex extends stream.Duplex {
        constructor() {
            super();
        }
        doRead(size: number) {
            let fn = (size: number) => {
                arktest.assertEQ(size, 16384);
                this.push('duplex test');
                this.push(null);
            }
            let wrappedFn = mustCallArgSize(fn);
            wrappedFn(size);
        }
        doWrite(chunk: string | Uint8Array, encoding: string, callback: Function): void {
            callback.unsafeCall();
        }
    }
    let duplex = new MyDuplex();
    duplex.write('duplex test', 'utf8', mustCallObjectArray((...param: Object[]): void => {
        if (param.length > 0 && param[0] instanceof Error) {
            const err = param[0] as Error;
            arktest.assertEQ(err, null);
        }
    }));
    duplex.on('data', mustCallObjectArray((...param: Object[]): void => {
        if (param.length > 0 && param[0] instanceof string) {
            const chunk = param[0] as string;
            arktest.assertEQ(chunk.toString(), 'duplex test');
        }
    }));
    arktest.expectNoThrow(() => { await mustCallCheckAll(); });
}

// Test cases ported from ArkTS 1.0:testStreamDuplex003
function testDuplexErrorHandlingOnWrite() {
    class MyDuplex extends stream.Duplex {
        constructor() {
            super();
        }
        doWrite(chunk: string | Uint8Array, encoding: string, callback: Function): void {
            callback.unsafeCall(new Error('Write error'));
        }
    }
    let duplex = new MyDuplex();
    let func: Function = (err: Error) => {
        arktest.assertEQ(err.message, "Write error", "err.message is valid");
        arktest.assertFalse(duplex.writable, "writable should be false");

    }
    duplex.on('error', mustCall(func));
    duplex.write('test');
    arktest.expectNoThrow(() => { await mustCallCheckAll(); });
}

// Test cases ported from ArkTS 1.0:testStreamDuplex004
function testDuplexReadWriteWithSyncData() {
    class MyDuplex extends stream.Duplex {
        constructor() {
            super();
        }
        doWrite(chunk: string | Uint8Array, encoding: string, callback: Function): void {
            setTimeout(() => {
                callback.unsafeCall();
            }, 20);
        }
        doRead(size: number) {
            this.push('Sync data');
            this.push(null);
        }
    }
    let duplex = new MyDuplex();
    duplex.on('data', (...chunk: Object[]): void => {
        if (chunk.length > 0 && chunk[0] instanceof string) {
            arktest.assertEQ(chunk[0].toString(), "Sync data");
        }
    });
    duplex.write('Test data');
}
