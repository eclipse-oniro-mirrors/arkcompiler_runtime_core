/**
 * Copyright (c) 2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const success: number = 0;
const fail: number = 1;

function main(): int {
  let failures: number = 0;

  failures += check(testBytePerElement(),"test BytePerElement for {{.item.objectType}}");
  failures += check(createDefault(),"Create default empty {{.item.objectType}}");
  failures += check(createEmptyWithLength(),"Create default empty {{.item.objectType}} from length");
  failures += check(createNonEmptyWithLength(),"Create default non empty {{.item.objectType}} from length");
  failures += check(createtypedArrayWithWrongLength(),"Create default non empty {{.item.objectType}} with wrong length");
  failures += check(createEmptyWithIterable(),"Create default empty {{.item.objectType}} from Iterable");
  failures += check(createNonEmptyWithIterable(),"Create default non empty {{.item.objectType}} from Iterable");
  failures += check(testTypedArrayIterator(),"test {{.item.objectType}} Iterator");
  
  failures += check(createtypedArrayWithArrayLike(),"Create {{.item.objectType}} with ArrayLike");
  
  failures += check(createTAFromEmptyArrayBuffer(),"Create default empty {{.item.objectType}} from empty source");
  failures += check(createTAFromEmptyArrayBufferOneParamNoOffset(),"Create default empty {{.item.objectType}} from empty source one param");
  failures += check(createTAFromEmptyArrayBufferOneOffsetWithWrongNumber(),"Create default empty {{.item.objectType}} from empty source one param");
  failures += check(createTAFromEmptyArrayBufferTwoParams(),"Create default empty {{.item.objectType}} from empty source two params");
  failures += check(createTAFromEmptyArrayBufferTwoParamsWithWrongNumber(),"Create default empty {{.item.objectType}} from empty source two params with wrong number");
  
  failures += check(createTAFromNonEmptyArrayBuffer(),"Create default empty {{.item.objectType}} from non empty source");
  failures += check(createTAFromNonEmptyArrayBufferOneParamNoOffset(),"Create default empty {{.item.objectType}} from non empty source one param");
  failures += check(createTAFromNonEmptyArrayBufferOneOffsetWithWrongNumber(),"Create default empty {{.item.objectType}} from non empty source one param with wrong number");
  failures += check(createTAFromNonEmptyArrayBufferTwoParams(),"Create default empty {{.item.objectType}} from non empty source two params");
  failures += check(createTAFromNonEmptyArrayBufferTwoParamsWithWrongNumber(),"Create default empty {{.item.objectType}} from non empty source two params with wrong number");
  
  failures += check(createTAFromNonEmptyArrayBufferOneParamWithOffset(),"Create default empty {{.item.objectType}} from non empty source with offset");
  failures += check(createTAFromNonEmptyArrayBufferOneParamWithOffsetAndSize(),"Create default empty {{.item.objectType}} from non empty source with offset and size");

  failures += check(createTAFromEmptySharedArrayBuffer(),"Create default empty {{.item.objectType}} from empty source");
  failures += check(createTAFromNonEmptySharedArrayBuffer(),"Create default empty {{.item.objectType}} from non empty source");
  failures += check(createTAFromNonEmptySharedArrayBufferOneParamWithOffset(),"Create default empty {{.item.objectType}} from non empty source with offset");
  failures += check(createTAFromNonEmptySharedArrayBufferOneParamWithOffsetAndSize(),"Create default empty {{.item.objectType}} from non empty source with offset and size");

  failures += check(testSliceWithOutParam(), "Try to Array slice() function");
  failures += check(testSliceOneParam(), "Try to Array slice(1) function");
  failures += check(testSliceTwoParams(), "Try to Array slice(2) function");
  failures += check(testSliceTwoParamsWithOtherNumber(), "Try to Array slice(2) With Other Number function");
  failures += check(testSliceOneLengthTwoParams(), "Try to Array slice(2) One Length Two Params function");

  failures += check(testSubarrayWithOutParam(), "Try to Array subarray() function");
  failures += check(testSubarrayOneParam(), "Try to Array subarray(1) function");
  failures += check(testSubarrayTwoParams(), "Try to Array subarray(2) function");
  failures += check(testSubarrayTwoParamsWithOtherNumber(), "Try to Array subarray(2) With Other Number function");
  failures += check(testSubarrayOneLengthTwoParams(), "Try to Array subarray(2) One Length Two Params function");

  failures += check(testEmptyTypedArrayToString(), "Try to Empty Array toString");
  failures += check(testNonEmptyTypedArrayToString(), "Try to Nonempty Array toString");

  failures += check(testEmptyTypedArrayAt(), "Test to Empty Array at");
  failures += check(testNonEmptyTypedArrayAt(), "Test to Nonempty Array at");

  failures += check(testNonEmptyTypedArraySetValue(), "Test Set Value to Nonempty Array");
  
  failures += check(testNonEmptyTypedArrayReverse(), "Test NonEmpty Array Reverse");
  failures += check(testEmptyTypedArrayReverse(), "Test Empty Array Reverse");

  failures += check(testTypedArrayIncludesOneParamWithNormalNum(), "Test Includes One Param With NormalNum");
  failures += check(testTypedArrayIncludesOneParamWithAbnormalNum(), "Test Includes One Param With AbnormalNum");
  failures += check(testTypedArrayIncludesTwoParamWithNormalIndex(), "Test Includes Two Param With Normal Index");
  failures += check(testTypedArrayIncludesTwoParamWithAbnormalIndex(), "Test Includes Two Param With Abnormal Index");

  failures += check(testTypedArrayJoinWithEmptyArray(), "Test Join With EmptyArray");
  failures += check(testTypedArrayJoinWithNonEmptyArray(), "Test Join With NonEmptyArray");
  failures += check(testTypedArrayJoinWithNonEmptyArrayAndAbnormalStr(), "Test Join With NonEmptyArray And AbnormalStr");
  failures += check(testTypedArrayKeysWithEmptyArray(), "Test Keys With EmptyArray");
  failures += check(testTypedArrayKeysWithSingleElementArray(), "Test Keys With SingleElement");
  failures += check(testTypedArrayKeysWithMultipleElementArray(), "Test Keys With MultipleElementArray");

  failures += check(testTypedArrayForEach(), "Try to apply a function to each element of the TypedArray using TypedArray.forEach() function");
  failures += check(testTypedArrayForEachValueIndexCallback(), "Test case for forEach(callbackFn: (value: number, index: number) => void)");
  failures += check(testTypedArrayForEachValueCallback(), "Test case for forEach(callbackFn: (value: number) => void)");
  failures += check(testTypedArrayForEachNoArgsCallback(), "Test case for forEach(callbackFn: () => void)");
  failures += check(testTypedArrayEntries(), "Test TypedArray Entries");


  if (failures > 0){
    console.log("failed");
    return fail;
  }

  console.log("All passed");
  return success;
}

function check(result: int, message: String): number {
  if (result == 0) {
    return success;
  }
  console.log("\nFAILED: " + message);
  return fail;
}

function check(result: number, message: String): number {
  if (result == 0) {
    return success;
  }
  console.log("\nFAILED: " + message);
  return fail;
}

const source: {{.item.primitiveType}}[] = {{.item.data}};
const abnormalSource: {{.item.primitiveType}}[] = {{.item.abnormalData}};

function testBytePerElement(): number {
  if ({{.item.objectType}}.BYTES_PER_ELEMENT as int == {{.item.primitiveSizeBytes}}) return success;
  return fail;
}

function createDefault(): number {
  let target: {{.item.objectType}} = new {{.item.objectType}}();
  if (target.length as int == 0 && target.byteOffset as int == 0) return success;
  return fail;
}

function createEmptyWithLength(): number {
  let target: {{.item.objectType}} = new {{.item.objectType}}(0);
  if (target.length as int == 0 && target.byteOffset as int == 0) return success;
  return fail;
}

function createNonEmptyWithLength(): number {
  let target: {{.item.objectType}} = new {{.item.objectType}}(5);
  if (target.length as int == 5 && target.byteOffset as int == 0 && target.byteLength as int == 5*{{.item.primitiveSizeBytes}}){
    return success;
  }
  return fail;
}

function createtypedArrayWithWrongLength(): number {
  try {
    let target: {{.item.objectType}} = new {{.item.objectType}}(-1 as number);
  } catch(e) {
    return success;
  }
  return fail;
}

function createEmptyWithIterable(): number {
  let array: Array<Number> = new Array<Number>();
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(array.values() as Iterable<Number>);
  } catch(e) {
    return fail;
  }

  for (let value of target) {
    console.log(value); 
    return fail;
  }

  if (target.length as int == 0){
    return success;
  }
  return fail;
}

function createNonEmptyWithIterable(): number {
  let array: Array<Number> = new Array<Number>();
  array.push(1);
  array.push(2);
  array.push(3);
  let target: {{.item.objectType}} = new {{.item.objectType}}(array.values() as Iterable<Number>);

  if (target.length as int == 3 && target.byteOffset as int == 0 && target.byteLength as int == 3*{{.item.primitiveSizeBytes}}){
    return success;
  }

  let exceptArray: Array<Number> = new Array<Number>();
  for (let value of target) {
    exceptArray.push(value);
    console.log(value); 
  }
  
  let origin: {{.item.objectType}} = new {{.item.objectType}}(exceptArray.values() as Iterable<Number>);
  for (let i: int = 0; i< target.length as int; i++) {
    let tv = target[i] as number;
    let ov = origin[i] as number;
    console.log(tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }
  return fail;
}

function testTypedArrayIterator(): number {
  let ss = new ArrayBuffer(5 * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let length = typedArray.length;

  try {
    typedArray[0] = 1 as number;
    typedArray[1] = 2 as number;
    typedArray[2] = 3 as number;
    typedArray[3] = 4 as number;
    typedArray[4] = 5 as number;
  } catch(e) {
    console.log(e);
    return fail;
  }

  let arrayIterator = typedArray.$_iterator();
  let next = arrayIterator.next();
  let counter: int = 0;
  while (!next.done) {
    if (next.value == undefined) {
        return fail;
    }
    if (typedArray[counter] as number != (next.value) as number) {  
        return fail;
    }
    next = arrayIterator.next()
    counter++
  }

  if (counter != typedArray.length) { 
    return fail;
  }

  return success;
}


function createtypedArrayWithArrayLike(): number {
  let array = new Array<Number>();
  array.push(1 as Number);
  array.push(2 as Number);
  array.push(3 as Number);
  
  let target: {{.item.objectType}} = new {{.item.objectType}} (array as ArrayLike<Number> );
  if (target.length as int == 3 && target.byteOffset as int == 0){
    return success;
  }
  return fail;
}


function createTAFromEmptyArrayBuffer(): number {
  let ss = new ArrayBuffer(0);  // Buffer 0-bytes length;
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss);
  } catch(e) {
    return fail;
  }

  if (target.length as int == 0 && target.byteOffset as int == 0) return success;
  return fail;
}

function createTAFromNonEmptyArrayBuffer(): number {
  let ss = new ArrayBuffer(5*{{.item.primitiveSizeBytes}});  // Buffer 5-items length;
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss);
  } catch(e) {
    return fail;
  }

  if (target.byteLength as int == 5*{{.item.primitiveSizeBytes}} && target.byteOffset as int == 0) return success;
  console.println("Error: Actual bytes length: " + target.byteLength);
  return fail;
}

function createTAFromEmptySharedArrayBuffer(): number {
  let ss = new SharedArrayBuffer(0);  // Buffer 0-bytes length;
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss);
  } catch(e) {
    return fail;
  }

  if (target.length as int == 0 && target.byteOffset as int == 0) return success;
  return fail;
}

function createTAFromNonEmptySharedArrayBuffer(): number {
  let ss = new SharedArrayBuffer(5*{{.item.primitiveSizeBytes}} as int);  // Buffer 5-items length;
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss);
  } catch(e) {
    return fail;
  }

  if (target.byteLength as int == 5*{{.item.primitiveSizeBytes}} && target.byteOffset as int == 0) return success;
  console.println("Error: Actual bytes length: " + target.byteLength);
  return fail;
}



function createTAFromEmptyArrayBufferOneParamNoOffset(): number {
  let ss = new ArrayBuffer(0);
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss, 0);
  } catch(e) {
    return fail;
  }
  if (target.length as number != 0 || target.byteOffset as number != 0 ) {
    return fail;
  }

  try {
    target = new {{.item.objectType}}(ss, undefined);
  } catch(e) {
    return fail;
  }

  if (target.length as number != 0 || target.byteOffset as number != 0) {
    return fail;
  }
  
  return success;
}

function createTAFromEmptyArrayBufferOneOffsetWithWrongNumber(): number {
  let ss = new ArrayBuffer(0);
  let target: {{.item.objectType}};
  let result: number = success;

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, -1);
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, 1);
  } catch(e) {
    result = success;
  }  

  return result;
}


function createTAFromNonEmptyArrayBufferOneParamNoOffset(): number {
  let ss = new ArrayBuffer(5*{{.item.primitiveSizeBytes}});  // Buffer 5-items length;
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss, 0);
  } catch(e) {
    return fail;
  }

  if (target.byteLength as number != 5*{{.item.primitiveSizeBytes}} || target.byteOffset as number != 0 
    || target.length as number != 5){
    console.println("Error: Actual bytes length: " + target.byteLength);
    return fail;
  }

  try {
    target = new {{.item.objectType}}(ss, undefined);
  } catch(e) {
    return fail;
  }

  if (target.byteLength as number != 5*{{.item.primitiveSizeBytes}} || target.byteOffset as number != 0 
    || target.length as number != 5){
    console.println("Error: Actual bytes length: " + target.byteLength);
    return fail;
  }
  
  return success;
}

function createTAFromNonEmptyArrayBufferOneOffsetWithWrongNumber(): number {
  let ss = new ArrayBuffer(5*{{.item.primitiveSizeBytes}});  // Buffer 5-items length;
  let target: {{.item.objectType}};
  let result: number = success;
  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, -1);
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, 6*{{.item.primitiveSizeBytes}});
  } catch(e) {
    result = success;
  }

  return result;
}

function createTAFromNonEmptyArrayBufferOneParamWithOffset(): number {
  let ss = new ArrayBuffer(7*{{.item.primitiveSizeBytes}});  // Buffer 7-items length;
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss, 2*{{.item.primitiveSizeBytes}});
  } catch(e) {
    console.println(e);
    return fail;
  }

  if (target.byteLength as int == 5*{{.item.primitiveSizeBytes}} && target.byteOffset as int == 2*{{.item.primitiveSizeBytes}} 
    && target.length as int == 5){
    return success;
  }
  console.println("Error: Actual bytes length: " + target.byteLength);
  console.println("Error: Actual bytes offset: " + target.byteOffset);
  console.println("Error: Actual length: " + target.length);
  return fail;
}

function createTAFromNonEmptyArrayBufferOneParamWithOffsetAndSize(): number {
  let ss = new ArrayBuffer(7*{{.item.primitiveSizeBytes}});  // Buffer 7-items length;
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss, 2*{{.item.primitiveSizeBytes}}, 4);
  } catch(e) {
    console.println(e);
    return fail;
  }

  if (target.byteLength as int == 4*{{.item.primitiveSizeBytes}} && target.byteOffset as int == 2*{{.item.primitiveSizeBytes}} && target.length as int == 4) return success;
  console.println("Error: Actual bytes length: " + target.byteLength);
  console.println("Error: Actual bytes offset: " + target.byteOffset);
  console.println("Error: length: " + target.length);
  return fail;
}

function createTAFromNonEmptySharedArrayBufferOneParamWithOffset(): number {
  let ss = new SharedArrayBuffer(7*{{.item.primitiveSizeBytes}} as int);  // Buffer 7-items length;
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss, 2*{{.item.primitiveSizeBytes}});
  } catch(e) {
    console.println(e);
    return fail;
  }

  if (target.byteLength as int == 5*{{.item.primitiveSizeBytes}} && target.byteOffset as int == 2*{{.item.primitiveSizeBytes}} 
    && target.length as int == 5){
    return success;
  }
  console.println("withSharedArrayBuffer1 Error: Actual bytes length: " + target.byteLength);
  console.println("withSharedArrayBuffer1 Error: Actual bytes offset: " + target.byteOffset);
  console.println("withSharedArrayBuffer1 Error: Actual length: " + target.length);
  return fail;
}

function createTAFromNonEmptySharedArrayBufferOneParamWithOffsetAndSize(): number {
  let ss = new SharedArrayBuffer(7*{{.item.primitiveSizeBytes}} as int);  // Buffer 7-items length;
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss, 2*{{.item.primitiveSizeBytes}}, 4);
  } catch(e) {
    console.println(e);
    return fail;
  }

  if (target.byteLength as int == 4*{{.item.primitiveSizeBytes}} && target.byteOffset as int == 2*{{.item.primitiveSizeBytes}} && target.length as int == 4) return success;
  console.println("withSharedArrayBuffer2 Error: Actual bytes length: " + target.byteLength);
  console.println("withSharedArrayBuffer2 Error: Actual bytes offset: " + target.byteOffset);
  console.println("withSharedArrayBuffer2 Error: length: " + target.length);
  return fail;
}


function createTAFromEmptyArrayBufferTwoParams(): number {
  let ss = new ArrayBuffer(0);
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss, 0, 0);
  } catch(e) {
    return fail;
  }

  if (target.length as number != 0 || target.byteOffset as number != 0) {
    return fail;
  }

  try {
    target = new {{.item.objectType}}(ss, undefined, undefined);
  } catch(e) {
    return fail;
  }

  if (target.length as number != 0 || target.byteOffset as number != 0) {
    return fail;
  }

  return success;
}

function createTAFromNonEmptyArrayBufferTwoParams(): number {
  let ss = new ArrayBuffer(5 * {{.item.primitiveSizeBytes}});  // Buffer 5-items length;
  let target: {{.item.objectType}};
  try {
    target = new {{.item.objectType}}(ss, 0, 5);
  } catch(e) {
    return fail;
  }

  if (target.byteLength as int == 5*{{.item.primitiveSizeBytes}} && target.byteOffset as int == 0 && target.length == 5){
    return success;
  }
  console.println("Error: Actual bytes length: " + target.byteLength);
  return fail;
}

function createTAFromEmptyArrayBufferTwoParamsWithWrongNumber(): number {
  let ss = new ArrayBuffer(0);  // Buffer 5-items length;
  let target: {{.item.objectType}};
  let result: number = success;
  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, new Number(-1), undefined);
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, new Number(2), undefined);
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, -1, -1);
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, -2, 66);
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, 2, 5);
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, 2, 66);
  } catch(e) {
    result = success;
  }

  return result;
}

function createTAFromNonEmptyArrayBufferTwoParamsWithWrongNumber(): number {
  let ss = new ArrayBuffer(5 * {{.item.primitiveSizeBytes}});  // Buffer 5-items length;
  let target: {{.item.objectType}};
  let result: number = success;

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, new Number(-1), undefined);
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, -2, 66);
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, -1, -1);
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, -1, 6 * {{.item.primitiveSizeBytes}});
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, 2, 6 * {{.item.primitiveSizeBytes}});
  } catch(e) {
    result = success;
  }

  try {
    result = fail; 
    target = new {{.item.objectType}}(ss, undefined, new Number(-1));
  } catch(e) {
    result = success;
  }

  return result;
}


function testSliceWithOutParam(): int {
  //let source: {{.item.primitiveType}}[] = [10, 20, 30, 40, 50, 60];
  let ss = new ArrayBuffer(source.length as int * {{.item.primitiveSizeBytes}});

  let origin: {{.item.objectType}};

  try {
    origin = new {{.item.objectType}}(ss);
    origin.set(source);
  } catch(e) {
    console.log(e);
    return fail;
  }


  let target: {{.item.objectType}};

  try {
    target = origin.slice();
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != origin.length as int) {
    console.log("Array length mismatch on slice");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = 0; i< origin.length as int; i++) {
    let tv = target[i] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  origin= new {{.item.objectType}}(0);
  if (origin.length as int != 0){
    return fail;
  }

  try {
    target = origin.slice();
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != 0){
    return fail;
  }
  return success;
}

function testSliceOneParam(): int {
  //let source: {{.item.primitiveType}}[] = [10, 20, 30, 40, 50, 60];
  let ss = new ArrayBuffer(source.length as int * {{.item.primitiveSizeBytes}});

  let origin: {{.item.objectType}};

  try {
    origin = new {{.item.objectType}}(ss);
    origin.set(source);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let sliceStart: int = 1;
  let sliceEnd: int = origin.length as int;

  let target: {{.item.objectType}};

  try {
    target = origin.slice(sliceStart);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != origin.length as int - sliceStart) {
    console.log("Array length mismatch on slice One Params" + target.length);
    return fail;
  }

  //Check all the data copied;
  for (let i: int = sliceStart; i< sliceEnd; i++) {
    let tv = target[i - sliceStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  sliceStart = 0;
  try {
    target = origin.slice(undefined);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != origin.length as int) {
    console.log("Array length mismatch on slice One Params" + target.length);
    return fail;
  }

  //Check all the data copied;
  for (let i: int = sliceStart; i< sliceEnd; i++) {
    let tv = target[i - sliceStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  return success;
}

function testSliceTwoParams(): int {
  //let source: {{.item.primitiveType}}[] = [10, 20, 30, 40, 50, 60, 70, 80];
  let ss = new ArrayBuffer(source.length as int * {{.item.primitiveSizeBytes}});

  let origin: {{.item.objectType}};

  try {
    origin = new {{.item.objectType}}(ss);
    origin.set(source);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let sliceStart: int = 2;
  let sliceEnd: int = 4;

  let target: {{.item.objectType}};

  try {
    target = origin.slice(sliceStart, sliceEnd);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != sliceEnd - sliceStart) {
    console.log("Array length mismatch on slice2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = sliceStart; i< sliceEnd; i++) {
    let tv = target[i - sliceStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  sliceStart = 0;
  sliceEnd = origin.length as int;
  try {
    target = origin.slice(sliceStart, sliceEnd);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != sliceEnd - sliceStart) {
    console.log("Array length mismatch on slice2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = sliceStart; i< sliceEnd; i++) {
    let tv = target[i - sliceStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  try {
    target = origin.slice(new Number(sliceStart), undefined);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != sliceEnd - sliceStart) {
    console.log("Array length mismatch on slice2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = sliceStart; i< sliceEnd; i++) {
    let tv = target[i - sliceStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  try {
    target = origin.slice(undefined, undefined);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != sliceEnd - sliceStart) {
    console.log("Array length mismatch on slice2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = sliceStart; i< sliceEnd; i++) {
    let tv = target[i - sliceStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  try {
    target = origin.slice(undefined, new Number(sliceEnd));
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != sliceEnd - sliceStart) {
    console.log("Array length mismatch on slice2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = sliceStart; i< sliceEnd; i++) {
    let tv = target[i - sliceStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  try {
    target = origin.slice(0, 0);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != 0) {
    console.log("Array length mismatch on slice2");
    return fail;
  }

  return success;
}

function testSliceTwoParamsWithOtherNumber(): int {
  //let source: {{.item.primitiveType}}[] = [10, 20, 30, 40, 50, 60, 70, 80];
  let ss = new ArrayBuffer(source.length as int * {{.item.primitiveSizeBytes}});

  let origin: {{.item.objectType}};

  try {
    origin = new {{.item.objectType}}(ss);
    origin.set(source);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let sliceStart: int = 4;
  let sliceEnd: int = 2;

  let target: {{.item.objectType}};

  try {
    target = origin.slice(sliceStart, sliceEnd);
  } catch(e) {
    return fail;
  }

  if (target.length as int != 0) {
    console.log("Array length mismatch on slice2");
    return fail;
  }

  sliceStart = -1;
  sliceEnd = origin.length as int;
  try {
    target = origin.slice(sliceStart, sliceEnd);
  } catch(e) {
    return fail;
  }

  if (target.length as int != sliceEnd - (origin.length + sliceStart)) {
    console.log("Array length mismatch on slice2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = (origin.length + sliceStart) as int; i< sliceEnd; i++) {
    let tv = target[(i - (origin.length + sliceStart)) as int] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  sliceStart = 0;
  sliceEnd = -origin.length as int;
  try {
    target = origin.slice(sliceStart, sliceEnd);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != (origin.length + sliceEnd) - sliceStart) {
    console.log("Array length mismatch on slice2");
    return fail;
  }

  return success;
}

function testSliceOneLengthTwoParams(): int {
  let source1: {{.item.primitiveType}}[] = [10];
  let ss = new ArrayBuffer(source1.length as int * {{.item.primitiveSizeBytes}});

  let origin: {{.item.objectType}};

  try {
    origin = new {{.item.objectType}}(ss);
    origin.set(source1);
  } catch(e) {
    console.log(e);
    return fail;
  }
  
  let sliceStart: int = 4;
  let sliceEnd: int = 2;

  let target: {{.item.objectType}};

  try {
    target = origin.slice(sliceStart, sliceEnd);
  } catch(e) {
    return fail;
  }

  if (target.length as int != 0) {
    console.log("Array length mismatch on slice2");
    return fail;
  }

  sliceStart = 2;
  sliceEnd = 4;
  try {
    target = origin.slice(sliceStart, sliceEnd);
  } catch(e) {
    return fail;
  }

  if (target.length as int != 0) {
    console.log("Array length mismatch on slice2");
    return fail;
  }

  return success;
}


function testSubarrayWithOutParam(): int {
  //let source: {{.item.primitiveType}}[] = [10, 20, 30, 40, 50, 60];
  let ss = new ArrayBuffer(source.length as int * {{.item.primitiveSizeBytes}});

  let origin: {{.item.objectType}};

  try {
    origin = new {{.item.objectType}}(ss);
    origin.set(source);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let target: {{.item.objectType}};

  try {
    target = origin.subarray();
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != origin.length as int) {
    console.log("Array length mismatch on slice");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = 0; i< origin.length as int; i++) {
    let tv = target[i] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  origin= new {{.item.objectType}}(0);
  if (origin.length as int != 0){
    return fail;
  }

  try {
    target = origin.subarray();
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != 0){
    return fail;
  }
  return success;
}

function testSubarrayOneParam(): int {
  //let source: {{.item.primitiveType}}[] = [10, 20, 30, 40, 50, 60];
  let ss = new ArrayBuffer(source.length as int * {{.item.primitiveSizeBytes}});

  let origin: {{.item.objectType}};

  try {
    origin = new {{.item.objectType}}(ss);
    origin.set(source);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let subarrayStart: int = 1;
  let subarrayEnd: int = origin.length as int;

  let target: {{.item.objectType}};

  try {
    target = origin.subarray(subarrayStart);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != origin.length as int - subarrayStart) {
    console.log("Array length mismatch on subarray One Params" + target.length);
    return fail;
  }

  //Check all the data copied;
  for (let i: int = subarrayStart; i< subarrayEnd; i++) {
    let tv = target[i - subarrayStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  subarrayStart = 0;
  try {
    target = origin.subarray(undefined);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != origin.length as int) {
    console.log("Array length mismatch on subarray One Params" + target.length);
    return fail;
  }

  //Check all the data copied;
  for (let i: int = subarrayStart; i< subarrayEnd; i++) {
    let tv = target[i - subarrayStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  //The subarray method returns a view of the original array, so modifications made to the subarray will affect the original array, and vice versa.
  /*TypedArrays will support it later
  target[subarrayStart] = 1;
  for (let i: int = subarrayStart; i< subarrayEnd; i++) {
    let tv = target[i - subarrayStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  origin[subarrayStart] = 2;
  for (let i: int = subarrayStart; i< subarrayEnd; i++) {
    let tv = target[i - subarrayStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }*/

  return success;
}

function testSubarrayTwoParams(): int {
  //let source: {{.item.primitiveType}}[] = [10, 20, 30, 40, 50, 60, 70, 80];
  let ss = new ArrayBuffer(source.length as int * {{.item.primitiveSizeBytes}});

  let origin: {{.item.objectType}};

  try {
    origin = new {{.item.objectType}}(ss);
    origin.set(source);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let subarrayStart: int = 2;
  let subarrayEnd: int = 4;

  let target: {{.item.objectType}};

  try {
    target = origin.subarray(subarrayStart, subarrayEnd);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != subarrayEnd - subarrayStart) {
    console.log("Array length mismatch on subarray2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = subarrayStart; i< subarrayEnd; i++) {
    let tv = target[i - subarrayStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  subarrayStart = 0;
  subarrayEnd = origin.length as int;
  try {
    target = origin.subarray(subarrayStart, subarrayEnd);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != subarrayEnd - subarrayStart) {
    console.log("Array length mismatch on subarray2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = subarrayStart; i< subarrayEnd; i++) {
    let tv = target[i - subarrayStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  try {
    target = origin.subarray(new Number(subarrayStart), undefined);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != subarrayEnd - subarrayStart) {
    console.log("Array length mismatch on subarray2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = subarrayStart; i< subarrayEnd; i++) {
    let tv = target[i - subarrayStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  try {
    target = origin.subarray(undefined, undefined);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != subarrayEnd - subarrayStart) {
    console.log("Array length mismatch on subarray2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = subarrayStart; i< subarrayEnd; i++) {
    let tv = target[i - subarrayStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  try {
    target = origin.subarray(undefined, new Number(subarrayEnd));
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != subarrayEnd - subarrayStart) {
    console.log("Array length mismatch on subarray2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = subarrayStart; i< subarrayEnd; i++) {
    let tv = target[i - subarrayStart] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  try {
    target = origin.subarray(0, 0);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != 0) {
    console.log("Array length mismatch on subarray2");
    return fail;
  }

  return success;
}

function testSubarrayTwoParamsWithOtherNumber(): int {
  //let source: {{.item.primitiveType}}[] = [10, 20, 30, 40, 50, 60, 70, 80];
  let ss = new ArrayBuffer(source.length as int * {{.item.primitiveSizeBytes}});

  let origin: {{.item.objectType}};

  try {
    origin = new {{.item.objectType}}(ss);
    origin.set(source);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let subarrayStart: int = 4;
  let subarrayEnd: int = 2;

  let target: {{.item.objectType}};

  try {
    target = origin.subarray(subarrayStart, subarrayEnd);
  } catch(e) {
    return fail;
  }

  if (target.length as int != 0) {
    console.log("Array length mismatch on subarray2");
    return fail;
  }

  subarrayStart = -1;
  subarrayEnd = origin.length as int;
  try {
    target = origin.subarray(subarrayStart, subarrayEnd);
  } catch(e) {
    return fail;
  }

  if (target.length as int != subarrayEnd - (origin.length + subarrayStart)) {
    console.log("Array length mismatch on subarray2");
    return fail;
  }

  //Check all the data copied;
  for (let i: int = (origin.length + subarrayStart) as int; i< subarrayEnd; i++) {
    let tv = target[(i - (origin.length + subarrayStart)) as int] as {{.item.primitiveType}};
    let ov = origin[i] as {{.item.primitiveType}};
    console.log(source[i] + "->" + tv + "->" + ov);
    if (tv != ov) {
      console.log("Array data mismatch");
      return fail;
    }
  }

  subarrayStart = 0;
  subarrayEnd = -origin.length as int;
  try {
    target = origin.subarray(subarrayStart, subarrayEnd);
  } catch(e) {
    console.log(e);
    return fail;
  }

  if (target.length as int != (origin.length + subarrayEnd) - subarrayStart) {
    console.log("Array length mismatch on subarray2");
    return fail;
  }

  return success;
}

function testSubarrayOneLengthTwoParams(): int {
  let source1: {{.item.primitiveType}}[] = [10];
  let ss = new ArrayBuffer(source1.length as int * {{.item.primitiveSizeBytes}});

  let origin: {{.item.objectType}};

  try {
    origin = new {{.item.objectType}}(ss);
    origin.set(source1);
  } catch(e) {
    console.log(e);
    return fail;
  }
  
  let subarrayStart: int = 4;
  let subarrayEnd: int = 2;

  let target: {{.item.objectType}};

  try {
    target = origin.subarray(subarrayStart, subarrayEnd);
  } catch(e) {
    return fail;
  }

  if (target.length as int != 0) {
    console.log("Array length mismatch on subarray2");
    return fail;
  }

  subarrayStart = 2;
  subarrayEnd = 4;
  try {
    target = origin.subarray(subarrayStart, subarrayEnd);
  } catch(e) {
    return fail;
  }

  if (target.length as int != 0) {
    console.log("Array length mismatch on subarray2");
    return fail;
  }

  return success;
}


function testNonEmptyTypedArrayToString(): number {
  let source1: number[] = [1, 2, 3, 4, 5];
  let ss = new ArrayBuffer(source1.length * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
    typedArray.set(source1);
  } catch(e) {
    console.log(e);
    return fail;
  }

  const toStringResult = typedArray.toString();
  console.log("toString result: " + toStringResult);
  // Assertion
  if (toStringResult == "1,2,3,4,5") {
    console.log("toString test passed.");
    return success;
  } else {
    console.log("testNonEmptyTypedArrayToString test failed.");
    return fail;
  }
}

function testEmptyTypedArrayToString(): number {
  let ss = new ArrayBuffer(0); 
  let typedArray: {{.item.objectType}};
  try {
    typedArray = new {{.item.objectType}}(ss);
  } catch(e) {
    console.log(e);
    return fail;
  }

  const toStringResult = typedArray.toString();
  console.log("toString result: " + toStringResult);
  // Assertion
  if (toStringResult == "") {
    console.log("testEmptyTypedArrayToString test passed.");
    return success;
  } else {
    console.log("toString test failed.");
    return fail;
  }
}


function testNonEmptyTypedArrayAt(): number {
  //let source: number[] = [1, 2, 3, 4, 5];
  let ss = new ArrayBuffer(source.length * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
    typedArray.set(source);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let index = 0;
  let length = typedArray.length;
  let atResult = typedArray.at(index);
  console.log("testNonEmptyTypedArrayAt result: " + atResult);
  // Assertion
  if (atResult == new Number(source[index])) {
    console.log("testNonEmptyTypedArrayAt test passed.");
  } else {
    console.log("testNonEmptyTypedArrayAt test failed.");
    return fail;
  }

  index = -1;
  atResult = typedArray.at(index);
  console.log("testNonEmptyTypedArrayAt result: " + atResult);
  // Assertion
  if (atResult == new Number(source[index + length as int])) {
    console.log("testNonEmptyTypedArrayAt test passed.");
  } else {
    console.log("testNonEmptyTypedArrayAt test failed.");
    return fail;
  }

  index = typedArray.length as int;
  atResult = typedArray.at(index);
  console.log("testNonEmptyTypedArrayAt result: " + atResult);
  // Assertion
  if (atResult == undefined) {
    console.log("testNonEmptyTypedArrayAt test passed.");
  } else {
    console.log("testNonEmptyTypedArrayAt test failed.");
    return fail;
  }
  return success;
}

function testEmptyTypedArrayAt(): number {
  let ss = new ArrayBuffer(0); 
  let typedArray: {{.item.objectType}};
  try {
    typedArray = new {{.item.objectType}}(ss);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let atResult = typedArray.at(0);
  console.log("testEmptyTypedArrayAt result: " + atResult);
  // Assertion
  if (atResult == undefined) {
    console.log("testEmptyTypedArrayAt test passed.");
    return success;
  } else {
    console.log("testEmptyTypedArrayAt test failed.");
    return fail;
  }
}

function testNonEmptyTypedArraySetValue(): number {
  let ss = new ArrayBuffer(5 * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let length = typedArray.length;

  {%- if item.objectType == 'Int8Array' %}
    const minValue = Byte.MIN_VALUE as byte;
    const maxValue = Byte.MAX_VALUE as byte;
  {%- elif item.objectType == 'Int16Array' %}
    const minValue = Short.MIN_VALUE as short;
    const maxValue = Short.MAX_VALUE as short;
  {%- elif item.objectType == 'Int32Array' %}
    const minValue = Int.MIN_VALUE;
    const maxValue = Int.MAX_VALUE;
  {%- elif item.objectType == 'Float32Array' %}
    const minValue = Float.MIN_VALUE;
    const maxValue = Float.MAX_VALUE;
  {%- elif item.objectType == 'Float64Array' %}
    const minValue = Double.MIN_VALUE;
    const maxValue = Double.MAX_VALUE;
  {%- endif %}    

  try {
    typedArray[0] = 1;
    typedArray[1] = 2;
    typedArray[2] = minValue;
    typedArray[3] = maxValue;
    typedArray[4] = -1;
  } catch(e) {
    console.log(e);
    return fail;
  }

  let expectedArray: {{.item.primitiveType}}[] = [1, 2, minValue, maxValue, -1];

  for (let i = 0; i < typedArray.length; i++) {
    if (typedArray[i] != expectedArray[i]) {
      console.log("Test failed. testNonEmptyTypedArraySetValue: " + typedArray[i]);
      return fail;
    }
  }
  
  if (typedArray.at(length) != undefined) { // check value,  wrong index
    console.log("Test failed. typedArray.at(length) : " + typedArray.at(length));
    return fail;
  }
  if (typedArray.at(-1) != typedArray.at(-1 + length)) {  // check value,  wrong index
    console.log("Test failed. typedArray.at(-1) : " + typedArray.at(-1));
    return fail;
  }

  return success;
}


function testNonEmptyTypedArrayReverse(): number {
  let source1: {{.item.primitiveType}}[] = [5, 3, 1, 4, 2];
  let ss = new ArrayBuffer(source1.length * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
    typedArray.set(source1);
  } catch(e) {
    console.log(e);
    return fail;
  }

  // Test toReversed function
  let reversedArray: {{.item.objectType}} = typedArray.reverse();
  let expectedArray: {{.item.primitiveType}}[] = [2, 4, 1, 3, 5];
  for (let i = 0; i < reversedArray.length; i++) {
    if (reversedArray[i] != expectedArray[i]) {
      console.log("Test failed. testNonEmptyTypedArrayReverse: " + JSON.stringify(reversedArray[i]));
      return fail;
    }
  }
  return success;
}

function testEmptyTypedArrayReverse(): number {
  let ss = new ArrayBuffer(0);
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
  } catch(e) {
    console.log(e);
    return fail;
  }

  // Test toReversed function
  let reversedArray: {{.item.objectType}} = typedArray.reverse();

  if (reversedArray != typedArray || reversedArray.length != 0) {
    console.log("Test failed. testEmptyTypedArrayReverse: " + reversedArray);
    return fail;
  }

  return success;
}

function checkEntries(actual: [Number, Number], expected: [Number, Number], name: string): int {
    let result = (actual[0] == expected[0]) && (actual[1] == expected[1])
    if (result) {
        console.println("PASSED: " + name)
        return success
    }
    console.println("FAILED: " + name + ", expected: [" + expected.toString() + "], actual: [" + actual.toString() + "]")
    return fail
}

function assertEq(expr: boolean, expected: boolean, name: string): int {
    if (expr == expected) {
        console.println("PASSED: " + name)
        return success
    }
    console.println("FAILED: " + name + ", expected: " + (expected ? "true": "false") + ", actual: " + (expr ? "true": "false"))
    return fail
}

function testTypedArrayEntries(): int {
    let failures = 0
    const firstResult = [0, 1] as [Number, Number]
    const secondResult = [1, 2] as [Number, Number]
    const numbers = [1 as number, 2 as number]
    let entries = (new {{.item.objectType}}(numbers)).entries()
    failures += checkEntries(entries.next().value!, firstResult, "{{.item.objectType}}.entries() - next() #1")
    failures += checkEntries(entries.next().value!, secondResult, "{{.item.objectType}}.entries() - next() #2")
    failures += assertEq(entries.next().done, true, "{{.item.objectType}}.entries() - next() #3 (done)")
    return failures
}

// Test case for TypedArray.includes(searchElement) with Normal Number
function testTypedArrayIncludesOneParamWithNormalNum(): number {
  let ss = new ArrayBuffer(source.length as int * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
    typedArray.set(source);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let searchElementArray: {{.item.primitiveType}}[] =  {{.item.data}};

  for (let i = 0; i < searchElementArray.length; i++) {
    if (!typedArray.includes(searchElementArray[i])) {
      console.log("Test failed. testTypedArrayIncludesOneParamWithNormalNum: typed" + JSON.stringify(typedArray[i]));
      console.log("Test failed. testTypedArrayIncludesOneParamWithNormalNum: " + JSON.stringify(searchElementArray[i]));
      return fail;
    }
  }

  let searchElement = 8;
  let result = typedArray.includes(searchElement);
  if (result) {
    console.log(`Includes ${searchElement}? true`);
    return fail;
  } else {
    console.log(`Includes ${searchElement}? false`);
  }
  return success; 
}


// Test case for TypedArray.includes(searchElement) with abnormal number
function testTypedArrayIncludesOneParamWithAbnormalNum(): number {
  let ss = new ArrayBuffer(abnormalSource.length as int * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
    typedArray.set(abnormalSource);
  } catch(e) {
    console.log(e);
    return fail;
  }

  {%- if item.objectType == 'Int8Array' %}
    let searchElementArray: {{.item.primitiveType}}[] = [Byte.MAX_VALUE - 1 as byte, Byte.MAX_VALUE as byte, Byte.MIN_VALUE as byte, Byte.MIN_VALUE + 1 as byte];
  {%- elif item.objectType == 'Int16Array' %}
    let searchElementArray: {{.item.primitiveType}}[] = [Short.MAX_VALUE - 1 as short, Short.MAX_VALUE as short, Short.MIN_VALUE as short, Short.MIN_VALUE + 1 as short];
  {%- elif item.objectType == 'Int32Array' %}
    let searchElementArray: {{.item.primitiveType}}[] = [Int.MAX_VALUE - 1, Int.MAX_VALUE, Int.MIN_VALUE, Int.MIN_VALUE + 1];
  {%- elif item.objectType == 'Float32Array' %}
    let searchElementArray: {{.item.primitiveType}}[] = [-2, -1, Float.MAX_VALUE, Float.MAX_VALUE - 1];
  {%- elif item.objectType == 'Float64Array' %}
    let searchElementArray: {{.item.primitiveType}}[] = [-2, -1, Double.MAX_VALUE, Double.MAX_VALUE - 1];
  {%- endif %}

  for (let i = 0; i < searchElementArray.length; i++) {
    if (!typedArray.includes(searchElementArray[i])) {
      console.log("Test failed. testTypedArrayIncludesOneParamWithAbnormalNum: typed" + JSON.stringify(typedArray[i]));
      console.log("Test failed. testTypedArrayIncludesOneParamWithAbnormalNum: " + JSON.stringify(searchElementArray[i]));
      return fail;
    }
  }

  let searchElement = 8;
  let result = typedArray.includes(searchElement);
  if (result) {
    console.log(`Includes ${searchElement}? true`);
    return fail;
  } else {
    console.log(`Includes ${searchElement}? false`);
  }

  //with large Number
  let large_number: number[] = [-0x8000000000000000, 0x7FFFFFFFFFFFFFFF];
  {%- if item.objectType == 'Float32Array' or item.objectType == 'Float64Array' %}
    let convertedValues: number[] = [-0x8000000000000000, 0x7FFFFFFFFFFFFFFF];
  {%- elif item.objectType == 'Int32Array'%}
    let convertedValues: number[] = [Int.MIN_VALUE, Int.MAX_VALUE];
  {%- else %}
    let convertedValues: number[] = [0, -1];
  {%- endif %}
  typedArray = new {{.item.objectType}}(large_number);

  for (let i = 0; i < convertedValues.length; i++) {
    if (!typedArray.includes(convertedValues[i])) {
      console.log("Test failed. testtypedArrayIncludesOneParamWithAbnormalNum large number typed" + JSON.stringify(typedArray[i]));
      console.log("Test failed. testtypedArrayIncludesOneParamWithAbnormalNum large number except" + JSON.stringify(convertedValues[i]));
      return fail;
    }
  }
  return success; 
}


// Test case for TypedArray.includes(searchElement, fromIndex)
function testTypedArrayIncludesTwoParamWithNormalIndex(): number {
  let source1: number[] = [1, 2, 3, 4, 5];
  let ss = new ArrayBuffer(source1.length * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
    typedArray.set(source1);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let fromIndex = 1;
  let searchElement = 3;
  // Test when searchElement exists in the TypedArray with fromIndex specified
  let result = typedArray.includes(searchElement, fromIndex);
  if (result) {
    console.log(`Includes ${searchElement} from index ${fromIndex}? true`);
  } else {
    console.log(`Includes ${searchElement} from index ${fromIndex}? false`);
    return fail;
  }

  fromIndex = 4;
  result = typedArray.includes(searchElement, fromIndex);
  if (result) {
    console.log(`Includes ${searchElement} from index ${fromIndex}? true`);
    return fail;
  } else {
    console.log(`Includes ${searchElement} from index ${fromIndex}? false`);
  }

  return success;
}

// Test case for TypedArray.includes(searchElement, fromIndex)
function testTypedArrayIncludesTwoParamWithAbnormalIndex(): number {
  let source1: number[] = [1, 2, 3, 4, 5];
  let ss = new ArrayBuffer(source1.length * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
    typedArray.set(source1);
  } catch(e) {
    console.log(e);
    return fail;
  }

  let searchElement = 1;
  // Test when searchElement exists in the TypedArray with fromIndex specified
  //fromIndex = undefined,fromIndex = 0
  let result = typedArray.includes(searchElement, undefined);
  if (result) {
    console.log(`Includes ${searchElement} from undefined? true`);
  } else {
    console.log(`Includes ${searchElement} from undefined? false`);
    return fail;
  }

  let fromIndex = 0;
  let arrayLen = typedArray.length;
  //a. Let k be len + n.
  //ECMA: if fromIndex < 0(k < 0) ,a. Let k be len + n. 
  //      b. If k < 0, set k to 0. typedArray need to be fixed
  for (let i = 0 as int; i < arrayLen; i++) {
    fromIndex = (- arrayLen + i) as int;
    result = typedArray.includes(searchElement, fromIndex);
    let exceptResult = typedArray.includes(searchElement, i);
    if (result == exceptResult) {
      console.log(`Includes ${searchElement} from index ${fromIndex}? true`);
    } else {
      console.log(`Includes ${searchElement} from index ${fromIndex}? false`);
      return fail;
    }
  }
 
  //index > len, return false;
  fromIndex = 6 as int;
  result = typedArray.includes(searchElement, fromIndex);
  if (result) {
    console.log(`Includes ${searchElement} from index ${fromIndex}? true`);
    return fail;
  } else {
    console.log(`Includes ${searchElement} from index ${fromIndex}? false`);
  }

  //Currently not supported for typedArray
  //b. If k < 0, set k to 0.
  fromIndex = (-arrayLen -1) as int;
  result = typedArray.includes(searchElement, fromIndex);
  if (result) {
    console.log(`Includes ${searchElement} from index ${fromIndex}? true`);
  } else {
    console.log(`Includes ${searchElement} from index ${fromIndex}? false`);
    return fail;
  }
  //index = Infinity, return false
  result = typedArray.includes(searchElement, Infinity);
  if (result) {
    console.log(`Includes ${searchElement} from index Infinity? true`);
    return fail;
  } else {
    console.log(`Includes ${searchElement} from index Infinity? false`);
  }

  //fromIndex = -Infinity, fromIndex = 0
  result = typedArray.includes(searchElement, -Infinity);
  if (result) {
    console.log(`Includes ${searchElement} from index -Infinity? true`);
  } else {
    console.log(`Includes ${searchElement} from index -Infinity? false`);
    return fail;
  }

  return success;
}

function compareJoinResult(typedArray:{{.item.objectType}}, separator: string | undefined, expected: string): number {
   const result = typedArray.join(separator);
   return result == expected ? success : fail;
}

function testTypedArrayJoinWithEmptyArray(): number {
  let ss = new ArrayBuffer(0);
  let typedArray: {{.item.objectType}};
  try {
    typedArray = new {{.item.objectType}}(ss, 0);
  } catch(e) {
    return fail;
  }
  if (typedArray.length as number != 0 || typedArray.byteOffset as number != 0) {
    return fail;
  }

  // Test case 0: Using empty param
  const testResult0 = typedArray.join() == '' ? success : fail;

  // Test case 1: Using default separator
  const testResult1 = compareJoinResult(typedArray, undefined, '');
  console.log(`Test 1 result: ${testResult1}`); // Expected output: 0

  // Test case 2: Using comma as separator
  const testResult2 = compareJoinResult(typedArray, ',', '');
  console.log(`Test 2 result: ${testResult2}`); // Expected output: 0

  // Test case 3: Using hyphen as separator
  const testResult3 = compareJoinResult(typedArray, '-', '');
  console.log(`Test 3 result: ${testResult3}`); // Expected output: 0

  // Return the combined result of all test cases using addition
  return testResult0 + testResult1 + testResult2 + testResult3;
}

function testTypedArrayJoinWithNonEmptyArray(): number {
  let source1: number[] = [1, 2, 3, 4, 5];
  let ss = new ArrayBuffer(source1.length * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
    typedArray.set(source1);
  } catch(e) {
    console.log(e);
    return fail;
  }

  // Test case 0: Using empty param
  const testResult0 = typedArray.join() == '1,2,3,4,5' ? success : fail;

   // Test case 1: Using default separator (comma)
  const testResult1 = compareJoinResult(typedArray, undefined, '1,2,3,4,5');

  // Test case 2: Using comma as separator
  const testResult2 = compareJoinResult(typedArray, ',', '1,2,3,4,5');

  // Test case 3: Using hyphen as separator
  const testResult3 = compareJoinResult(typedArray, '-', '1-2-3-4-5');

  // Test case 4: Using empty string as separator
  const testResult4 = compareJoinResult(typedArray, '', '12345');

  // Test case 5: Using space as separator
  const testResult5 = compareJoinResult(typedArray, ' ', '1 2 3 4 5');

  // Test case 6: Using a multi-character separator
  const testResult6 = compareJoinResult(typedArray, ' | ', '1 | 2 | 3 | 4 | 5');

  // Test case 7: Using a numeric separator (will be coerced to string)
  const testResult7 = compareJoinResult(typedArray, `${1}`, '112131415');

  // Assert that all test cases pass
  return testResult0 + testResult1 + testResult2 + testResult3 + testResult4 + testResult5 + testResult6 + testResult7;
}

function testTypedArrayJoinWithNonEmptyArrayAndAbnormalStr(): number {
  let source1: number[] = [1, 2, 3, 4, 5];
  let ss = new ArrayBuffer(source1.length * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
    typedArray.set(source1);
  } catch(e) {
    console.log(e);
    return fail;
  }

  // Test case 1: Use newline character as a separator
  const testResult1 = compareJoinResult(typedArray, '\n', '1\n2\n3\n4\n5');

  // Test case 2: Use tab character as a separator
  const testResult2 = compareJoinResult(typedArray, '\t', '1\t2\t3\t4\t5');

  // Test case 3: Use backslash as a separator
  const testResult3 = compareJoinResult(typedArray, '\\', '1\\2\\3\\4\\5');

  // Assert that all test cases pass
  return testResult1 + testResult2 + testResult3;
}

function testTypedArrayKeysWithEmptyArray(): number {
  let ss = new ArrayBuffer(0);
  let typedArray: {{.item.objectType}};
  try {
    typedArray = new {{.item.objectType}}(ss, 0);
  } catch(e) {
    return fail;
  }
  if (typedArray.length as number != 0 || typedArray.byteOffset as number != 0) {
    return fail;
  }
  
  const emptyKeysArray = typedArray.keys();
  if(emptyKeysArray.next().value != undefined){
    return fail;
  }
  return success;
}

function testTypedArrayKeysWithSingleElementArray(): number {
  let typedArray: {{.item.objectType}};
  try {
    typedArray = new {{.item.objectType}}([1]);
  } catch(e) {
    return fail;
  }
  
  const emptyKeysArray = typedArray.keys();
  if(emptyKeysArray.next().value != 0){
    return fail;
  }

  //test nonInteger Length
  try {
    const nonIntegerLengthArray = new {{.item.objectType}}(3.5);
    const nonIntegerLengthIterator = nonIntegerLengthArray.keys();
    const expectedValues = [0, 1, 2];
    for (const expected of expectedValues) {
        if (nonIntegerLengthIterator.next().value != expected) {
            return fail;
        }
    }
    if (!nonIntegerLengthIterator.next().done) {
        return fail;
    }
    console.log(`Non-Integer Length Array Test Result: success`);
  } catch (error) {
      console.log('Non-Integer Length Array Test threw an error:', error);
      return fail;
  }

  //test big length,comment out the code to prevent potential unknown errors. 
  /*
  try {
      const largeLengthArray = new {{.item.objectType}}(1e4);
      let largeLengthKeysResult = 0;
      const largeLengthIterator = largeLengthArray.keys();
      for (let i = 0; i < 1e4; i++) {
        if (largeLengthIterator.next().value != i) {
            return fail;
        }
      }
      if (!largeLengthIterator.next().done) {
          return fail;
      }
      console.log(`Large Length Array Test Result: ${largeLengthKeysResult}`);
  } catch (error) {
      console.log('Large Length Array Test threw an error:', error);
      return fail;
  }*/
  return success;
}

function testTypedArrayKeysWithMultipleElementArray(): number {
  try {
    let typedArray = new {{.item.objectType}}([5, 15, 25, 35]);
    let multipleElementKeysResult = 0;
    const multipleElementIterator = typedArray.keys();
    const expectedValues = [0, 1, 2, 3];
    for (const expected of expectedValues) {
        if (multipleElementIterator.next().value != expected) {
            return fail;
        }
    }
    if (!multipleElementIterator.next().done) {
        return fail;
    }
      console.log(`Multiple Element Array Test Result: ${multipleElementKeysResult}`);
  } catch (error) {
      console.log('Multiple Element Array Test threw an error:', error);
      return fail;
  }
  return success;
}


function doubleElementsInArray(element: number, index: number, array: {{.item.objectType}}): {{.item.primitiveType}} {
   return element * 2 as {{.item.primitiveType}};
}

// Test case for forEach(callbackFn)
function testTypedArrayForEach(): number{
  let source1 = [1, 2, 3, 4, 5];
  let ss = new ArrayBuffer(source1.length * {{.item.primitiveSizeBytes}});
  let typedArray: {{.item.objectType}};

  try {
    typedArray = new {{.item.objectType}}(ss);
    typedArray.set(source1);
  } catch(e) {
    console.log(e);
    return 1; // Return 1 if there is an error in creating the typed array
  }

  typedArray.forEach((value, index, array) => {
    array[index] = value * 2;
  });

  // Compare the modified array with the expected result
  const expectedArray = [2, 4, 6, 8, 10];
  for (let i = 0; i < typedArray.length; i++) {
    if (typedArray[i] != expectedArray[i]) {
      console.log("Test failed. testTypedArrayForEach: " + JSON.stringify(typedArray[i]));
      return fail;
    }
  }
  return success;
}

// Test case for forEach(callbackFn: (value: number, index: number) => void)
function testTypedArrayForEachValueIndexCallback(): number {
    let source1 = [1, 2, 3, 4, 5];
    let ss = new ArrayBuffer(source1.length * {{.item.primitiveSizeBytes}});
    let typedArray: {{.item.objectType}};

    try {
        typedArray = new {{.item.objectType}}(ss);
        typedArray.set(source1);
    } catch (e) {
        console.log(e);
        return fail; // Return 1 if there is an error in creating the typed array
    }

    typedArray.forEach((value, index) => {
        typedArray[index] = value * 2;
        console.log("In forEach: " + JSON.stringify(typedArray[index]));
    });

    // Compare the modified array with the expected result
    const expectedArray = [2, 4, 6, 8, 10];
    for (let i = 0; i < typedArray.length; i++) {
      if (typedArray[i] != expectedArray[i]) {
        console.log("Test failed. testTypedArrayForEachValueIndexCallback: " + JSON.stringify(typedArray[i]));
        return fail;
      }
    }
    return success;
}

// Test case for forEach(callbackFn: (value: number) => void)
function testTypedArrayForEachValueCallback(): number {
    let source1 = [1, 2, 3, 4, 5];
    let ss = new ArrayBuffer(source1.length * {{.item.primitiveSizeBytes}});
    let typedArray: {{.item.objectType}};

    try {
        typedArray = new {{.item.objectType}}(ss);
        typedArray.set(source1);
    } catch (e) {
        console.log(e);
        return fail; // Return 1 if there is an error in creating the typed array
    }

    let index = 0;
    typedArray.forEach((value) => {
        typedArray[index] = value * 2;
        console.log("In forEach: " + JSON.stringify(typedArray[index]));
        index++;
    });

    // Compare the modified array with the expected result
    const expectedArray = [2, 4, 6, 8, 10];
    for (let i = 0; i < typedArray.length; i++) {
        if (typedArray[i] != expectedArray[i]) {
            console.log("Test failed. testTypedArrayForEachValueCallback: " + JSON.stringify(typedArray[i]));
            return fail;
        }
    }
    return success;
}

// Test case for forEach(callbackFn: () => void)
function testTypedArrayForEachNoArgsCallback(): number {
    let source1 = [1, 2, 3, 4, 5];
    let ss = new ArrayBuffer(source1.length * {{.item.primitiveSizeBytes}});
    let typedArray: {{.item.objectType}};

    try {
        typedArray = new {{.item.objectType}}(ss);
        typedArray.set(source1);
    } catch (e) {
        console.log(e);
        return fail; // Return 1 if there is an error in creating the typed array
    }

    let index = 0;
    typedArray.forEach(() => {
        // As forEach without arguments is not valid for typed arrays, this implementation is just for demonstration
        typedArray[index] = typedArray[index] * 2;
        index++;
    });
    // Compare the modified array with the expected result
    const expectedArray = [2, 4, 6, 8, 10];
    for (let i = 0; i < typedArray.length; i++) {
        if (typedArray[i] != expectedArray[i]) {
            console.log("Test failed. testTypedArrayForEachNoArgsCallback: " + JSON.stringify(typedArray[i]));
            return fail;
        }
    }
    return success;
}

