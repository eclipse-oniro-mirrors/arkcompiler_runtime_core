/*
 * Copyright (c) 2021-2026 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Defines the Array for ArkTS
 * @kit ArkTS
 */

package std.core;

// NOTE: autogenerated file

 // NOTE(zaytsevaekaterina): fix in #26615
class ArrayKeysIterator<T> implements IterableIterator<number> {
    private parent: Array<T>
    private idx: int = 0
    private isDone: boolean = false

    constructor(parent: Array<T>) {
        this.parent = parent
    }

    override next(): IteratorResult<number> {
        if (this.isDone || this.idx >= this.parent.length) {
            this.isDone = true
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>((this.idx++).toDouble())
    }

    override $_iterator(): IterableIterator<number> {
        return this
    }
}

class FromBuffer {}
// initialized in _initializerBlock_.ets
const FROM_BUFFER: FromBuffer;

/**
 * Defines arrType for Array
 *
 * @typedef { String | undefined } arrType
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
type arrType = String | undefined;

/**
 * Represents a Array.
 *
 * @class Array
 * @implements ReadonlyArray<T>, Iterable<T>
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export class Array<T> implements ReadonlyArray<T>, Iterable<T> {
    private buffer: FixedArray<Any>
    protected actualLength: int
    private static INIT_CAPACITY: int = 4

    /**
     * Get the length of the array.
     *
     * @returns { int } The length of the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    override get length(): int {
        return this.actualLength
    }

    /**
     * Set the length of the array.
     *
     * @param { int } newLen The new length of the array.
     * @returns { void }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    set length(newLen: int) {
        const len = newLen
        if (len < 0 || len > this.actualLength) {
            throw new RangeError("can't change length to bigger or negative")
        }
        if (len == 0) {
            this.buffer = new FixedArray<Any>(Array.INIT_CAPACITY)
        } else {
            const other = this.slice(0, len)
            this.buffer = other.buffer
        }
        this.actualLength = len
    }

    /**
     * Get the element at the specified index.
     *
     * @param { int } idx The index of the element to get.
     * @returns { T } The element at the specified index.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override native $_get(idx: int): T;

    private final native $_get_unsafe(idx: int): T

    /**
     * Set the element at the specified index.
     *
     * @param { int } idx The index of the element to set.
     * @param { T } val The value to set at the specified index.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_set(idx: int, val: T): void;

    private final native $_set_unsafe(idx: int, val: T | undefined): void

    /**
     * Creates a new instance of Array with the specified initial length.
     *
     * @param { int } arrayLen The initial length of the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(arrayLen: int) {
        this.buffer = new FixedArray<Any>(arrayLen)
        this.actualLength = arrayLen
    }

    private constructor(_tag: FromBuffer, buf: FixedArray<Any>) {
        this.buffer = buf
        this.actualLength = buf.length
    }

    /**
     * Creates a new empty instance of Array.
     *
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor() {
        this.buffer = new FixedArray<Any>(Array.INIT_CAPACITY)
        this.actualLength = 0
    }

    /**
     * Creates a new instance of Array with the given elements.
     *
     * @param { T } first The first element of the array.
     * @param { T[] } d The rest of the elements to initialize the array with.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(first: T, ...d: T[]) {
        this.buffer = new FixedArray<Any>(d.length + 1)
        this.actualLength = d.length + 1
        this.buffer[0] = first

        for (let k: int = 0; k < d.length; k++) {
            this.$_set_unsafe(k + 1, d[k])
        }
    }

    /**
     * Creates a new instance of Array with a specific length and initializes each element using a function.
     *
     * @param { int } arrayLen The amount of elements in the array.
     * @param { function } initializer A function that generates an element for a given index.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(arrayLen: int, initializer: (index: int) => T) {
        this.buffer = new FixedArray<Any>(arrayLen)
        this.actualLength = arrayLen
        for (let k: int = 0; k < arrayLen; k++) {
            this.$_set_unsafe(k, initializer(k))
        }
    }

    /**
     * Creates a new Array of the specified length, filled with the specified initial value.
     *
     * @param { int } arrayLength The amount of elements in the new array.
     * @param { T } initialValue The value to fill the array with.
     * @returns { Array<T> } A new Array instance filled with the initial value.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static create<T>(arrayLength: int, initialValue: T): Array<T> {
        let other = new Array<T>(arrayLength)
        other.fill(initialValue)
        return other
    }

    /**
     * Extends the Array with new elements up to the specified length.
     *
     * @param { int } arrayLength The new length of the array.
     * @param { T } initialValue The initial value for the added elements.
     * @throws { RangeError } Throws a RangeError if the array length is negative.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public extendTo(arrayLength: int, initialValue: T): void {
        if(arrayLength < 0){
            throw new RangeError("Parameter error.Invalid array length.")
        }
        const delta: int = arrayLength - this.actualLength
        if (delta <= 0) {
            return
        }
        this.ensureUnusedCapacity(delta)
        for (let i: int = 0; i < delta; i++) {
            this.buffer[this.actualLength + i] = initialValue
        }
        this.actualLength = arrayLength
    }

    /**
     * Shrinks the Array to the specified length. Elements beyond the new length are removed.
     *
     * @param { int } arrayLength The length at which to shrink the array.
     * @throws { RangeError } Throws a RangeError if the array length is negative.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public shrinkTo(arrayLength: int): void {
        if(arrayLength < 0){
            throw new RangeError("Parameter error.Invalid array length.")
        }
        if (arrayLength >= this.actualLength) {
            return
        }
        let newLen: int = arrayLength
        if (newLen < 0) {
            // Convert from signed to unsigned
            newLen = newLen & Int.MAX_VALUE
        }
        const other = this.slice(0, newLen)
        this.buffer = other.buffer
        this.actualLength = other.actualLength
    }

    /**
     * Creates a new empty instance of Array.
     *
     * @returns { Array<T> } A new Array instance.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     * @example
     * ```arkts
     * // Using the constructor
     * const a = new Array<number>();
     *
     * // Using the invoke overload (behaves like calling Array() as a function)
     * const b = Array<number>();
     * ```
     */
    static $_invoke<T>(): Array<T> {
        return new Array<T>();
    }

    /**
     * Creates a new instance of an Array with the specified length.
     *
     * @param { int } [arrayLength] The length of the array to be created (optional).
     * @returns { Array<T> } A new Array instance with the specified length.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     * @example
     * ```arkts
     * // Constructor form
     * const a = new Array<number>(3); // length = 3
     *
     * // Invoke overload form (Array() as a function)
     * const b = Array<number>(3);     // also creates an array of length 3
     * ```
     */
    static $_invoke<T>(arrayLength?: int): Array<T> {
        if (arrayLength != undefined) {
            return new Array<T>(arrayLength);
        } else {
            return new Array<T>();
        }
    }

    /**
     * Creates a new instance of Array with the given elements.
     *
     * @param { T[] } items The elements to initialize the array with.
     * @returns { Array<T> } A new Array instance with the given elements.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     * @example
     * ```arkts
     * // Constructor form
     * const a = new Array(1, 2, 3);
     *
     * // Invoke overload form (Array() as a function)
     * const b = Array(1, 2, 3);
     * ```
     */
    static $_invoke<T>(...items: T[]): Array<T> {
        if (items.length == 0) {
            return new Array<T>(0)
        }
        return new Array<T>(items[0], ...items.slice(1))
    }

    /**
     * Creates a new `Array` instance from a `FixedArray`.
     *
     * @param { FixedArray<T> } arr The source primitive array.
     * @returns { Array<T> } A new Array instance containing the elements from the source array.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(arr: FixedArray<T>): Array<T> {
        const len: int = arr.length
        const ret: FixedArray<Any> = new FixedArray<Any>(len)
        for (let i: int = 0; i < len; i++) {
            ret[i] = arr[i]
        }
        return new Array<T>(FROM_BUFFER, ret)
    }

    /**
     * Creates a new `Array` instance from an `ArrayLike` object.
     *
     * @param { ArrayLike<T> } arr An array-like object to convert to an array.
     * @returns { Array<T> } A new Array instance containing the elements from the array-like object.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(arr: ArrayLike<T>): Array<T> {
        const ret: Array<T> = new Array<T>(arr.length)
        let i: int = 0
        iteratorForEach<T>(arr.$_iterator(), (x: T): void => {
            ret[i] = x
            i += 1
        })
        return ret
    }

    /**
     * Creates a new `Array` instance from an iterable or array-like object.
     *
     * @param { ArrayLike<T> | Iterable<T> } iterable An iterable or array-like object to convert to an array.
     * @returns { Array<T> } A new Array instance containing the elements from the iterable.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(iterable: ArrayLike<T> | Iterable<T>): Array<T> {
        const ret = new Array<T>()
        iteratorForEach<T>(iterable.$_iterator(), (x: T): void => {
            ret.push(x)
        })
        return ret
    }

    /**
     * Creates a new `Array` instance from a `FixedArray` and applies a mapping function to each element.
     *
     * @param { FixedArray<T> } values The source primitive array.
     * @param { function } mapfn A mapping function to call on every element of the array.
     * @returns { Array<U> } A new Array instance with the mapped values.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T, U>(values: FixedArray<T>, mapfn: (v: T, k: int) => U): Array<U> {
        const length: int = values.length
        const ret: Array<U> = new Array<U>(length)
        for (let i: int = 0; i < length; ++i) {
            ret[i] = mapfn(values[i], i)
        }
        return ret
    }

    /**
     * Creates a new `Array` instance from an iterable object, applying a mapping function to each element.
     * Every value to be added to the array is first passed through this function, and `mapfn`'s return value is added
     * to the array instead.
     *
     * @param { ArrayLike<T> | Iterable<T> } iterable An iterable or array-like object to convert to an array.
     * @param { function } mapfn A mapping function to call on every element of the array.
     * @returns { Array<U> } A new Array instance with the mapped values.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T, U>(iterable: ArrayLike<T> | Iterable<T>, mapfn: (v: T, k: int) => U): Array<U> {
        const ret: Array<U> = new Array<U>()
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new FixedArray<int>(1)
        idx[0] = 0
        iteratorForEach<T>(iterable.$_iterator(), (x: T): void => {
            ret.push(mapfn(x, idx[0]))
            idx[0] += 1
        })
        return ret
    }

    private searchUndefined(fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (this.$_get_unsafe(i) instanceof undefined) {
                return true
            }
        }
        return false
    }

    private searchNull(fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (this.$_get_unsafe(i) instanceof null) {
                return true
            }
        }
        return false
    }

    private searchString(val: String, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof String) {
                if (tmp == val) {
                    return true
                }
            }
        }
        return false
    }

    private searchDouble(val: double, fi: int, len: int): boolean {
        if (isNaN(val)) {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Double) {
                    if (isNaN(tmp)) {
                        return true
                    }
                }
            }
        } else {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Double) {
                    if (val == tmp) {
                        return true
                    }
                }
            }
        }
        return false
    }

    private searchFloat(val: Float, fi: int, len: int): boolean {
        if (isNaN(val)) {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Float) {
                    if (isNaN(tmp)) {
                        return true
                    }
                }
            }
        } else {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Float) {
                    if (val == tmp) {
                        return true
                    }
                }
            }
        }
        return false
    }

    private searchLong(val: Long, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Long) {
                if (tmp == val) {
                    return true
                }
            }
        }
        return false
    }

    private searchInt(val: Int, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Int) {
                if (tmp == val) {
                    return true
                }
            }
        }
        return false
    }

    private searchCommon(val: T, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (val == this.$_get_unsafe(i)) {
                return true;
            }
        }
        return false
    }

    /**
     * Default comparison function for sort algorithm.
     * Objects are compared as string. Both objects are converted to string
     * using `toString()` method and compared using `compareTo()` method of `String` class.
     *
     * @param { Any } a Object to be compared.
     * @param { Any } b Object to be compared.
     * @returns { int } One of -1 (less), 0 (equal), or 1 (greater).
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private static defaultComparator(a: Any, b: Any): int {
        if (a instanceof Number && b instanceof Number) {
            const x = a
            const y = b
            if (Number.isInteger(x) && Number.isInteger(y) &&
                x <= Int.MAX_VALUE / 128 && x >= Int.MIN_VALUE / 128 &&
                y <= Int.MAX_VALUE / 128 && y >= Int.MIN_VALUE / 128) {
                let z = x.toInt()
                let w = y.toInt()
                return Array.defaultComparatorInts(z, w)
            }
        } else if (a instanceof String && b instanceof String) {
            return a.compareTo(b)
        }
        let sa = new String(a)
        let sb = new String(b)
        return sa.compareTo(sb)
    }

    private static defaultComparatorInts(a: int, b: int): int {
        if (a < 0) {
            if (b >= 0) {
                return -1
            }
            a *= -1
            b *= -1
        } else if (b < 0) {
            return 1
        }
        let aDigs = 1
        while (10 * aDigs <= a) {
            aDigs *= 10
        }
        let bDigs = 1
        while (10 * bDigs <= b) {
            bDigs *= 10
        }

        while (aDigs > 0 && bDigs > 0) {
            let r = (a / aDigs) - (b / bDigs)
            if (r != 0) {
                return r
            }
            aDigs /= 10
            bDigs /= 10
        }
        return (aDigs - bDigs)
    }

    private static defaultComparatorStr(a: String, b: String) {
        return a.compareTo(b)
    }

    /**
     * Helper function preparing copy of `this` instance of `Array` class' data array.
     *
     * @returns { FixedArray<Any> } Copy of this Array's primitive buffer.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private copyArray(): FixedArray<Any> {
        let len: int = this.actualLength
        let res : FixedArray<Any> = new FixedArray<Any>(len)
        for (let i = 0; i < len; i++) {
            res[i] = this.$_get_unsafe(i)
        }
        return res
    }

    private wrap_default_sort(): void {
        let idxNonUndef = 0
        try {
            let strArr : FixedArray<arrType> = new FixedArray<arrType>(this.actualLength)
            for (let i = 0; i < this.actualLength; i++) {
                const vl = this.$_get_unsafe(i)
                if (vl !== undefined) {
                    if (vl == null) {
                        this.$_set_unsafe(idxNonUndef, vl as T)
                        strArr[idxNonUndef] = "null"
                    } else {
                        this.$_set_unsafe(idxNonUndef, vl)
                        strArr[idxNonUndef] = (vl as object).toString() // #26217
                    }
                    idxNonUndef++
                }
            }
            let sortTo = idxNonUndef
            for (let i = idxNonUndef; i < this.actualLength; i++) {
                this.$_set_unsafe(i, undefined as T)
            }

            sort_default<Any>(this.buffer, strArr, 0, sortTo)
        }
        catch (e) {
            if (e instanceof OutOfMemoryError) {
                this.slow_default_sort()
            } else {
                throw e as Error
            }
        }
    }

    private slow_default_sort(): void {
        let idxNonUndef = 0
        const cmp: (l: Any, r: Any) => int = (l: Any, r: Any): int => {
            return Array.defaultComparator(l, r)
        }
        for (let i = 0; i < this.actualLength; i++) {
            const vl = this.$_get_unsafe(i)
            if (vl !== undefined) {
                this.$_set_unsafe(idxNonUndef, vl)
                idxNonUndef++
            }
        }
        let sortTo: int = idxNonUndef
        for (let i = idxNonUndef; i < this.actualLength; i++) {
            this.$_set_unsafe(i, undefined as T)
        }
        sort_stable<Any>(this.buffer, 0, sortTo, cmp)
    }

    private move_undefined_end(): int {
        let writeIndex: int = 0
        for (let i = 0; i < this.actualLength; i++) {
            let val = this.$_get_unsafe(i)
            if (val !== undefined) {
                if(writeIndex != i) {
                    this.$_set_unsafe(writeIndex, val)
                }
                writeIndex++
            }
        }
        for (let i = writeIndex; i < this.actualLength; i++) {
            this.$_set_unsafe(i, undefined as T)
        }
        return writeIndex
    }

    /**
     * Sorts the elements of an array in place and returns the reference to the same array, now sorted.
     *
     * @param { function } [comparator] Optional. A function that defines the sort order. If omitted, the array is sorted
     *     according to each character's Unicode code point value, according to the string conversion of each element.
     * @returns { this } The sorted array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public sort(comparator?: (a: T, b: T) => int): this {
        if (this.actualLength <= 1)
            return this

        if (comparator == undefined) {
            this.wrap_default_sort()
            return this
        }

        const compareTo: int = this.move_undefined_end()
        let cmp: (l: Any, r: Any) => int = (l: Any, r: Any): int => {
            return comparator!(l as T, r as T)
        }
        sort_stable<Any>(this.buffer, 0, compareTo, cmp)
        return this
    }

    /**
     * Removes the first element from an array and returns that removed element. This method changes the length of the array.
     *
     * @returns { T | undefined } The removed element from the array; undefined if the array is empty.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public shift(): T | undefined {
        const len: int = this.actualLength
        if(len == 0) {
            return undefined
        }
        let obj: T = this.$_get_unsafe(0)
        copyToFastWithBarriers(this.buffer, this.buffer, 0, 1, len)
        this.popImpl()
        return obj
    }

    /**
     * Removes the last element from an array and returns that element. This method changes the length of the array.
     *
     * @returns { T | undefined } The removed element from the array; undefined if the array is empty.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public pop(): T | undefined {
        const len: int = this.actualLength
        if(len == 0) {
            return undefined
        }
        let obj: T = this.$_get_unsafe(len - 1)
        this.popImpl()
        return obj
    }

    private popImpl(): void {
        const index: int = this.actualLength - 1
        this.$_set_unsafe(index, undefined)
        this.actualLength = index
    }

    /**
     * Adds the specified elements to the end of an array and returns the new length of the array.
     *
     * @param { T[] } val The elements to add to the end of the array.
     * @returns { int } The new length of the array upon which the method was called.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public pushArray(...val: T[]): int {
        const length: int = val.length
        this.ensureUnusedCapacity(length)
        for (let i = 0; i < length; i++) {
            this.buffer[this.actualLength + i] = val[i]
        }
        this.actualLength += length
        return this.actualLength
    }

    /**
     * Adds the specified element to the end of an array and returns the new length of the array.
     *
     * @param { T } val The element to add to the end of the array.
     * @returns { int } The new length of the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public pushOne(val: T): int {
        this.ensureUnusedCapacity(1)
        this.buffer[this.actualLength] = val
        this.actualLength += 1
        return this.actualLength
    }

    overload push{ pushOne, pushArray }

    private ensureUnusedCapacity(cap: int): void {
        const length: int = this.buffer.length
        if (this.actualLength + cap > length) {
            const copy: FixedArray<Any> = new FixedArray<Any>(length * 2 + cap)
            for (let i = 0; i < this.actualLength; i++) {
                copy[i] = this.buffer[i]
            }
            this.buffer = copy
        }
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.
     *
     * @param { int } start The index at which to start changing the array.
     * @param { int | undefined } delete The number of items to remove after the start index.
     * @param { T[] } items The elements to add to the array, beginning from start.
     * @returns { Array<T> } An array containing the deleted elements.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public splice(start: int, delete: int | undefined, ...items: T[]): Array<T> {
        if (delete === undefined) {
            delete = 0
        }
        start = normalizeIndex(start, this.actualLength)
        if (delete < 0) {
            delete = 0
        }
        if (start > this.actualLength - delete) {
            delete = this.actualLength - start
        }
        // this: [left middle right], we must replace middle with `items`

        const itemsLength = items.length
        this.ensureUnusedCapacity(itemsLength - delete)
        const oldLen = this.actualLength
        const newLen = this.actualLength - delete + itemsLength
        // Extend `actualLength` to ensure correct operations.
        // Note that shrinking the array will lead to incorrect behavior
        if (newLen > oldLen) {
            this.actualLength = newLen
        }

        let ret = new Array<T>(delete)
        // left part remains unchanged
        // copy excluded part
        for (let i = 0; i < delete; i++) {
            ret.$_set_unsafe(i, this.$_get_unsafe(start + i))
        }
        // move right part to the right of the buffer
        const rightLen = oldLen - start - delete
        if (itemsLength > delete) {
            for (let i = 0; i < rightLen; i++) {
                // This operation is correct because `actualLength` was extended before
                this.$_set_unsafe(newLen - 1 - i, this.$_get_unsafe(oldLen - 1 - i))
            }
        } else {
            for (let i = 0; i < rightLen; i++) {
                this.$_set_unsafe(start + itemsLength + i, this.$_get_unsafe(start + delete + i))
            }
            for (let i = newLen; i < oldLen; i++) {
                this.$_set_unsafe(i, undefined)
            }
        }
        // insert middle part
        for (let i = 0; i < itemsLength; i++) {
            this.$_set_unsafe(start + i, items.$_get_unsafe(i))
        }
        // Update length in the end to ensure correct `this` operations
        this.actualLength = newLen
        return ret
    }

    /**
     * Changes the contents of an array by removing existing elements in place from the start index to the end.
     *
     * @param { int } start The index at which to start changing the array.
     * @returns { Array<T> } An array containing the deleted elements.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public splice(start: int): Array<T> {
        return this.splice(start, this.actualLength)
    }

    /**
     * Checks whether the passed value is an Array.
     *
     * @param { Any } o The value to be checked.
     * @returns { boolean } True if the value is an Array; otherwise, false.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static isArray(o: Any): boolean {
        return o instanceof Array
    }

    /**
     * Creates a new Array instance from a variable number of arguments, regardless of number or type of the arguments.
     *
     * @param { T[] } values Elements of which to create the array.
     * @returns { Array<T> } A new Array instance.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of<T>(...values: T[]): Array<T> {
        const ret = new Array<T>()
        const length: int = values.length
        ret.ensureUnusedCapacity(length)
        for (let i = 0; i < length; i++) {
            ret.push(values[i])
        }
        return ret
    }

    /**
     * Adds the specified elements to the beginning of an Array and returns the new length of the Array.
     *
     * @param { T[] } values The elements to add to the front of the array.
     * @returns { int } The new length of the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public unshift(...values: T[]): int {
        const length: int = this.buffer.length
        if (length <= values.actualLength + this.actualLength) {
            let buffer: FixedArray<Any> = new FixedArray<Any>(length * 2 + values.actualLength)
            Array.unshiftInternal(this.buffer, this.actualLength, buffer, values)
            this.buffer = buffer
        } else {
            Array.unshiftInternal(this.buffer, this.actualLength, this.buffer, values)
        }

        this.actualLength += values.actualLength
        return this.actualLength
    }

    private static native unshiftInternal<T>(self: FixedArray<Any>, selfLen: int, buffer: FixedArray<Any>, values: Array<T>): void

    /**
     * Returns a new Array Iterator object that contains the keys for each index in the array.
     *
     * @returns { IterableIterator<number> } A new Array Iterator object.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    // NOTE(zaytsevaekaterina): fix in #26615
    public override keys(): IterableIterator<number> {
        return new ArrayKeysIterator<T>(this)
    }

    /**
     * Returns an iterator over all values
     *
     * @returns { IterableIterator<T> } An iterator over all values.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override $_iterator(): IterableIterator<T> {
        return this.values()
    }

    // === methods with incompatible implementation ===
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     *
     * @param { function } predicate A function that accepts up to three arguments. The filter method calls the
     *     predicate function one time for each element in the array.
     * @returns { Array<T> } A new array with the elements that pass the test.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override filter(predicate: (value: T, index: int, array: Array<T>) => boolean): Array<T> {
        const res = new Array<T>()
        const len = this.actualLength
        for (let i: int = 0; i < len && i < this.actualLength; i++) {
            const val = this.$_get_unsafe(i)
            if (predicate(val, i, this)) {
                res.push(val)
            }
        }
        return res
    }

    /**
     * Creates a new Array with all sub-array elements concatenated into it recursively up to the specified depth.
     *
     * @param { int } depth The depth level specifying how deep a nested array structure should be flattened.
     * @returns { Array<U> } A new array with the sub-array elements concatenated into it.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public flat<U = T>(depth: int): Array<U> {
        let ret = new Array<U>()
        this.flatImpl<U>(depth, ret)
        return ret
    }

    /**
     * Determines whether obj is exactly an instance of the std.core.Array class.
     *
     * @param { Object } obj The object to check.
     * @returns { boolean } True if obj is an instance of std.core.Array; otherwise, false.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private static native isPlatformArray(obj: Object): boolean

    /**
     * Returns the buffer from an instance of the std.core.Array class.
     * The caller must ensure obj is an instance of std.core.Array (e.g. via isPlatformArray).
     *
     * @param { Object } obj An instance of std.core.Array.
     * @returns { FixedArray<Any> } A reference to the (obj as Array<T>).buffer field.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private static native getBuffer(obj: Object): FixedArray<Any>;

    /**
     * Creates a new `Array` by merging this `Array` instance with given arrays and/or values.
     *
     * @param { FixedArray<ConcatArray<T>> } items Arrays and/or values to concatenate into a new array.
     * @returns { Array<T> } A new Array instance.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public concat(...items: FixedArray<ConcatArray<T>>): Array<T> {
        let totalAdd = this.actualLength;
        for (let i = 0; i < items.length; i++) {
            totalAdd += items[i].length
        }

        const buf : FixedArray<Any> = new FixedArray<Any>(totalAdd);
        copyTo(this.buffer, buf, 0, 0, this.actualLength)

        let insertTo = this.actualLength;
        for (let i = 0; i < items.length; i++) {
            const arr = items[i]
            const len: int = arr.length
            if (Array.isPlatformArray(arr)) {
                copyTo(Array.getBuffer(arr), buf, insertTo, 0, len)
                insertTo += len
            } else {
                for (let j = 0; j < len; j++) {
                    buf[insertTo++] = arr.$_get(j)
                }
            }
        }

        return new Array<T>(FROM_BUFFER, buf);
    }

    private flatImpl<U>(depth: int, to: Array<U>) {
        for (let i = 0; i < this.actualLength; i++) {
            let element = this.buffer[i]
            if (depth > 0 && element instanceof Array) {
                let subArray = (element as Array<T>).flat<U>(depth - 1)
                for (let j = 0; j < subArray.length; j++) {
                    to.push(subArray[j] as U)
                }
            } else {
                to.push(element as U)
            }
        }
    }

    /**
     * Creates a new Array with all sub-array elements concatenated into it recursively with a default depth of 1.
     *
     * @returns { Array<U> } A new array with the sub-array elements concatenated into it.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public flat<U = T>(): Array<U> {
        return this.flat<U>(1)
    }

    /**
     * Calls a defined callback function on each element of an array. Then, flattens the result into a new array.
     * This is identical to a map() followed by a flat() with depth 1.
     *
     * @param { function } fn A function that produces an element of the new Array.
     * @returns { Array<U> } A new array with each element being the result of the callback function and flattened.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public flatMap<U = T>(fn: (v: T, k: int, arr: Array<T>) => U | ReadonlyArray<U>): Array<U> {
        const result = new Array<U>();
        for (let i = 0; i < this.actualLength; ++i) {
            let value: U | ReadonlyArray<U> = fn(this.$_get_unsafe(i), i, this);
            if (value instanceof ReadonlyArray) {
                let vv: ReadonlyArray<U> = value;
                for (let i = 0; i < vv.length; ++i) {
                    result.push(vv[i]);  // Workaround to not use 'push(value[i] as U)'
                }
            }
            else {
                result.push(value);
            }
        }
        return result;
    }

    // === methods common among all arrays ===

    /**
     * Takes an integer value and returns the item at that index, allowing for positive and negative integers.
     * Negative integers count back from the last item in the array.
     *

     * @param { int } index Zero-based index of the array element to be returned.
     * @returns { T } The element at the given index.
     * @throws { RangeError } Throws a RangeError if the index is out of bounds.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override at(index: int): T {
        let len = this.actualLength;
        let k: int;
        if (index >= 0) {
            k = index;
        } else {
            k = len + index;
        }

        if (k < 0 || k >= len) {
            throw new RangeError("Invalid index");
        }

        return this.$_get_unsafe(k);
    }

    /**
     * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its
     * length.
     *

     * @param { int } target Zero-based index at which to copy the sequence to.
     * @returns { this } The modified array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int): this {
        this.copyWithin(target, 0, this.actualLength);
        return this;
    }

    /**
     * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its
     * length.
     *

     * @param { int } target Zero-based index at which to copy the sequence to.
     * @param { int } start Zero-based index at which to start copying elements from.
     * @returns { this } The modified array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int, start: int): this {
        this.copyWithin(target, start, this.actualLength);
        return this;
    }

    /**
     * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its
     * length.
     *

     * @param { int } target Zero-based index at which to copy the sequence to.
     * @param { int } start Zero-based index at which to start copying elements from.
     * @param { int } [end] Zero-based index at which to end copying elements from.
     * @returns { this } The modified array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int, start: int, end?: int): this {
        target = normalizeIndex(target, this.actualLength)
        start = normalizeIndex(start, this.actualLength)
        end = normalizeIndex(end ?? this.actualLength, this.actualLength)

        if (end <= start) {
            return this;
        }

        if (target <= start) {
            while (start < end) {
                const read = this.$_get_unsafe(start++);
                this.$_set_unsafe(target++, read);
            }
        } else {
            let len = end - start;
            if (target + len > this.actualLength) {
                len = this.actualLength - target
            }
            for (let i = 0; i < len; i++) {
                const read = this.$_get_unsafe(start + len - 1 - i);
                this.$_set_unsafe(target + len - 1 - i, read);
            }
        }

        return this;
    }

    /**
     * Changes all elements in the Array to a static value, from a start index to an end index.
     *

     * @param { T } value The value to fill the array with.
     * @param { int } [start] The index at which to start filling (optional).
     * @param { int } [end] The index at which to end filling (optional, not included).
     * @returns { this } The modified array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: T, start?: int, end?: int): this {
        Array.fillImpl(this.buffer, this.actualLength, value, start ?? 0, end ?? this.actualLength)
        return this
    }

    private static native fillImpl<T>(buffer: FixedArray<Any>, actualLength: int, value: T, start: int, end: int): void;

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined otherwise.
     *

     * @param { function } predicate A function to execute on each value in the array.
     * @returns { T | undefined } The value of the first element that satisfies the provided testing function;
     *     otherwise, undefined.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override find(predicate: (value: T, index: int, array: Array<T>) => boolean): T | undefined {
        const len = this.actualLength
        for (let i = 0; i < len && i < this.actualLength; i++) {
            const val = this.$_get_unsafe(i);
            if (predicate(val, i, this)) {
                return val;
            }
        }
        return undefined;
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1 otherwise.
     *

     * @param { function } predicate A function to execute on each value in the array.
     * @returns { int } The index of the first element that satisfies the provided testing function; otherwise, -1.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override findIndex(predicate: (value: T, index: int, array: Array<T>) => boolean): int {
        const len = this.actualLength
        for (let i = 0; i < len && i < this.actualLength; i++) {
            if (predicate(this.$_get_unsafe(i), i, this)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Iterates the array in reverse order and returns the value of the first element that satisfies the provided
     * testing function.
     *

     * @param { function } predicate A function to execute on each value in the array.
     * @returns { T | undefined } The value of the element if found; otherwise, undefined.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override findLast(predicate: (elem: T, index: int, array: Array<T>) => boolean): T | undefined {
        for (let i = this.actualLength - 1; i >= 0 && i < this.actualLength; i--) {
            const val = this.$_get_unsafe(i);
            if (predicate(val, i, this)) {
                return val;
            }
        }
        return undefined;
    }

    /**
     * Determines whether all the members of an array satisfy the specified test.
     *

     * @param { function } predicate A function that accepts up to three arguments. The every method calls the predicate
     *     function for each element in the array until the predicate returns a value which is
     *     coercible to the Boolean value false, or until the end of the array.
     * @returns { boolean } True if the predicate returns true for all elements in the array; otherwise, false.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override every(predicate: (value: T, index: int, array: Array<T>) => boolean): boolean {
        let curArrLength = this.actualLength
        for (let i = 0; i < curArrLength && i < this.actualLength; i++) {
            if (!predicate(this.$_get_unsafe(i), i, this)) {
                return false
            }
        }
        return true;
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *

     * @param { function } predicate A function that accepts up to three arguments. The some method calls the predicate
     *     function for each element in the array until the predicate returns a value which is
     *     coercible to the Boolean value true, or until the end of the array.
     * @returns { boolean } True if the predicate returns true for at least one element in the array; otherwise, false.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override some(predicate: (value: T, index: int, array: Array<T>) => boolean): boolean {
        const len = this.actualLength
        for (let i = 0; i < len && i < this.actualLength; i++) {
            if (predicate(this.$_get_unsafe(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Iterates the array in reverse order and returns the index of the first element that satisfies the provided
     * testing function. If no elements satisfy the testing function, -1 is returned.
     *

     * @param { function } predicate A function to execute on each value in the array.
     * @returns { int } The index of the first element that satisfies the provided testing function; otherwise, -1.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override findLastIndex(predicate: (element: T, index: int, array: Array<T>) => boolean): int {
        for (let i = this.actualLength - 1; i >= 0 && i < this.actualLength; i--) {
            if (predicate(this.$_get_unsafe(i), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function
     * is the accumulated result, and is provided as an argument in the next call to the callback function.
     *

     * @param { function } callbackfn A function that accepts up to four arguments. The reduce method calls the
     *     callbackfn function one time for each element in the array.
     * @returns { T } The accumulated result.
     * @throws { TypeError } Throws a TypeError if the array is empty and no initial value is provided.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override reduce(callbackfn: (previousValue: T, currentValue: T, index: int, array: Array<T>) => T): T {
        if (this.actualLength == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }
        let acc: T = this.$_get_unsafe(0);
        const len = this.actualLength
        for (let i = 1; i < len && i < this.actualLength; i++) {
            acc = callbackfn(acc, this.$_get_unsafe(i), i, this)
        }
        return acc
    }

    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function
     * is the accumulated result, and is provided as an argument in the next call to the callback function.
     *

     * @param { function } callbackfn A function that accepts up to four arguments. The reduce method calls the
     *     callbackfn function one time for each element in the array.
     * @param { U } initialValue The initial value of the accumulator.
     * @returns { U } The accumulated result.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override reduce<U = T>(callbackfn: (previousValue: U, currentValue: T, index: int, array: Array<T>) => U, initialValue: U): U {
        let acc = initialValue
        const len = this.actualLength
        for (let i = 0; i < len && i < this.actualLength; i++) {
            acc = callbackfn(acc, this.$_get_unsafe(i), i, this)
        }
        return acc
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of
     * the callback function is the accumulated result, and is provided as an argument in the next call to the callback
     * function.

     * @param { function } callbackfn A function that accepts up to four arguments. The reduceRight method calls the
     *     callbackfn function one time for each element in the array.
     * @param { U } initialValue The initial value of the accumulator.
     * @returns { U } The accumulated result.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, index: int, array: Array<T>) => U, initialValue: U): U {
        let acc = initialValue
        for (let i = this.actualLength - 1; i >= 0; i--) {
            if (i < this.actualLength) {
                acc = callbackfn(acc, this.$_get_unsafe(i), i, this)
            }
        }
        return acc
    }

    /**
     * Performs the specified action for each element in an array.
     *

     * @param { function } callbackfn A function that accepts up to three arguments. forEach calls the callbackfn
     *     function one time for each element in the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override forEach(callbackfn: (value: T, index: int, array: Array<T>) => void): void {
        const len0 = this.actualLength;
        for (let i = 0; i < len0 && i < this.actualLength; i++) {
            if (i >= this.actualLength) {
                break
            }
            callbackfn(this.$_get_unsafe(i), i, this)
        }
    }

    /**
     * Returns a copy of a section of an array.
     *

     * @param { int } start The beginning index of the specified portion of the array.
     * @returns { Array<T> } A new Array object containing the extracted elements.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(start: int): Array<T> {
        return this.slice(start, Int.MAX_VALUE);
    }

    /**
     * Returns a copy of a section of an array.
     *

     * @param { int } [start] The beginning index of the specified portion of the array.
     * @param { int } [end] The end index of the specified portion of the array. The slice includes elements up to but not
     *     including the end index.
     * @returns { Array<T> } A new Array object containing the extracted elements.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(start?: int, end?: int): Array<T> {
        const len: int = this.actualLength;
        const relStart = normalizeIndex(start ?? 0, len)
        const relEnd = normalizeIndex(end ?? len, len)

        let count = relEnd - relStart;
        if (count < 0) {
            count = 0;
        }
        let res : FixedArray<Any> = new FixedArray<Any>(count)
        copyToFast(this.buffer, res, 0, relStart, relStart + count);
        return new Array<T>(FROM_BUFFER, res)
    }

    /**
     * Returns the last index at which a given element can be found in the array,
     * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
     *
     * @param buffer Array's underlying buffer.
     *
     * @param actualLength Array's underlying length, might be greater than buffer's length.
     *
     * @param searchElement element to locate in the array.
     *
     * @param fromIndex zero-based index at which to start searching backwards.
     * Negative index counts back from the end of the array  if `fromIndex` < 0, `fromIndex` + `length()` is used.
     * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
     * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
     * If `fromIndex` is undefined then `fromIndex = 0`.
     * If `fromIndex` is ommited then `fromIndex = length()-1`.
     *
     * @returns The last index of the element in the array; -1 if not found.
     */
    private static native lastIndexOfImpl<T>(buffer: FixedArray<Any>, actualLength: int, searchElement: T, fromIndex: int): int;

    /**
     * Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array
     * is searched backwards.
     *

     * @param { T } searchElement The element to locate in the array.
     * @returns { int } The last index of the element in the array; -1 if not found.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: T): int {
        return Array.lastIndexOfImpl(this.buffer, this.actualLength, searchElement, this.actualLength - 1)
    }

    /**
     * Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array
     * is searched backwards, starting at fromIndex.
     *

     * @param { T } searchElement The element to locate in the array.
     * @param { int } [fromIndex] The index at which to start searching backwards.
     * @returns { int } The last index of the element in the array; -1 if not found.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: T, fromIndex?: int): int {
        return Array.lastIndexOfImpl(this.buffer, this.actualLength, searchElement, fromIndex ?? 0)
    }

    private isPrimitive(element: T): boolean {
        return (element instanceof String ||
                element instanceof Int ||
                element instanceof Number ||
                element instanceof Float ||
                element instanceof Long ||
                element instanceof Short ||
                element instanceof Boolean ||
                element instanceof Char ||
                element instanceof Byte ||
                element == null);
    }
    private static native joinInternal(buffer: FixedArray<Any>, actualLength: int, sep: string): string;

    private joinObject(arr: Array<T>, visited: Set<Array<T>>, result: StringBuilder, sep?: String): void {
        let length = arr.length
        if (length == 0 || visited.has(arr)) {
            return
        }
        visited.add(arr)
        const sepReal = sep === undefined ? "," : sep!
        const first_el = arr[0]
        if (first_el != null) {
            if (first_el instanceof Array) {
                this.joinObject(first_el as Array<T>, visited, result)
            } else {
                result.append(new String(first_el))
            }
        }
        for (let i: int = 1; i < length; i++) {
            result.append(sepReal)
            const tmp = arr[i]
            if (tmp == null) {
                continue
            }
            if (tmp instanceof Array) {
                this.joinObject(tmp as Array<T>, visited, result)
            } else {
                result.append(new String(tmp))
            }
        }
        visited.delete(arr)
    }

    /**
     * Creates and returns a new string by concatenating all of the elements in an `Array`, separated by a specified
     * separator string.
     *

     * @param { String } [sep] A string to separate each pair of adjacent elements of the array. If omitted, the array
     *     elements are separated with a comma.
     * @returns { string } A string with all array elements joined.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override join(sep?: String): string {
        if (this.actualLength == 0) {
            return ""
        }

        let objArray: boolean = false;
        for (let i: int = 0; i < this.actualLength; i++) {
            const element = this.$_get_unsafe(i);
            if (!this.isPrimitive(element)) {
                objArray = true;
                break;
            }
        }

        if (objArray) {
            const visited: Set<Array<T>> = new Set<Array<T>>()
            const result: StringBuilder = new StringBuilder()
            this.joinObject(this, visited, result, sep)
            return result.toString()
        }

        return Array.joinInternal(this.buffer, this.actualLength, sep === undefined ? "," : sep!);
    }

    /**
     * Returns a string representing the specified array and its elements.
     *

     * @returns { string } A string representing the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override toString(): string {
        return this.join(",");
    }

    /**
     * Returns a string representing the elements of the array. The elements are converted to Strings using their
     * toLocaleString methods.
     *

     * @param { Object } locales A string with a BCP 47 language tag, or an array of such strings.
     * @param { Object } options An object with configuration properties.
     * @returns { string } A string representing the elements of the array.
     * @throws { Error } Throws an Error if the method is not implemented.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Array.toLocaleString: not implemented")
    }

    /**
     * Returns a string representing the elements of the array. The elements are converted to Strings using their
     * toLocaleString methods.
     *

     * @param { Object } locales A string with a BCP 47 language tag, or an array of such strings.
     * @returns { string } A string representing the elements of the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Returns a string representing the elements of the array. The elements are converted to Strings using their
     * toLocaleString methods.
     *

     * @returns { string } A string representing the elements of the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override toLocaleString(): string {
        const sb = new StringBuilder()
        const len = this.actualLength;
        for (let i = 0; i < len; i++) {
            if (i != 0) {
                sb.append(",")
            }
            let x = this.$_get_unsafe(i) as Any;
            if ((null !== x) && (undefined !== x)) {
                sb.append((x! as object).toLocaleString()) // #26217
            }
        }
        return sb.toString()
    }

    /**
     * Returns a new array with some elements removed and/or replaced at a given index.
     *

     * @param { int } start The zero-based index at which to start changing the array.
     * @returns { Array<T> } A new array with the changes applied.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toSpliced(start: int): Array<T> {
        return this.toSpliced(start, this.actualLength)
    }

    /**
     * Returns a new array with some elements removed and/or replaced at a given index.
     *

     * @param { int } start The zero-based index at which to start changing the array.
     * @param { int } delete The number of elements to remove.
     * @param { FixedArray<T> } items The elements to add to the array.
     * @returns { Array<T> } A new array with the changes applied.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toSpliced(start: int, delete: int, ...items: FixedArray<T>): Array<T> {
        const len = this.actualLength;
        start = normalizeIndex(start, len);
        if (delete < 0) {
            delete = 0;
        } else if (delete > len) {
            delete = len;
        }
        if (start > len - delete) {
            delete = len - start
        }
        const res : FixedArray<Any> = new FixedArray<Any>(len - delete + items.length);
        for (let i = 0; i < start; i++) {
            res[i] = this.$_get_unsafe(i)
        }
        for (let i = 0; i < items.length; i++) {
            res[start + i] = items[i]
        }
        for (let i = start + delete; i < len; i++) {
            res[i - delete + items.length] = this.$_get_unsafe(i)
        }
        return new Array<T>(FROM_BUFFER, res);
    }

    /**
     * Returns a new array with some elements removed and/or replaced at a given index.
     *

     * @param { int } [start] The zero-based index at which to start changing the array.
     * @param { int } [delete] The number of elements to remove.
     * @returns { Array<T> } A new array with the changes applied.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toSpliced(start?: int, delete?: int): Array<T> {
        const len = this.actualLength;
        return this.toSpliced(asIntOrDefault(start, len), asIntOrDefault(delete, len))
    }

    /**
     * Determines whether an array includes a certain value among its entries, returning true or false as appropriate.
     *

     * @param { T } val The value to search for.
     * @param { int } [fromIndex] The position in this array at which to begin searching for value.
     * @returns { boolean } True if the value is found, false otherwise.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override includes(val: T, fromIndex?: int): boolean {
        const len = this.actualLength;
        const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
        if (val instanceof String) {
            return this.searchString(val, fi, len)
        } else if (val instanceof Double) {
            return this.searchDouble(val, fi, len)
        } else if (val instanceof Float) {
            return this.searchFloat(val, fi, len)
        } else if (val instanceof Long) {
            return this.searchLong(val, fi, len)
        } else if (val instanceof Int) {
            return this.searchInt(val, fi, len)
        } else if (val === undefined) {
            return this.searchUndefined(fi, len)
        } else if (val == null) {
            return this.searchNull(fi, len)
        } else {
            return this.searchCommon(val, fi, len)
        }
    }

    /**
     * Returns the first index at which a given element can be found in the array, or -1 if it is not present.
     *

     * @param { T } val The element to locate in the array.
     * @returns { int } The first index of the element in the array; -1 if not found.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private static native indexOfImpl<T>(buffer: FixedArray<Any>, actualLength: int, val: T, fromIndex: int): int;

    public indexOf(val: T): int {
        return Array.indexOfImpl(this.buffer, this.actualLength, val, 0)
    }

    /**
     * Returns the first index at which a given element can be found in the array, or -1 if it is not present.
     *

     * @param { T } val The element to locate in the array.
     * @param { int } [fromIndex] The index to start the search at.
     * @returns { int } The first index of the element in the array; -1 if not found.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override indexOf(val: T, fromIndex?: int): int {
        return Array.indexOfImpl(this.buffer, this.actualLength, val, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns a new array with the elements sorted in ascending order.
     *

     * @returns { Array<T> } A new sorted array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toSorted(): Array<T> {
        let arr = new Array<T>(FROM_BUFFER, this.copyArray());
        arr.sort()
        return arr
    }

    /**
     * Returns a new array with the elements sorted using the provided comparator function.
     *

     * @param { function } comparator A function that defines the sort order.
     * @returns { Array<T> } A new sorted array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toSorted(comparator: (a: T, b: T) => int): Array<T> {
        let arr = new Array<T>(FROM_BUFFER, this.copyArray());
        arr.sort(comparator)
        return arr
    }

    /**
     * Reverses an array in place. The first array element becomes the last, and the last array element becomes the
     * first.
     *

     * @returns { this } The reversed array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reverse(): this {
    /* otherwise the result will be exactly the same as it is */
        if (this.actualLength > 1) {
            Array.reverseImpl(this.buffer, this.actualLength)
        }

        return this
    }

    private static native reverseImpl(buffer: FixedArray<Any>, actualLength: int): void;

    /**
     * Returns a new array with the elements in reversed order.
     *

     * @returns { Array<T> } A new reversed array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toReversed(): Array<T> {
        let arr : FixedArray<Any> = new FixedArray<Any>(this.actualLength)
        for (let i = 0; i < this.actualLength; i++) {
            arr[this.actualLength - 1 - i] = this.$_get_unsafe(i)
        }
        return new Array<T>(FROM_BUFFER, arr)
    }

    /**
     * Returns a new Array with the element at the given index replaced with the given value.
     *

     * @param { int } index The zero-based index at which to replace the value.
     * @param { T } value The new value to insert at the given index.
     * @returns { Array<T> } A new array with the element replaced.
     * @throws { RangeError } If the index is out of bounds.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: T): Array<T> {
        if (index < 0) {
            index += this.actualLength;
        }
        if (index < 0 || index >= this.actualLength) {
            throw new RangeError("Invalid index")
        }
        let arr = new Array<T>(FROM_BUFFER, this.copyArray());
        arr.$_set_unsafe(index, value);
        return arr
    }

    /**
     * Returns a new Array Iterator object that contains the values for each index in the array.
     *

     * @returns { IterableIterator<T> } A new Array Iterator object.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override values(): IterableIterator<T> {
        return new ArrayValuesIterator_T<T>(this);
    }

    /**
     * Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
     *

     * @returns {IterableIterator<[number, T]> } A new Array Iterator object.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override entries(): IterableIterator<[number, T]> {
        return new ArrayEntriesIterator_T<T>(this);
    }

    /**
     * Creates a new array populated with the results of calling a provided function on every element in the calling
     * array.
     *
     * @param { function } callbackfn Function that is called for every element of the array. Each time callbackfn
     *     executes, the returned value is added to the new array.
     * @returns { Array<U> } A new array with each element being the result of the callback function.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override map<U>(callbackfn: (value: T, index: int, array: Array<T>) => U): Array<U> {
        const len = this.actualLength;
        let res : FixedArray<Any> = new FixedArray<Any>(len);
        for (let i = 0; i < len && i < this.actualLength; i++) {
            res[i] = callbackfn(this.$_get_unsafe(i), i, this);
        }
        return new Array<U>(FROM_BUFFER, res);
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of
     * the callback function is the accumulated result, and is provided as an argument in the next call to the callback
     * function.
     *
     * @param { function } callbackfn A function that accepts up to four arguments. The reduceRight method calls the
     *     callbackfn function one time for each element in the array.
     * @returns { T } The accumulated result.
     * @throws { TypeError } Throws a TypeError if the array is empty and no initial value is provided.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override reduceRight(callbackfn: (previousValue: T, currentValue: T, index: int, array: Array<T>) => T): T {
        if (this.actualLength == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }
        let acc: T = this.$_get_unsafe(this.actualLength - 1);
        for (let i = this.actualLength - 2; i >= 0; i--) {
            if (this.actualLength > i) {
                acc = callbackfn(acc, this.$_get_unsafe(i), i, this)
            }
        }
        return acc
    }

}

/**
 * Copies src array into dst with respect to passed indexes and without setting pre-write barriers.
 * dst must be a newly allocated array with enough space; otherwise out-of-bounds may occur.
 *
 * @param { FixedArray<Any> } src Source array to be copied.
 * @param { FixedArray<Any> } dst Destination array.
 * @param { int } dstStart Index of dst to start from.
 * @param { int } srcStart Index of src to start from.
 * @param { int } srcEnd Last index of src to copy, exclusive (src[srcEnd] is not copied).
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 * @example
 * ```arkts
 * copyToFast(src, dst, 0, 0, src.length)
 * ```
 */
native function copyToFast(src: FixedArray<Any>, dst: FixedArray<Any>, dstStart: int, srcStart: int, srcEnd: int): void;

/**
 * Copies src array into dst with respect to passed indexes and with setting pre-write barriers.
 * dst may be the same as src and must have enough space; otherwise out-of-bounds may occur.
 *
 * @param { FixedArray<Any> } src Source array to be copied.
 * @param { FixedArray<Any> } dst Destination array.
 * @param { int } dstStart Index of dst to start from.
 * @param { int } srcStart Index of src to start from.
 * @param { int } srcEnd Last index of src to copy, exclusive (src[srcEnd] is not copied).
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 * @example
 * ```arkts
 * copyToFastWithBarriers(src, dst, 0, 1, src.length)
 * ```
 */
native function copyToFastWithBarriers(src: FixedArray<Any>, dst: FixedArray<Any>, dstStart: int, srcStart: int, srcEnd: int): void;

/**
 * Tries to get the length of the iterator from an object.
 *
 * @param { Object } obj The object to check for an iterator length.
 * @returns { int | undefined } The length of the iterator if found; otherwise, undefined.
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function tryGetIteratorLength(obj: Object): int | undefined {
    const objCls = Class.of(obj)
    for (const method of objCls.getInstanceMethods()) {
        if (method.getName() == "__Iterator_getLength" && method.getParametersNum() == 0) {
            return method.invoke(obj, []) as int
        }
    }
    return undefined
}

class ArrayValuesIterator_T<T> implements IterableIterator<T> {
    private parent: Array<T>
    private idx: int = 0
    private isDone: boolean = false

    constructor(parent: Array<T>) {
        this.parent = parent
    }

    override next(): IteratorResult<T> {
        if (this.isDone || this.idx >= this.parent.length) {
            this.isDone = true
            return new IteratorResult<T>()
        }
        return new IteratorResult<T>(this.parent[this.idx++])
    }

    override $_iterator(): IterableIterator<T> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length
    }
}

 // NOTE(zaytsevaekaterina): fix in #26615 (num -> int)
class ArrayEntriesIterator_T<T> implements IterableIterator<[number, T]> {
    private parent: Array<T>
    private idx: int = 0
    private isDone: boolean = false

    constructor(parent: Array<T>) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, T]> {
        if (this.isDone || this.idx >= this.parent.length) {
            this.isDone = true
            return new IteratorResult<[number, T]>()
        }
        const i = this.idx++;
        const vl: [number, T] = [i.toDouble(), this.parent[i]]
        return new IteratorResult<[number, T]>(vl);
    }

    override $_iterator(): IterableIterator<[number, T]> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length
    }
}
