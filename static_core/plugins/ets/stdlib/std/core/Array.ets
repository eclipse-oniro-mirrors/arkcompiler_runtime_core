/*
 * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package std.core;

// NOTE: autogenerated file

class ArrayKeysIterator<T> implements IterableIterator<number> {
    private parent: Array<T>
    private idx: int = 0
    private isDone: boolean = false

    constructor(parent: Array<T>) {
        this.parent = parent
    }

    override next(): IteratorResult<number> {
        if (this.isDone || this.idx >= this.parent.length) {
            this.isDone = true
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>((this.idx++).toDouble())
    }

    override $_iterator(): IterableIterator<number> {
        return this
    }
}

class FromBuffer {}
// initialized in _initializerBlock_.ets
const FROM_BUFFER: FromBuffer;

/**
 * Represents JS API-compatible Array
 */

type arrType = String | undefined;

export class Array<T> implements ReadonlyArray<T>, Iterable<T> {
    private buffer: FixedArray<Any>
    protected actualLength: int
    private static INIT_CAPACITY: int = 4

    override get length(): int {
        return this.actualLength
    }

    set length(newLen: int) {
        const len = newLen
        if (len < 0 || len > this.actualLength) {
            throw new RangeError("can't change length to bigger or negative")
        }
        if (len == 0) {
            this.buffer = new Any[Array.INIT_CAPACITY]
        } else {
            const other = this.slice(0, len)
            this.buffer = other.buffer
        }
        this.actualLength = len
    }

    public override native $_get(idx: int): T;

    private final native $_get_unsafe(idx: int): T

    public native $_set(idx: int, val: T): void;

    private final native $_set_unsafe(idx: int, val: T | undefined): void

    /**
     * Creates a new instance of Array
     */
    public constructor(arrayLen: int) {
        this.buffer = new Any[arrayLen]
        this.actualLength = arrayLen
    }

    private constructor(_tag: FromBuffer, buf: FixedArray<Any>) {
        this.buffer = buf
        this.actualLength = buf.length
    }

    public constructor() {
        this.buffer = new Any[Array.INIT_CAPACITY]
        this.actualLength = 0
    }

    /**
     * Creates a new instance of Array based on Object[]
     *
     * @param d Array initializer
     */
    public constructor(first: T, ...d: T[]) {
        this.buffer = new Any[d.length + 1]
        this.actualLength = d.length.toInt() + 1

        this.buffer[0] = first

        for (let k: int = 0; k < d.length; k++) {
            this.$_set_unsafe(k + 1, d[k])
        }
    }

    /**
     * Creates a new instance of Array.
     *
     * @param arrayLen amount of elements.
     *
     * @param initializer custom initialization for each elements.
     *
     * @returns A new Array instance with the specified length
     *
     */
    public constructor(arrayLen: int, initializer: (index: int) => T) {
        this.buffer = new Any[arrayLen]
        this.actualLength = arrayLen
        for (let k: int = 0; k < arrayLen; k++) {
            this.$_set_unsafe(k, initializer(k))
        }
    }

    /**
     * Creates a new instance of Array.
     *
     * @param arrayLength amount of elements.
     *
     * @param initialValue initial value of elements.
     *
     */
    public static create<T>(arrayLength: number, initialValue: T): Array<T> {
        let other = new Array<T>(arrayLength.toInt())
        other.fill(initialValue)
        return other
    }

    /**
     * Extends Array with new elements to specified length.
     *
     * @param arrayLength new length of the array.
     *
     * @param initialValue initial value of added elements.
     *
     */
    public extendTo(arrayLength: int, initialValue: T): void {
        if(arrayLength < 0){
            throw new RangeError("Parameter error.Invalid array length.")
        }
        const delta: int = arrayLength - this.actualLength
        if (delta <= 0) {
            return
        }
        this.ensureUnusedCapacity(delta)
        for (let i: int = 0; i < delta; i++) {
            this.buffer[this.actualLength + i] = initialValue
        }
        this.actualLength = arrayLength
    }

    /**
     * Shrinks Array to specified length.
     *
     * @param arrayLength length at which to shrink.
     *
     */
    public shrinkTo(arrayLength: int): void {
        if(arrayLength < 0){
            throw new RangeError("Parameter error.Invalid array length.")
        }
        if (arrayLength >= this.actualLength) {
            return
        }
        let newLen: int = arrayLength
        if (newLen < 0) {
            // Convert from signed to unsigned
            newLen = newLen & Int.MAX_VALUE
        }
        const other = this.slice(0, newLen)
        this.buffer = other.buffer
        this.actualLength = other.actualLength
    }

    /**
     * Creates a new instance of an Array with the specified length
     *
     * @param arrayLength The length of the array to be created (optional).
     *
     * @returns A new Array instance with the specified length
     */
    static $_invoke<T>(): Array<T> {
        return new Array<T>();
    }

    /**
     * Creates a new instance of an Array with the specified length
     *
     * @param arrayLength The length of the array to be created (optional).
     *
     * @returns A new Array instance with the specified length
     */
    static $_invoke<T>(arrayLength?: number): Array<T> {
        if (arrayLength != undefined) {
            return new Array<T>(arrayLength.toInt());
        } else {
            return new Array<T>();
        }
    }

    /**
     * Creates a new instance of an Array with the specified length
     *
     * @param items array of values.
     *
     * @returns A new Array instance with the specified length
     */
    static $_invoke<T>(...items: T[]): Array<T> {
        if (items.length == 0) {
            return new Array<T>(0)
        }
        return new Array<T>(items[0], ...items.slice(1))
    }

    /**
    * Creates a new `Array` instance from `Object[]` primitive array.
    *
    * @param arr primitive array.
    *
    * @returns `Array` intance constructed from `Object[]` primitive array.
    */
    public static from<T>(arr: FixedArray<T>): Array<T> {
        const len = arr.length
        const ret : FixedArray<Any> = new Any[len.toInt()]
        for (let i: int = 0; i < len; i++) {
            ret[i] = arr[i]
        }
        return new Array<T>(FROM_BUFFER, ret)
    }

    /**
     * Creates a new `Array` instance from `Object[]` ArrayLike.
     *
     * @param arr an iterable object to convert to an array.
     *
     * @returns `Array` intance constructed from `Object[]` ArrayLike.
     */
    public static from<T>(arr: ArrayLike<T>): Array<T> {
        const ret = new Array<T>(arr.length.toInt())
        let i = 0
        iteratorForEach<T>(arr.$_iterator(), (x: T): void => {
            ret[i] = x
            i += 1
        })
        return ret
    }

    /**
     * Creates a new `Array` instance from `Object[]` primitive array.
     *
     * @param iterable an iterable object to convert to an array.
     *
     * @returns `Array` intance constructed from `Object[]` primitive array.
     */
    public static from<T>(iterable: ArrayLike<T> | Iterable<T>): Array<T> {
        const ret = new Array<T>()
        iteratorForEach<T>(iterable.$_iterator(), (x: T): void => {
            ret.push(x)
        })
        return ret
    }

    public static from<T, U>(values: FixedArray<T>, mapfn: (v: T, k: number) => U): Array<U> {
        const ret = new Array<U>(values.length)
        for (let i = 0; i < values.length; ++i) {
            ret[i] = mapfn(values[i], i)
        }
        return ret
    }

    /**
     * Creates a new `Array` instance from `Object[]` primitive array.
     *
     * @param iterable an iterable object to convert to an array.
     *
     * @param mapfn a mapping function to call on every element of the array.
     * Every value to be added to the array is first passed through this function, and `mapfn`'s return value
     * is added to the array instead.
     *
     * @returns `Array` intance constructed from `Object[]` primitive array and given function.
     */
    public static from<T, U>(iterable: ArrayLike<T> | Iterable<T>, mapfn: (v: T, k: number) => U): Array<U> {
        const ret = new Array<U>()
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new int[1]
        idx[0] = 0
        iteratorForEach<T>(iterable.$_iterator(), (x: T): void => {
            ret.push(mapfn(x, idx[0].toDouble()))
            idx[0] += 1
        })
        return ret
    }

    private searchUndefined(fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (this.$_get_unsafe(i) instanceof undefined) {
                return true
            }
        }
        return false
    }

    private searchNull(fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (this.$_get_unsafe(i) instanceof null) {
                return true
            }
        }
        return false
    }

    private searchString(val: String, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof String) {
                if (tmp == val) {
                    return true
                }
            }
        }
        return false
    }

    private searchNumber(val: Number, fi: int, len: int): boolean {
        if (isNaN(val)) {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Number) {
                    if (isNaN(tmp)) {
                        return true
                    }
                }
            }
        } else {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Number) {
                    if (val == tmp) {
                        return true
                    }
                }
            }
        }
        return false
    }

    private searchFloat(val: Float, fi: int, len: int): boolean {
        if (isNaN(val)) {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Float) {
                    if (isNaN(tmp)) {
                        return true
                    }
                }
            }
        } else {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Float) {
                    if (val == tmp) {
                        return true
                    }
                }
            }
        }
        return false
    }

    private searchLong(val: Long, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Long) {
                if (tmp == val) {
                    return true
                }
            }
        }
        return false
    }

    private searchInt(val: Int, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Int) {
                if (tmp == val) {
                    return true
                }
            }
        }
        return false
    }

    private searchCommon(val: T, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (val == this.$_get_unsafe(i)) {
                return true;
            }
        }
        return false
    }

    /**
     * Default comparison function for sort algorithm.
     * Objects are compared as string. Both objects are convereted to string
     * using `toString()` method and compared using `compareTo() method of `string` class.
     *
     * @param a: Object - Object to be compared
     *
     * @param b: Object - Object to be compared
     *
     * @returns Returns one of values -1, 0, 1 (_less_, _equal_, _greater_ respectively).
     */
    private static defaultComparator(a: Any, b: Any): number {
        if (a instanceof Number && b instanceof Number) {
            const x = a
            const y = b
            if (Number.isInteger(x) && Number.isInteger(y) &&
                x <= Int.MAX_VALUE / 128 && x >= Int.MIN_VALUE / 128 &&
                y <= Int.MAX_VALUE / 128 && y >= Int.MIN_VALUE / 128) {
                let z = x.toInt()
                let w = y.toInt()
                return Array.defaultComparatorInts(z, w)
            }
        } else if (a instanceof String && b instanceof String) {
            return a.compareTo(b)
        }
        let sa = new String(a)
        let sb = new String(b)
        return sa.compareTo(sb)
    }

    private static defaultComparatorInts(a: int, b: int): number {
        if (a < 0) {
            if (b >= 0) {
                return -1
            }
            a *= -1
            b *= -1
        } else if (b < 0) {
            return 1
        }
        let aDigs = 1
        while (10 * aDigs <= a) {
            aDigs *= 10
        }
        let bDigs = 1
        while (10 * bDigs <= b) {
            bDigs *= 10
        }

        while (aDigs > 0 && bDigs > 0) {
            let r = (a / aDigs) - (b / bDigs)
            if (r != 0) {
                return r
            }
            aDigs /= 10
            bDigs /= 10
        }
        return (aDigs - bDigs)
    }

    private static defaultComparatorStr(a: String, b: String) {
        return a.compareTo(b)
    }

    /**
     * Helper function preparing copy of `this` instance of `Array` class' data array.
     *
     * @returns Copy of an `Array`'s primitive array data.
     */
    private copyArray(): FixedArray<Any> {
        let len: int = this.actualLength
        let res : FixedArray<Any> = new Any[len]
        for (let i = 0; i < len; i++) {
            res[i] = this.$_get_unsafe(i)
        }
        return res
    }

    private wrap_default_sort(): void {
        let idxNonUndef = 0
        try {
            let strArr : FixedArray<arrType> = new arrType[this.actualLength]
            for (let i = 0; i < this.actualLength; i++) {
                const vl = this.$_get_unsafe(i)
                if (vl !== undefined) {
                    if (vl == null) {
                        this.$_set_unsafe(idxNonUndef, vl as T)
                        strArr[idxNonUndef] = "null"
                    } else {
                        this.$_set_unsafe(idxNonUndef, vl)
                        strArr[idxNonUndef] = (vl as object).toString() // #26217
                    }
                    idxNonUndef++
                }
            }
            let sortTo = idxNonUndef
            for (let i = idxNonUndef; i < this.actualLength; i++) {
                this.$_set_unsafe(i, undefined as T)
            }

            sort_default<Any>(this.buffer, strArr, 0, sortTo)
        }
        catch (e) {
            if (e instanceof OutOfMemoryError) {
                this.slow_default_sort()
            } else {
                throw e as Error
            }
        }
    }

    private slow_default_sort(): void {
        let idxNonUndef = 0
        const cmp: (l: Any, r: Any) => number = (l: Any, r: Any): number => {
            return Array.defaultComparator(l, r)
        }
        for (let i = 0; i < this.actualLength; i++) {
            const vl = this.$_get_unsafe(i)
            if (vl !== undefined) {
                this.$_set_unsafe(idxNonUndef, vl)
                idxNonUndef++
            }
        }
        let sortTo: int = idxNonUndef
        for (let i = idxNonUndef; i < this.actualLength; i++) {
            this.$_set_unsafe(i, undefined as T)
        }
        sort_stable<Any>(this.buffer, 0, sortTo, cmp)
    }

    private move_undefined_end(): int {
        let writeIndex: int = 0
        for (let i = 0; i < this.actualLength; i++) {
            let val = this.$_get_unsafe(i)
            if (val !== undefined) {
                if(writeIndex != i) {
                    this.$_set_unsafe(writeIndex, val)
                }
                writeIndex++
            }
        }
        for (let i = writeIndex; i < this.actualLength; i++) {
            this.$_set_unsafe(i, undefined as T)
        }
        return writeIndex
    }

    /**
     * Reorders elements of `this` using comparator function.
     *
     * @see ECMA-262, 23.1.3.30
     *
     * @param comparator function that defines the sort order.
     *
     * @returns `this` instance of `Array` class.
     *
     * @note Mutating method
     *
     * NOTE clarify UTF-16 or UTF-8
     */
    public sort(comparator?: (a: T, b: T) => number): this {
        if (this.actualLength <= 1)
            return this

        if (comparator == undefined) {
            this.wrap_default_sort()
            return this
        }

        const compareTo: int = this.move_undefined_end()
        let cmp: (l: Any, r: Any) => number = (l: Any, r: Any): number => {
            return comparator!(l as T, r as T)
        }
        sort_stable<Any>(this.buffer, 0, compareTo, cmp)
        return this
    }

    /**
     * Removes the first element from an array and returns that removed element.
     * This method changes the length of the array.
     *
     * @returns shifted element, i.e. that was at index zero
     */
    public shift(): T | undefined {
        const len: int = this.actualLength
        if(len == 0) {
            return undefined
        }
        let obj: T = this.$_get_unsafe(0)
        copyToFastWithBarriers(this.buffer, this.buffer, 0, 1, len)
        this.popImpl()
        return obj
    }

    /**
     * Removes the last element from an array and returns that element.
     * This method changes the length of the array.
     *
     * @returns removed element
     */
    public pop(): T | undefined {
        const len: int = this.actualLength
        if(len == 0) {
            return undefined
        }
        let obj: T = this.$_get_unsafe(len - 1)
        this.popImpl()
        return obj
    }

    private popImpl(): void {
        const index: int = this.actualLength - 1
        this.$_set_unsafe(index, undefined)
        this.actualLength = index
    }

    /**
     * Adds the specified elements to the end of an array and returns the new length of the array.
     *
     * @returns new length
     */
    public pushArray(...val: T[]): int {
        this.ensureUnusedCapacity(val.length.toInt())
        for (let i = 0; i < val.length; i++) {
            this.buffer[this.actualLength + i] = val[i]
        }
        this.actualLength += val.length.toInt()
        return this.actualLength
    }

    /**
     * Adds the specified element to the end of an array and returns the new length of the array.
     *
     * @returns new length
     */
    public pushOne(val: T): int {
        this.ensureUnusedCapacity(1)
        this.buffer[this.actualLength] = val
        this.actualLength += 1
        return this.actualLength
    }

    overload push{ pushOne, pushArray }

    private ensureUnusedCapacity(cap: int): void {
        if (this.actualLength + cap > this.buffer.length) {
            const copy : FixedArray<Any> = new Any[this.buffer.length * 2 + cap]
            for (let i = 0; i < this.actualLength; i++) {
                copy[i] = this.buffer[i]
            }
            this.buffer = copy
        }
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements
     * and/or adding new elements in place.
     *
     * @param start index
     *
     * @param delete number of items after start index
     *
     * @returns an Array with deleted elements
     */
    public splice(start: int, delete: int | undefined, ...items: T[]): Array<T> {
        if (delete === undefined) {
            delete = 0
        }
        start = normalizeIndex(start, this.actualLength)
        if (delete < 0) {
            delete = 0
        }
        if (start > this.actualLength - delete) {
            delete = this.actualLength - start
        }
        // this: [left middle right], we must replace middle with `items`

        const itemsLength = items.length
        this.ensureUnusedCapacity(itemsLength - delete)
        const oldLen = this.actualLength
        const newLen = this.actualLength - delete + itemsLength
        // Extend `actualLength` to ensure correct operations.
        // Note that shrinking the array will lead to incorrect behavior
        if (newLen > oldLen) {
            this.actualLength = newLen
        }

        let ret = new Array<T>(delete)
        // left part remains unchanged
        // copy excluded part
        for (let i = 0; i < delete; i++) {
            ret.$_set_unsafe(i, this.$_get_unsafe(start + i))
        }
        // move right part to the right of the buffer
        const rightLen = oldLen - start - delete
        if (itemsLength > delete) {
            for (let i = 0; i < rightLen; i++) {
                // This operation is correct because `actualLength` was extended before
                this.$_set_unsafe(newLen - 1 - i, this.$_get_unsafe(oldLen - 1 - i))
            }
        } else {
            for (let i = 0; i < rightLen; i++) {
                this.$_set_unsafe(start + itemsLength + i, this.$_get_unsafe(start + delete + i))
            }
            for (let i = newLen; i < oldLen; i++) {
                this.$_set_unsafe(i, undefined)
            }
        }
        // insert middle part
        for (let i = 0; i < itemsLength; i++) {
            this.$_set_unsafe(start + i, items.$_get_unsafe(i))
        }
        // Update length in the end to ensure correct `this` operations
        this.actualLength = newLen
        return ret
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements
     * and/or adding new elements in place.
     *
     * @param start index
     *
     * @returns an Array with deleted elements from start to the last element of the current instance
     */
    public splice(start: int): Array<T> {
        return this.splice(start, this.actualLength)
    }

    /**
     * Checks whether the passed value is an Array.
     *
     * @param arr
     *
     * @returns true is arr is a non-nullish array, false otherwise
     */
    public static isArray(o: Any): boolean {
        return o instanceof Array
    }

    /**
     * Creates a new Array instance from a variable number of arguments,
     * regardless of number or type of the arguments.
     *
     * @param values an initilizer
     *
     * @returns a newly created Array
     */
    public static of<T>(...values: T[]): Array<T> {
        const ret = new Array<T>()
        ret.ensureUnusedCapacity(values.length.toInt())
        for (let i = 0; i < values.length; i++) {
            ret.push(values[i])
        }
        return ret
    }

    /**
     * Adds the specified elements to the beginning of an Array
     * and returns the new length of the Array.
     *
     * @param values data to be added
     *
     * @returns new length of the Array
     */
    public unshift(...values: T[]): int {
        if (this.buffer.length <= values.actualLength + this.actualLength) {
            let buffer: FixedArray<Any> = new Any[this.buffer.length * 2 + values.actualLength]
            Array.unshiftInternal(this.buffer, this.actualLength, buffer, values)
            this.buffer = buffer
        } else {
            Array.unshiftInternal(this.buffer, this.actualLength, this.buffer, values)
        }

        this.actualLength += values.actualLength
        return this.actualLength
    }

    private static native unshiftInternal<T>(self: FixedArray<Any>, selfLen: int, buffer: FixedArray<Any>, values: Array<T>): void

    /**
     * Returns an iterator over all indices
     */
    public override keys(): IterableIterator<Number> {
        return new ArrayKeysIterator<T>(this)
    }

    /**
     * Returns an iterator over all values
     */
    public override $_iterator(): IterableIterator<T> {
        return this.values()
    }

    // === methods with uncompatible implementation ===
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     *
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     *
     * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
     */
    public override filter(predicate: (value: T, index: int, array: Array<T>) => boolean): Array<T> {
        const res = new Array<T>()
        const len = this.actualLength
        for (let i: int = 0; i < len && i < this.actualLength; i++) {
            const val = this.$_get_unsafe(i)
            if (predicate(val, i, this)) {
                res.push(val)
            }
        }
        return res
    }

    /**
     * Creates a new Array with all sub-array elements concatenated
     * into it recursively up to the specified depth.
     *
     * @param depth
     *
     * @returns a flattened Array with respect to depth
     */
    public flat<U = T>(depth: int): Array<U> {
        let ret = new Array<U>()
        this.flatImpl<U>(depth, ret)
        return ret
    }

    /**
     * Determines whether obj is exactly an instance of the std.core.Array class.
     *
     * @param obj
     *
     * @return true if obj is an instance of std.core.Array and false otherwise.
     */
    private static native isPlatformArray(obj: Object): boolean

    /**
     * Returns the buffer from an instance arr of the std.core.Array class. We must be sure obj is an
     * instance of std.core.Array, the isPlatfromArray(obj: Object) method may be used for this.
     *
     * @param obj
     *
     * @return a reference to the (obj as Array<T>).buffer field.
     */
    private static native getBuffer(obj: Object): FixedArray<Any>;

    /**
     * Creates a new `Array` from this `Array` instance and given `Array` instance.
     *
     * @param other to concatenate into a new array.
     *
     * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
     */
    public concat(...items: FixedArray<ConcatArray<T>>): Array<T> {
        let totalAdd = this.actualLength;
        for (let i = 0; i < items.length; i++) {
            totalAdd += items[i].length.toInt()
        }

        const buf : FixedArray<Any> = new Any[totalAdd];
        copyTo(this.buffer, buf, 0, 0, this.actualLength)

        let insertTo = this.actualLength;
        for (let i = 0; i < items.length; i++) {
            const arr = items[i]
            const len = arr.length.toInt()
            if (Array.isPlatformArray(arr)) {
                copyTo(Array.getBuffer(arr), buf, insertTo, 0, len)
                insertTo += len
            } else {
                for (let j = 0; j < len; j++) {
                    buf[insertTo++] = arr.$_get(j)
                }
            }
        }

        return new Array<T>(FROM_BUFFER, buf);
    }

    private flatImpl<U>(depth: int, to: Array<U>) {
        for (let i = 0; i < this.actualLength; i++) {
            let element = this.buffer[i]
            if (depth > 0 && element instanceof Array) {
                let subArray = (element as Array<T>).flat<U>(depth - 1)
                for (let j = 0; j < subArray.length; j++) {
                    to.push(subArray[j] as U)
                }
            } else {
                to.push(element as U)
            }
        }
    }

    /**
     * Creates a new Array with all sub-array elements concatenated
     *
     * @returns a flattened Array
     */
    public flat<U = T>(): Array<U> {
        return this.flat<U>(1)
    }

    /**
     * Applies flat and than map
     *
     * fn a function to apply
     *
     * @return new Array after map and than flat
     */
    // NOTE(ivan-tyulyandin): TBD, flatMap may be not subset, see ReadonlyArray
    public flatMap<U>(fn: (v: T, k: int, arr: Array<T>) => U): Array<U> {
        let mapped: Array<U> = this.map<U>(fn)
        return mapped.flat<U>()
    }

    // === methods common among all arrays ===

    /**
     * Takes an integer value and returns the item at that index,
     * allowing for positive and negative integers. Negative integers count back
     * from the last item in the array.
     *
     * @param index Zero-based index of the array element to be returned.
     * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
     *
     * @returns The element in the array matching the given index.
     * Throw range error if `index` < `-length()` or `index` >= `length()`.
     */
    public override at(index: int): T {
        let len = this.actualLength;
        let k: int;
        if (index >= 0) {
            k = index;
        } else {
            k = len + index;
        }

        if (k < 0 || k >= len) {
            throw new RangeError("Invalid index");
        }

        return this.$_get_unsafe(k);
    }

    /**
     * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
     *
     * @param target index at which to copy the sequence
     *
     * @returns this array after transformation
     */
    public copyWithin(target: int): this {
        this.copyWithin(target, 0, this.actualLength);
        return this;
    }

    /**
     * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
     *
     * @param target index at which to copy the sequence
     *
     * @param start index at which to start copying elements from
     *
     * @returns this array after transformation
     */
    public copyWithin(target: int, start: int): this {
        this.copyWithin(target, start, this.actualLength);
        return this;
    }

    /**
     * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
     *
     * @param target index at which to copy the sequence
     *
     * @param start index at which to start copying elements from
     *
     * @param end index at which to end copying elements from
     *
     * @returns this array after transformation
     */
    public copyWithin(target: int, start: int, end?: int): this {
        target = normalizeIndex(target, this.actualLength)
        start = normalizeIndex(start, this.actualLength)
        end = normalizeIndex(end ?? this.actualLength, this.actualLength)

        if (end <= start) {
            return this;
        }

        if (target <= start) {
            while (start < end) {
                const read = this.$_get_unsafe(start++);
                this.$_set_unsafe(target++, read);
            }
        } else {
            let len = end - start;
            if (target + len > this.actualLength) {
                len = this.actualLength - target
            }
            for (let i = 0; i < len; i++) {
                const read = this.$_get_unsafe(start + len - 1 - i);
                this.$_set_unsafe(target + len - 1 - i, read);
            }
        }

        return this;
    }

    /**
     * Changes all elements in the Array to a static value, from a start index to an end index
     *
     * @param value to fill the array with
     *
     * @param start index at which to start filling
     *
     * @param end index at which to end filling, but not including
     *
     * @returns this array after transformation
     */
    public fill(value: T, start?: int, end?: int): this {
        Array.fillImpl(this.buffer, this.actualLength, value, start ?? 0, end ?? this.actualLength)
        return this
    }

    private static native fillImpl<T>(buffer: FixedArray<Any>, actualLength: int, value: T, start: int, end: int): void;

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise.
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined.
     *
     * @returns the value of the first element in the array or undefined
     */
    public override find(predicate: (value: T, index: int, array: Array<T>) => boolean): T | undefined {
        const len = this.actualLength
        for (let i = 0; i < len && i < this.actualLength; i++) {
            const val = this.$_get_unsafe(i);
            if (predicate(val, i, this)) {
                return val;
            }
        }
        return undefined;
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise.
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
     *
     * @returns found element index or -1 otherwise
     */
    public override findIndex(predicate: (value: T, index: int, array: Array<T>) => boolean): int {
        const len = this.actualLength
        for (let i = 0; i < len && i < this.actualLength; i++) {
            if (predicate(this.$_get_unsafe(i), i, this)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Iterates the array in reverse order and returns the value of the first element
     * that satisfies the provided testing function
     *
     * @param predicate testing function
     *
     * @returns found element or undefined otherwise
     */
    public override findLast(predicate: (elem: T, index: int, array: Array<T>) => boolean): T | undefined {
        for (let i = this.actualLength - 1; i >= 0 && i < this.actualLength; i--) {
            const val = this.$_get_unsafe(i);
            if (predicate(val, i, this)) {
                return val;
            }
        }
        return undefined;
    }

    /**
     * Determines whether all the members of an array satisfy the specified test.
     *
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     *
     * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
     */
    public override every(predicate: (value: T, index: int, array: Array<T>) => boolean): boolean {
        let curArrLength = this.actualLength
        for (let i = 0; i < curArrLength && i < this.actualLength; i++) {
            if (!predicate(this.$_get_unsafe(i), i, this)) {
                return false
            }
        }
        return true;
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     *
     * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
     */
    public override some(predicate: (value: T, index: int, array: Array<T>) => boolean): boolean {
        const len = this.actualLength
        for (let i = 0; i < len && i < this.actualLength; i++) {
            if (predicate(this.$_get_unsafe(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Iterates the array in reverse order and returns the index of
     * the first element that satisfies the provided testing function.
     * If no elements satisfy the testing function, -1 is returned.
     *
     * @param predicate testing function
     *
     * @returns index of first element satisfying to predicate, -1 if no such element
     */
    public override findLastIndex(predicate: (element: T, index: int, array: Array<T>) => boolean): int {
        for (let i = this.actualLength - 1; i >= 0 && i < this.actualLength; i--) {
            if (predicate(this.$_get_unsafe(i), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @returns a result after applying callbackfn over all elements of the Array
     */
    public override reduce(callbackfn: (previousValue: T, currentValue: T, index: int, array: Array<T>) => T): T {
        if (this.actualLength == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }
        let acc: T = this.$_get_unsafe(0);
        const len = this.actualLength
        for (let i = 1; i < len && i < this.actualLength; i++) {
            acc = callbackfn(acc, this.$_get_unsafe(i), i, this)
        }
        return acc
    }

    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     *
     * @returns a result after applying callbackfn over all elements of the Array
     */
    public override reduce<U = T>(callbackfn: (previousValue: U, currentValue: T, index: int, array: Array<T>) => U, initialValue: U): U {
        let acc = initialValue
        const len = this.actualLength
        for (let i = 0; i < len && i < this.actualLength; i++) {
            acc = callbackfn(acc, this.$_get_unsafe(i), i, this)
        }
        return acc
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     *
     * @returns a result after applying callbackfn over all elements of the Array
     */
    public override reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, index: int, array: Array<T>) => U, initialValue: U): U {
        let acc = initialValue
        for (let i = this.actualLength - 1; i >= 0; i--) {
            if (i < this.actualLength) {
                acc = callbackfn(acc, this.$_get_unsafe(i), i, this)
            }
        }
        return acc
    }

    /**
     * Performs the specified action for each element in an array.
     *
     * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     */
    public override forEach(callbackfn: (value: T, index: int, array: Array<T>) => void): void {
        const len0 = this.actualLength;
        for (let i = 0; i < len0 && i < this.actualLength; i++) {
            if (i >= this.actualLength) {
                break
            }
            callbackfn(this.$_get_unsafe(i), i, this)
        }
    }

    /**
     * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
     * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
     *
     * @param start zero-based index at which to start extraction
     *
     * @returns `Array` instance, constructed from extracted elements of `this` instance.
     */
    public slice(start: int): Array<T> {
        return this.slice(start, Int.MAX_VALUE);
    }

    /**
     * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
     * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
     *
     * @param start zero-based index at which to start extraction
     *
     * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
     *
     * @returns `Array` instance, constructed from extracted elements of `this` instance.
     */
    public slice(start?: int, end?: int): Array<T> {
        const len: int = this.actualLength;
        const relStart = normalizeIndex(start ?? 0, len)
        const relEnd = normalizeIndex(end ?? len, len)

        let count = relEnd - relStart;
        if (count < 0) {
            count = 0;
        }
        let res : FixedArray<Any> = new Any[count]
        copyToFast(this.buffer, res, 0, relStart, relStart + count);
        return new Array<T>(FROM_BUFFER, res)
    }

    /**
     * Returns the last index at which a given element can be found in the array,
     * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
     *
     * @param buffer Array's underlying buffer.
     *
     * @param actualLength Array's underlying length, might be greater than buffer's length.
     *
     * @param searchElement element to locate in the array.
     *
     * @param fromIndex zero-based index at which to start searching backwards.
     * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
     * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
     * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
     * If `fromIndex` is undefined then `fromIndex = 0`.
     * If `fromIndex` is ommited then `fromIndex = length()-1`.
     *
     * @returns The last index of the element in the array; -1 if not found.
     */
    private static native lastIndexOfImpl<T>(buffer: FixedArray<Any>, actualLength: int, searchElement: T, fromIndex: int): int;

    /**
     * Returns the last index at which a given element can be found in the array,
     * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
     *
     * @param searchElement element to locate in the array.
     *
     * @param fromIndex zero-based index at which to start searching backwards.
     * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
     * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
     * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
     * If `fromIndex` is undefined then `fromIndex = 0`.
     * If `fromIndex` is ommited then `fromIndex = length()-1`.
     *
     * @returns The last index of the element in the array; -1 if not found.
     */
    public lastIndexOf(searchElement: T): int {
        return Array.lastIndexOfImpl(this.buffer, this.actualLength, searchElement, this.actualLength - 1)
    }

    /**
     * Returns the last index at which a given element can be found in the array,
     * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
     *
     * @param searchElement element to locate in the array.
     *
     * @param fromIndex zero-based index at which to start searching backwards.
     * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
     * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
     * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
     * If `fromIndex` is undefined then `fromIndex = 0`.
     * If `fromIndex` is ommited then `fromIndex = length()-1`.
     *
     * @returns The last index of the element in the array; -1 if not found.
     */
    public lastIndexOf(searchElement: T, fromIndex?: int): int {
        return Array.lastIndexOfImpl(this.buffer, this.actualLength, searchElement, fromIndex ?? 0)
    }

    private isPrimitive(element: T): boolean {
        return (element instanceof String ||
                element instanceof Int ||
                element instanceof Number ||
                element instanceof Float ||
                element instanceof Long ||
                element instanceof Short ||
                element instanceof Boolean ||
                element instanceof Char ||
                element instanceof Byte ||
                element == null);
    }
    private static native joinInternal(buffer: FixedArray<Any>, actualLength: int, sep: string): string;

    private joinObject(arr: Array<T>, visited: Set<Array<T>>, result: StringBuilder, sep?: String): void {
        let length = arr.length
        if (length == 0 || visited.has(arr)) {
            return
        }
        visited.add(arr)
        const sepReal = sep === undefined ? "," : sep!
        const first_el = arr[0]
        if (first_el != null) {
            if (first_el instanceof Array) {
                this.joinObject(first_el as Array<T>, visited, result)
            } else {
                result.append(new String(first_el))
            }
        }
        for (let i: int = 1; i < length; i++) {
            result.append(sepReal)
            const tmp = arr[i]
            if (tmp == null) {
                continue
            }
            if (tmp instanceof Array) {
                this.joinObject(tmp as Array<T>, visited, result)
            } else {
                result.append(new String(tmp))
            }
        }
        visited.delete(arr)
    }

    /**
     * Creates and returns a new string by concatenating all of the elements in an `Array`,
     * separated by a specified separator string.
     * If the array has only one item, then that item will be returned without using the separator.
     *
     * @param sep specifies a separator
     *
     * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
     */
    public override join(sep?: String): string {
        if (this.actualLength == 0) {
            return ""
        }

        let objArray: boolean = false;
        for (let i: int = 0; i < this.actualLength; i++) {
            const element = this.$_get_unsafe(i);
            if (!this.isPrimitive(element)) {
                objArray = true;
                break;
            }
        }

        if (objArray) {
            const visited: Set<Array<T>> = new Set<Array<T>>()
            const result: StringBuilder = new StringBuilder()
            this.joinObject(this, visited, result, sep)
            return result.toString()
        }

        return Array.joinInternal(this.buffer, this.actualLength, sep === undefined ? "," : sep!);
    }

    /**
     * Returns a string representing the specified array and its elements.
     *
     * @returns string representation
     */
    public override toString(): string {
        return this.join(",");
    }

    /**
     * Returns a locale string representing the specified array and its elements.
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Array.toLocaleString: not implemented")
    }

    /**
     * Returns a locale string representing the specified array and its elements.
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Returns a locale string representing the specified array and its elements.
     *
     * @returns string representation
     */
    public override toLocaleString(): string {
        const sb = new StringBuilder()
        const len = this.actualLength;
        for (let i = 0; i < len; i++) {
            if (i != 0) {
                sb.append(",")
            }
            let x = this.$_get_unsafe(i) as Any;
            if ((null !== x) && (undefined !== x)) {
                sb.append((x! as object).toLocaleString()) // #26217
            }
        }
        return sb.toString()
    }

    /**
     * Copying version of the splice() method.
     *
     * @param start index
     *
     * @returns a new Array with some elements removed and/or replaced at a given index.
     */
    public toSpliced(start: int): Array<T> {
        return this.toSpliced(start, this.actualLength)
    }

    /**
     * Copying version of the splice() method.
     *
     * @param start index
     *
     * @param delete number of items after start index
     *
     * @returns a new Array with some elements removed and/or replaced at a given index.
     */
    public toSpliced(start: int, delete: int, ...items: FixedArray<T>): Array<T> {
        const len = this.actualLength;
        start = normalizeIndex(start, len);
        if (delete < 0) {
            delete = 0;
        } else if (delete > len) {
            delete = len;
        }
        if (start > len - delete) {
            delete = len - start
        }
        const res : FixedArray<Any> = new Any[len - delete + items.length];
        for (let i = 0; i < start; i++) {
            res[i] = this.$_get_unsafe(i)
        }
        for (let i = 0; i < items.length; i++) {
            res[start + i] = items[i]
        }
        for (let i = start + delete; i < len; i++) {
            res[i - delete + items.length] = this.$_get_unsafe(i)
        }
        return new Array<T>(FROM_BUFFER, res);
    }

    /**
     * Copying version of the splice() method.
     *
     * @param start index
     *
     * @param delete number of items after start index
     *
     * @returns a new Array with some elements removed and/or replaced at a given index.
     */
    public toSpliced(start?: int, delete?: int): Array<T> {
        const len = this.actualLength;
        return this.toSpliced(asIntOrDefault(start, len), asIntOrDefault(delete, len))
    }

    /**
     * Checks whether an Array includes a certain value among its entries,
     * returning true or false as appropriate.
     *
     * @param val value to search
     *
     * @param fromIndex start index
     *
     * @returns true if val is in Array
     */
    public override includes(val: T, fromIndex?: int): boolean {
        const len = this.actualLength;
        const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
        if (val instanceof String) {
            return this.searchString(val, fi, len)
        } else if (val instanceof Number) {
            return this.searchNumber(val, fi, len)
        } else if (val instanceof Float) {
            return this.searchFloat(val, fi, len)
        } else if (val instanceof Long) {
            return this.searchLong(val, fi, len)
        } else if (val instanceof Int) {
            return this.searchInt(val, fi, len)
        } else if (val === undefined) {
            return this.searchUndefined(fi, len)
        } else if (val == null) {
            return this.searchNull(fi, len)
        } else {
            return this.searchCommon(val, fi, len)
        }
    }

    /**
     * Returns the first index at which a given element
     * can be found in the array, or -1 if it is not present.
     *
     * @param val value to search
     *
     * @param fromIndex index to search from
     *
     * @returns index of val, -1 otherwise
     */
    private static native indexOfImpl<T>(buffer: FixedArray<Any>, actualLength: int, val: T, fromIndex1: int): int;

    public indexOf(val: T): int {
        return Array.indexOfImpl(this.buffer, this.actualLength, val, 0)
    }

    /**
     * Returns the first index at which a given element
     * can be found in the array, or -1 if it is not present.
     *
     * @param val value to search
     *
     * @param fromIndex index to search from
     *
     * @returns index of val, -1 otherwise
     */
    public override indexOf(val: T, fromIndex?: int): int {
        return Array.indexOfImpl(this.buffer, this.actualLength, val, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Copying version of the sort() method.
     * It returns a new array with the elements sorted in ascending order.
     *
     * @returns sorted copy of hte current instance using default comparator
     */
    public toSorted(): Array<T> {
        let arr = new Array<T>(FROM_BUFFER, this.copyArray());
        arr.sort()
        return arr
    }

    /**
     * Copying version of the sort() method.
     * It returns a new array with the elements sorted in ascending order.
     *
     * @param comparator function to compare to elements of the Array
     *
     * @returns sorted copy of the current instance comparator
     */
    public toSorted(comparator: (a: T, b: T) => number): Array<T> {
        let arr = new Array<T>(FROM_BUFFER, this.copyArray());
        arr.sort(comparator)
        return arr
    }

    /**
     * Modifies `this` instance of `Array` class and populates
     * it with same elements ordered towards the direction opposite to that previously stated.
     *
     * @note Mutating method
     */
    public reverse(): this {
        /* otherwise the result will be exactly the same as it is */
        if (this.actualLength > 1) {
            Array.reverseImpl(this.buffer, this.actualLength)
        }

        return this
    }

    private static native reverseImpl(buffer: FixedArray<Any>, actualLength: int): void;

    /**
     * Copying version of the reverse() method.
     * It returns a new array with the elements in reversed order.
     *
     * @returns reversed copy of the current Array
     */
    public toReversed(): Array<T> {
        let arr : FixedArray<Any> = new Any[this.actualLength]
        for (let i = 0; i < this.actualLength; i++) {
            arr[this.actualLength - 1 - i] = this.$_get_unsafe(i)
        }
        return new Array<T>(FROM_BUFFER, arr)
    }

    /**
     * Copying version of using the bracket notation to change the value of a given index.
     * It returns a new Array with the element at the given index replaced with the given value.
     *
     * @param index to replace
     *
     * @param value new value
     *
     * @returns a new Array with the element at the given index replaced with the given value
     */
    public with(index: int, value: T): Array<T> {
        if (index < 0) {
            index += this.actualLength;
        }
        if (index < 0 || index >= this.actualLength) {
            throw new RangeError("Invalid index")
        }
        let arr = new Array<T>(FROM_BUFFER, this.copyArray());
        arr.$_set_unsafe(index, value);
        return arr
    }

    /**
     * Returns an iterator over all values
     */
    public override values(): IterableIterator<T> {
        return new ArrayValuesIterator_T<T>(this);
    }

    /**
     * Returns an iterable of key, value pairs for every entry in the array
     */
    public override entries(): IterableIterator<[number, T]> {
        return new ArrayEntriesIterator_T<T>(this);
    }

    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     *
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     *
     * @returns `Array` instance, constructed from `this` and given function.
     */
    public override map<U>(callbackfn: (value: T, index: int, array: Array<T>) => U): Array<U> {
        const len = this.actualLength;
        let res : FixedArray<Any> = new Any[len];
        for (let i = 0; i < len && i < this.actualLength; i++) {
            res[i] = callbackfn(this.$_get_unsafe(i), i, this);
        }
        return new Array<U>(FROM_BUFFER, res);
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @returns a result after applying callbackfn over all elements of the Array
     */
    public override reduceRight(callbackfn: (previousValue: T, currentValue: T, index: int, array: Array<T>) => T): T {
        if (this.actualLength == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }
        let acc: T = this.$_get_unsafe(this.actualLength - 1);
        for (let i = this.actualLength - 2; i >= 0; i--) {
            if (this.actualLength > i) {
                acc = callbackfn(acc, this.$_get_unsafe(i), i, this)
            }
        }
        return acc
    }

}

/**
 * copies src array into dst with respect to passed indexes and without setting pre-write barriers.
 * dst must be a new allocated array and have enough space, otherwise out-of-bounds might occur
 *
 * @param src source array to be copied
 *
 * @param dst destination array
 *
 * @param dstStart index of dst to start from
 *
 * @param srcStart index of src to start from
 *
 * @param srcEnd last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 *
 * @example: copy src to dst
 * ```
 * copyToFast(src, dst, 0, 0, src.length)
 * ```
 */
native function copyToFast(src: FixedArray<Any>, dst: FixedArray<Any>, dstStart: int, srcStart: int, srcEnd: int): void;

/**
 * copies src array into dst with respect to passed indexes and with setting pre-write barriers.
 * dst could be the same src array and must have enough space, otherwise out-of-bounds might occur
 *
 * @param src source array to be copied
 *
 * @param dst destination array
 *
 * @param dstStart index of dst to start from
 *
 * @param srcStart index of src to start from
 *
 * @param srcEnd last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 *
 * @example: copy src to dst
 * ```
 * copyToFastWithBarriers(src, dst, 0, 1, src.length)
 * ```
 */
native function copyToFastWithBarriers(src: FixedArray<Any>, dst: FixedArray<Any>, dstStart: int, srcStart: int, srcEnd: int): void;

export function tryGetIteratorLength(obj: Object): int | undefined {
    const objCls = Class.of(obj)
    for (const method of objCls.getInstanceMethods()) {
        if (method.getName() == "__Iterator_getLength" && method.getParametersNum() == 0) {
            return method.invoke(obj, []) as int
        }
    }
    return undefined
}

class ArrayValuesIterator_T<T> implements IterableIterator<T> {
    private parent: Array<T>
    private idx: int = 0
    private isDone: boolean = false

    constructor(parent: Array<T>) {
        this.parent = parent
    }

    override next(): IteratorResult<T> {
        if (this.isDone || this.idx >= this.parent.length) {
            this.isDone = true
            return new IteratorResult<T>()
        }
        return new IteratorResult<T>(this.parent[this.idx++])
    }

    override $_iterator(): IterableIterator<T> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length.toInt()
    }
}

class ArrayEntriesIterator_T<T> implements IterableIterator<[number, T]> {
    private parent: Array<T>
    private idx: int = 0
    private isDone: boolean = false

    constructor(parent: Array<T>) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, T]> {
        if (this.isDone || this.idx >= this.parent.length) {
            this.isDone = true
            return new IteratorResult<[number, T]>()
        }
        const i = this.idx++;
        const vl: [number, T] = [i.toDouble(), this.parent[i]]
        return new IteratorResult<[number, T]>(vl);
    }

    override $_iterator(): IterableIterator<[number, T]> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length.toInt()
    }
}
