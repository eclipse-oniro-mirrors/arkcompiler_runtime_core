/*
 * Copyright (c) 2021-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package std.core;

// NOTE: autogenerated file

function asIntOrDefault(n: Number | undefined, def: int): int {
    if (__runtimeIsSameReference(n, undefined)) {
        return def
    }
    return (n! as Object as Number) as number as int;
}

function normalizeIndex(idx: int, len: int): int {
    if (idx < -len) {
        return 0
    }
    if (idx < 0) {
        return len + idx
    }
    if (idx > len) {
        return len
    }
    return idx
}

// Range is [startIndex, endIndex), i.e. startIndex included and endIndex is excluded
function checkRange(arrLen: int, startIndex: int, endIndex: int): boolean {
    // Since mostly everywhere for loop is used from startIndex till endIndex exclusive,
    // startIndex <= endIndex is used to cover empty array case
    return ((0 <= startIndex) && (startIndex <= endIndex) && (endIndex <= arrLen));
}

native function __alloc_array<T>(len: int, ofType: Object | null): T[]

class BuiltinArrayKeysIterator implements IterableIterator<number> {
    private len: int
    private idx: int = 0

    constructor(len: int) {
        this.len = len
    }

    override next(): IteratorResult<number> {
        if (this.idx >= this.len) {
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>(this.idx++ as number)
    }

    override iterator(): IterableIterator<number> {
        return this
    }
}

function cloneArray(self: boolean[]): boolean[] {
    const ret = new boolean[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: boolean[], index: number): Boolean | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: boolean[], ...items: (boolean | Concatboolean[])[]): boolean[] {
//     throw new Error("not implemented")
// }

export function concat(self: boolean[], ...items: ConcatArray<boolean>[]): boolean[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new boolean[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: boolean[], index: int): Boolean | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: boolean[], target: number, start: number, end?: Number): boolean[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: boolean[], target: int, start: int, end: int): boolean[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: boolean[], target: int, start: int): boolean[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: boolean[], target: int): boolean[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: boolean[], value: boolean, start?: Number, end?: Number): boolean[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: boolean[], value: boolean, start: int, end: int): boolean[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

export function find(self: boolean[], predicate: (value: boolean, i: number, self: boolean[]) => boolean): Boolean | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: boolean[], fn: (value: boolean, i: number, self: boolean[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: boolean[], fn: (elem: boolean, i: number, self: boolean[]) => boolean): Boolean | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: boolean[], fn: (v: boolean, i: number, self: boolean[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: boolean[], fn: (v: boolean, i: number, self: boolean[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: boolean[], fn: (v: boolean, i: number, self: boolean[]) => boolean): boolean[] {
    return filter(self, (v: boolean, i: number): boolean => fn(v, i as number, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: boolean[], fn: (element: boolean, i: number, self: boolean[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: boolean[], fn: (a: boolean, b: boolean, i: number, self: boolean[]) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = boolean>(self: boolean[], fn: (previousValue: U, currentValue: boolean, i: number, self: boolean[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: boolean[], fn: (a: boolean, b: boolean, i: number, self: boolean[]) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: boolean[], fn: (a: U, b: boolean, i: number, self: boolean[]) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: boolean[], fn: (a: boolean, i: number, self: boolean[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number, self)
    }
}

export function find(self: boolean[], predicate: (value: boolean, i: number) => boolean): Boolean | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: boolean[], fn: (value: boolean, i: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: boolean[], fn: (elem: boolean, i: number) => boolean): Boolean | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: boolean[], fn: (v: boolean, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: boolean[], fn: (v: boolean, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: boolean[], fn: (element: boolean, i: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: boolean[], fn: (a: boolean, b: boolean, i: number) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = boolean>(self: boolean[], fn: (previousValue: U, currentValue: boolean, i: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: boolean[], fn: (a: boolean, b: boolean, i: number) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: boolean[], fn: (a: U, b: boolean, i: number) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: boolean[], fn: (a: boolean, i: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number)
    }
}

export function find(self: boolean[], predicate: (value: boolean) => boolean): Boolean | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: boolean[], fn: (value: boolean) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: boolean[], fn: (elem: boolean) => boolean): Boolean | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: boolean[], fn: (v: boolean) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: boolean[], fn: (v: boolean) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: boolean[], fn: (v: boolean) => boolean): boolean[] {
    return filter(self, (v: boolean, i: number): boolean => fn(v));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: boolean[], fn: (element: boolean) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: boolean[], fn: (a: boolean, b: boolean) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = boolean>(self: boolean[], fn: (previousValue: U, currentValue: boolean) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: boolean[], fn: (a: boolean, b: boolean) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: boolean[], fn: (a: U, b: boolean) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: boolean[], fn: (a: boolean) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: boolean[], start?: Number, end?: Number): boolean[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: boolean[], start: int, end: int): boolean[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new boolean[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: boolean[], start: int): boolean[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: boolean[], element: boolean, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: boolean[], element: boolean, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: boolean[], sep?: String): string {
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder();
    for (let i: int = 0; i < self.length; i++) {
        if (i != 0) {
            sb.append(sepReal);
        }
        sb.append(new String(self[i]));
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: boolean[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: boolean[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: boolean[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: boolean[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: boolean[], start?: Number, delete?: Number): boolean[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: boolean[], start: number, delete: number, ...items: boolean[]): boolean[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: boolean[], start: int, delete: int, ...items: boolean[]): boolean[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new boolean[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: boolean[], start: int): boolean[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: boolean[], val: boolean, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: boolean[], val: boolean, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: boolean[], val: boolean, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: boolean[], ): boolean[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: boolean[], comparator: (a: boolean, b: boolean) => number): boolean[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: boolean[], ): boolean[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: boolean[], ): boolean[] {
    let arr = new boolean[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: boolean[], index: number, value: boolean): boolean[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: boolean[], index: int, value: boolean): boolean[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: boolean[], ): IterableIterator<boolean> {
    return new ArrayValuesIterator_boolean(self);
}

/**
 * Returns an iterator over all entries
 */
export function entries(self: boolean[], ): IterableIterator<[number, boolean]> {
    return new ArrayEntriesIterator_boolean(self);
}

/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: boolean[], fn: (value: boolean, i: number, self: boolean[]) => boolean): boolean[] {
    const len = self.length;
    let res = new boolean[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number, self);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: boolean[], fn: (value: boolean, i: number) => boolean): boolean[] {
    const len = self.length;
    let res = new boolean[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: boolean[], fn: (value: boolean) => boolean): boolean[] {
    const len = self.length;
    let res = new boolean[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i]);
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: boolean[], fn: (v: boolean, k: number) => boolean): boolean[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new boolean[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: boolean[], fst: boolean[], ...more: boolean[][]): boolean[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new boolean[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: boolean[], comparator: (a: boolean, b: boolean) => number): boolean[] {
    sort_subarray(self, 0, self.length, (l: boolean, r: boolean): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: boolean[], ): boolean[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: boolean[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_boolean implements IterableIterator<boolean> {
    private parent: boolean[]
    private idx: int = 0

    constructor(parent: boolean[]) {
        this.parent = parent
    }

    override next(): IteratorResult<boolean> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<boolean>()
        }
        return new IteratorResult<boolean>(this.parent[this.idx++])
    }

    override iterator(): IterableIterator<boolean> {
        return this;
    }
}

class ArrayEntriesIterator_boolean implements IterableIterator<[number, boolean]> {
    private parent: boolean[]
    private idx: int = 0

    constructor(parent: boolean[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, boolean]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, boolean]>()
        }
        const i = this.idx++;
        const vl: [number, boolean] = [i as number, this.parent[i]]
        return new IteratorResult<[number, boolean]>(vl);
    }

    override iterator(): IterableIterator<[number, boolean]> {
        return this;
    }
}

function cloneArray(self: byte[]): byte[] {
    const ret = new byte[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: byte[], index: number): Byte | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: byte[], ...items: (byte | Concatbyte[])[]): byte[] {
//     throw new Error("not implemented")
// }

export function concat(self: byte[], ...items: ConcatArray<byte>[]): byte[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new byte[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: byte[], index: int): Byte | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: byte[], target: number, start: number, end?: Number): byte[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: byte[], target: int, start: int, end: int): byte[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: byte[], target: int, start: int): byte[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: byte[], target: int): byte[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: byte[], value: byte, start?: Number, end?: Number): byte[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: byte[], value: byte, start: int, end: int): byte[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

export function find(self: byte[], predicate: (value: byte, i: number, self: byte[]) => boolean): Byte | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: byte[], fn: (value: byte, i: number, self: byte[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: byte[], fn: (elem: byte, i: number, self: byte[]) => boolean): Byte | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: byte[], fn: (v: byte, i: number, self: byte[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: byte[], fn: (v: byte, i: number, self: byte[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: byte[], fn: (v: byte, i: number, self: byte[]) => boolean): byte[] {
    return filter(self, (v: byte, i: number): boolean => fn(v, i as number, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: byte[], fn: (element: byte, i: number, self: byte[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: byte[], fn: (a: byte, b: byte, i: number, self: byte[]) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = byte>(self: byte[], fn: (previousValue: U, currentValue: byte, i: number, self: byte[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: byte[], fn: (a: byte, b: byte, i: number, self: byte[]) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: byte[], fn: (a: U, b: byte, i: number, self: byte[]) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: byte[], fn: (a: byte, i: number, self: byte[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number, self)
    }
}

export function find(self: byte[], predicate: (value: byte, i: number) => boolean): Byte | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: byte[], fn: (value: byte, i: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: byte[], fn: (elem: byte, i: number) => boolean): Byte | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: byte[], fn: (v: byte, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: byte[], fn: (v: byte, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: byte[], fn: (element: byte, i: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: byte[], fn: (a: byte, b: byte, i: number) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = byte>(self: byte[], fn: (previousValue: U, currentValue: byte, i: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: byte[], fn: (a: byte, b: byte, i: number) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: byte[], fn: (a: U, b: byte, i: number) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: byte[], fn: (a: byte, i: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number)
    }
}

export function find(self: byte[], predicate: (value: byte) => boolean): Byte | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: byte[], fn: (value: byte) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: byte[], fn: (elem: byte) => boolean): Byte | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: byte[], fn: (v: byte) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: byte[], fn: (v: byte) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: byte[], fn: (v: byte) => boolean): byte[] {
    return filter(self, (v: byte, i: number): boolean => fn(v));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: byte[], fn: (element: byte) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: byte[], fn: (a: byte, b: byte) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = byte>(self: byte[], fn: (previousValue: U, currentValue: byte) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: byte[], fn: (a: byte, b: byte) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: byte[], fn: (a: U, b: byte) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: byte[], fn: (a: byte) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: byte[], start?: Number, end?: Number): byte[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: byte[], start: int, end: int): byte[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new byte[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: byte[], start: int): byte[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: byte[], element: byte, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: byte[], element: byte, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: byte[], sep?: String): string {
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder();
    for (let i: int = 0; i < self.length; i++) {
        if (i != 0) {
            sb.append(sepReal);
        }
        sb.append(new String(self[i]));
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: byte[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: byte[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: byte[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: byte[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: byte[], start?: Number, delete?: Number): byte[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: byte[], start: number, delete: number, ...items: byte[]): byte[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: byte[], start: int, delete: int, ...items: byte[]): byte[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new byte[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: byte[], start: int): byte[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: byte[], val: byte, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: byte[], val: byte, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: byte[], val: byte, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: byte[], ): byte[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: byte[], comparator: (a: byte, b: byte) => number): byte[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: byte[], ): byte[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: byte[], ): byte[] {
    let arr = new byte[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: byte[], index: number, value: byte): byte[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: byte[], index: int, value: byte): byte[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: byte[], ): IterableIterator<byte> {
    return new ArrayValuesIterator_byte(self);
}

/**
 * Returns an iterator over all entries
 */
export function entries(self: byte[], ): IterableIterator<[number, byte]> {
    return new ArrayEntriesIterator_byte(self);
}

/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: byte[], fn: (value: byte, i: number, self: byte[]) => byte): byte[] {
    const len = self.length;
    let res = new byte[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number, self);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: byte[], fn: (value: byte, i: number) => byte): byte[] {
    const len = self.length;
    let res = new byte[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: byte[], fn: (value: byte) => byte): byte[] {
    const len = self.length;
    let res = new byte[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i]);
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: byte[], fn: (v: byte, k: number) => boolean): byte[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new byte[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: byte[], fst: byte[], ...more: byte[][]): byte[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new byte[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: byte[], comparator: (a: byte, b: byte) => number): byte[] {
    sort_subarray(self, 0, self.length, (l: byte, r: byte): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: byte[], ): byte[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: byte[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_byte implements IterableIterator<byte> {
    private parent: byte[]
    private idx: int = 0

    constructor(parent: byte[]) {
        this.parent = parent
    }

    override next(): IteratorResult<byte> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<byte>()
        }
        return new IteratorResult<byte>(this.parent[this.idx++])
    }

    override iterator(): IterableIterator<byte> {
        return this;
    }
}

class ArrayEntriesIterator_byte implements IterableIterator<[number, byte]> {
    private parent: byte[]
    private idx: int = 0

    constructor(parent: byte[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, byte]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, byte]>()
        }
        const i = this.idx++;
        const vl: [number, byte] = [i as number, this.parent[i]]
        return new IteratorResult<[number, byte]>(vl);
    }

    override iterator(): IterableIterator<[number, byte]> {
        return this;
    }
}

function cloneArray(self: short[]): short[] {
    const ret = new short[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: short[], index: number): Short | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: short[], ...items: (short | Concatshort[])[]): short[] {
//     throw new Error("not implemented")
// }

export function concat(self: short[], ...items: ConcatArray<short>[]): short[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new short[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: short[], index: int): Short | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: short[], target: number, start: number, end?: Number): short[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: short[], target: int, start: int, end: int): short[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: short[], target: int, start: int): short[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: short[], target: int): short[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: short[], value: short, start?: Number, end?: Number): short[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: short[], value: short, start: int, end: int): short[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

export function find(self: short[], predicate: (value: short, i: number, self: short[]) => boolean): Short | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: short[], fn: (value: short, i: number, self: short[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: short[], fn: (elem: short, i: number, self: short[]) => boolean): Short | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: short[], fn: (v: short, i: number, self: short[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: short[], fn: (v: short, i: number, self: short[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: short[], fn: (v: short, i: number, self: short[]) => boolean): short[] {
    return filter(self, (v: short, i: number): boolean => fn(v, i as number, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: short[], fn: (element: short, i: number, self: short[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: short[], fn: (a: short, b: short, i: number, self: short[]) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = short>(self: short[], fn: (previousValue: U, currentValue: short, i: number, self: short[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: short[], fn: (a: short, b: short, i: number, self: short[]) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: short[], fn: (a: U, b: short, i: number, self: short[]) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: short[], fn: (a: short, i: number, self: short[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number, self)
    }
}

export function find(self: short[], predicate: (value: short, i: number) => boolean): Short | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: short[], fn: (value: short, i: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: short[], fn: (elem: short, i: number) => boolean): Short | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: short[], fn: (v: short, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: short[], fn: (v: short, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: short[], fn: (element: short, i: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: short[], fn: (a: short, b: short, i: number) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = short>(self: short[], fn: (previousValue: U, currentValue: short, i: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: short[], fn: (a: short, b: short, i: number) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: short[], fn: (a: U, b: short, i: number) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: short[], fn: (a: short, i: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number)
    }
}

export function find(self: short[], predicate: (value: short) => boolean): Short | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: short[], fn: (value: short) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: short[], fn: (elem: short) => boolean): Short | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: short[], fn: (v: short) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: short[], fn: (v: short) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: short[], fn: (v: short) => boolean): short[] {
    return filter(self, (v: short, i: number): boolean => fn(v));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: short[], fn: (element: short) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: short[], fn: (a: short, b: short) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = short>(self: short[], fn: (previousValue: U, currentValue: short) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: short[], fn: (a: short, b: short) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: short[], fn: (a: U, b: short) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: short[], fn: (a: short) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: short[], start?: Number, end?: Number): short[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: short[], start: int, end: int): short[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new short[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: short[], start: int): short[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: short[], element: short, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: short[], element: short, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: short[], sep?: String): string {
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder();
    for (let i: int = 0; i < self.length; i++) {
        if (i != 0) {
            sb.append(sepReal);
        }
        sb.append(new String(self[i]));
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: short[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: short[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: short[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: short[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: short[], start?: Number, delete?: Number): short[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: short[], start: number, delete: number, ...items: short[]): short[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: short[], start: int, delete: int, ...items: short[]): short[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new short[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: short[], start: int): short[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: short[], val: short, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: short[], val: short, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: short[], val: short, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: short[], ): short[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: short[], comparator: (a: short, b: short) => number): short[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: short[], ): short[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: short[], ): short[] {
    let arr = new short[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: short[], index: number, value: short): short[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: short[], index: int, value: short): short[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: short[], ): IterableIterator<short> {
    return new ArrayValuesIterator_short(self);
}

/**
 * Returns an iterator over all entries
 */
export function entries(self: short[], ): IterableIterator<[number, short]> {
    return new ArrayEntriesIterator_short(self);
}

/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: short[], fn: (value: short, i: number, self: short[]) => short): short[] {
    const len = self.length;
    let res = new short[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number, self);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: short[], fn: (value: short, i: number) => short): short[] {
    const len = self.length;
    let res = new short[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: short[], fn: (value: short) => short): short[] {
    const len = self.length;
    let res = new short[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i]);
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: short[], fn: (v: short, k: number) => boolean): short[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new short[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: short[], fst: short[], ...more: short[][]): short[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new short[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: short[], comparator: (a: short, b: short) => number): short[] {
    sort_subarray(self, 0, self.length, (l: short, r: short): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: short[], ): short[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: short[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_short implements IterableIterator<short> {
    private parent: short[]
    private idx: int = 0

    constructor(parent: short[]) {
        this.parent = parent
    }

    override next(): IteratorResult<short> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<short>()
        }
        return new IteratorResult<short>(this.parent[this.idx++])
    }

    override iterator(): IterableIterator<short> {
        return this;
    }
}

class ArrayEntriesIterator_short implements IterableIterator<[number, short]> {
    private parent: short[]
    private idx: int = 0

    constructor(parent: short[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, short]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, short]>()
        }
        const i = this.idx++;
        const vl: [number, short] = [i as number, this.parent[i]]
        return new IteratorResult<[number, short]>(vl);
    }

    override iterator(): IterableIterator<[number, short]> {
        return this;
    }
}

function cloneArray(self: int[]): int[] {
    const ret = new int[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: int[], index: number): Int | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: int[], ...items: (int | Concatint[])[]): int[] {
//     throw new Error("not implemented")
// }

export function concat(self: int[], ...items: ConcatArray<int>[]): int[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new int[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: int[], index: int): Int | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: int[], target: number, start: number, end?: Number): int[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: int[], target: int, start: int, end: int): int[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: int[], target: int, start: int): int[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: int[], target: int): int[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: int[], value: int, start?: Number, end?: Number): int[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: int[], value: int, start: int, end: int): int[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

export function find(self: int[], predicate: (value: int, i: number, self: int[]) => boolean): Int | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: int[], fn: (value: int, i: number, self: int[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: int[], fn: (elem: int, i: number, self: int[]) => boolean): Int | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: int[], fn: (v: int, i: number, self: int[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: int[], fn: (v: int, i: number, self: int[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: int[], fn: (v: int, i: number, self: int[]) => boolean): int[] {
    return filter(self, (v: int, i: number): boolean => fn(v, i as number, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: int[], fn: (element: int, i: number, self: int[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: int[], fn: (a: int, b: int, i: number, self: int[]) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = int>(self: int[], fn: (previousValue: U, currentValue: int, i: number, self: int[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: int[], fn: (a: int, b: int, i: number, self: int[]) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: int[], fn: (a: U, b: int, i: number, self: int[]) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: int[], fn: (a: int, i: number, self: int[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number, self)
    }
}

export function find(self: int[], predicate: (value: int, i: number) => boolean): Int | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: int[], fn: (value: int, i: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: int[], fn: (elem: int, i: number) => boolean): Int | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: int[], fn: (v: int, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: int[], fn: (v: int, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: int[], fn: (element: int, i: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: int[], fn: (a: int, b: int, i: number) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = int>(self: int[], fn: (previousValue: U, currentValue: int, i: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: int[], fn: (a: int, b: int, i: number) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: int[], fn: (a: U, b: int, i: number) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: int[], fn: (a: int, i: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number)
    }
}

export function find(self: int[], predicate: (value: int) => boolean): Int | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: int[], fn: (value: int) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: int[], fn: (elem: int) => boolean): Int | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: int[], fn: (v: int) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: int[], fn: (v: int) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: int[], fn: (v: int) => boolean): int[] {
    return filter(self, (v: int, i: number): boolean => fn(v));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: int[], fn: (element: int) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: int[], fn: (a: int, b: int) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = int>(self: int[], fn: (previousValue: U, currentValue: int) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: int[], fn: (a: int, b: int) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: int[], fn: (a: U, b: int) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: int[], fn: (a: int) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: int[], start?: Number, end?: Number): int[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: int[], start: int, end: int): int[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new int[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: int[], start: int): int[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: int[], element: int, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: int[], element: int, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: int[], sep?: String): string {
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder();
    for (let i: int = 0; i < self.length; i++) {
        if (i != 0) {
            sb.append(sepReal);
        }
        sb.append(new String(self[i]));
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: int[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: int[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: int[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: int[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: int[], start?: Number, delete?: Number): int[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: int[], start: number, delete: number, ...items: int[]): int[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: int[], start: int, delete: int, ...items: int[]): int[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new int[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: int[], start: int): int[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: int[], val: int, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: int[], val: int, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: int[], val: int, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: int[], ): int[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: int[], comparator: (a: int, b: int) => number): int[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: int[], ): int[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: int[], ): int[] {
    let arr = new int[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: int[], index: number, value: int): int[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: int[], index: int, value: int): int[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: int[], ): IterableIterator<int> {
    return new ArrayValuesIterator_int(self);
}

/**
 * Returns an iterator over all entries
 */
export function entries(self: int[], ): IterableIterator<[number, int]> {
    return new ArrayEntriesIterator_int(self);
}

/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: int[], fn: (value: int, i: number, self: int[]) => int): int[] {
    const len = self.length;
    let res = new int[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number, self);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: int[], fn: (value: int, i: number) => int): int[] {
    const len = self.length;
    let res = new int[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: int[], fn: (value: int) => int): int[] {
    const len = self.length;
    let res = new int[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i]);
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: int[], fn: (v: int, k: number) => boolean): int[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new int[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: int[], fst: int[], ...more: int[][]): int[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new int[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: int[], comparator: (a: int, b: int) => number): int[] {
    sort_subarray(self, 0, self.length, (l: int, r: int): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: int[], ): int[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: int[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_int implements IterableIterator<int> {
    private parent: int[]
    private idx: int = 0

    constructor(parent: int[]) {
        this.parent = parent
    }

    override next(): IteratorResult<int> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(this.parent[this.idx++])
    }

    override iterator(): IterableIterator<int> {
        return this;
    }
}

class ArrayEntriesIterator_int implements IterableIterator<[number, int]> {
    private parent: int[]
    private idx: int = 0

    constructor(parent: int[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, int]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, int]>()
        }
        const i = this.idx++;
        const vl: [number, int] = [i as number, this.parent[i]]
        return new IteratorResult<[number, int]>(vl);
    }

    override iterator(): IterableIterator<[number, int]> {
        return this;
    }
}

function cloneArray(self: long[]): long[] {
    const ret = new long[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: long[], index: number): Long | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: long[], ...items: (long | Concatlong[])[]): long[] {
//     throw new Error("not implemented")
// }

export function concat(self: long[], ...items: ConcatArray<long>[]): long[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new long[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: long[], index: int): Long | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: long[], target: number, start: number, end?: Number): long[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: long[], target: int, start: int, end: int): long[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: long[], target: int, start: int): long[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: long[], target: int): long[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: long[], value: long, start?: Number, end?: Number): long[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: long[], value: long, start: int, end: int): long[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

export function find(self: long[], predicate: (value: long, i: number, self: long[]) => boolean): Long | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: long[], fn: (value: long, i: number, self: long[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: long[], fn: (elem: long, i: number, self: long[]) => boolean): Long | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: long[], fn: (v: long, i: number, self: long[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: long[], fn: (v: long, i: number, self: long[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: long[], fn: (v: long, i: number, self: long[]) => boolean): long[] {
    return filter(self, (v: long, i: number): boolean => fn(v, i as number, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: long[], fn: (element: long, i: number, self: long[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: long[], fn: (a: long, b: long, i: number, self: long[]) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = long>(self: long[], fn: (previousValue: U, currentValue: long, i: number, self: long[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: long[], fn: (a: long, b: long, i: number, self: long[]) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: long[], fn: (a: U, b: long, i: number, self: long[]) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: long[], fn: (a: long, i: number, self: long[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number, self)
    }
}

export function find(self: long[], predicate: (value: long, i: number) => boolean): Long | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: long[], fn: (value: long, i: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: long[], fn: (elem: long, i: number) => boolean): Long | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: long[], fn: (v: long, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: long[], fn: (v: long, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: long[], fn: (element: long, i: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: long[], fn: (a: long, b: long, i: number) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = long>(self: long[], fn: (previousValue: U, currentValue: long, i: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: long[], fn: (a: long, b: long, i: number) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: long[], fn: (a: U, b: long, i: number) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: long[], fn: (a: long, i: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number)
    }
}

export function find(self: long[], predicate: (value: long) => boolean): Long | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: long[], fn: (value: long) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: long[], fn: (elem: long) => boolean): Long | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: long[], fn: (v: long) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: long[], fn: (v: long) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: long[], fn: (v: long) => boolean): long[] {
    return filter(self, (v: long, i: number): boolean => fn(v));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: long[], fn: (element: long) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: long[], fn: (a: long, b: long) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = long>(self: long[], fn: (previousValue: U, currentValue: long) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: long[], fn: (a: long, b: long) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: long[], fn: (a: U, b: long) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: long[], fn: (a: long) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: long[], start?: Number, end?: Number): long[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: long[], start: int, end: int): long[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new long[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: long[], start: int): long[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: long[], element: long, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: long[], element: long, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: long[], sep?: String): string {
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder();
    for (let i: int = 0; i < self.length; i++) {
        if (i != 0) {
            sb.append(sepReal);
        }
        sb.append(new String(self[i]));
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: long[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: long[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: long[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: long[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: long[], start?: Number, delete?: Number): long[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: long[], start: number, delete: number, ...items: long[]): long[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: long[], start: int, delete: int, ...items: long[]): long[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new long[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: long[], start: int): long[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: long[], val: long, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: long[], val: long, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: long[], val: long, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: long[], ): long[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: long[], comparator: (a: long, b: long) => number): long[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: long[], ): long[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: long[], ): long[] {
    let arr = new long[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: long[], index: number, value: long): long[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: long[], index: int, value: long): long[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: long[], ): IterableIterator<long> {
    return new ArrayValuesIterator_long(self);
}

/**
 * Returns an iterator over all entries
 */
export function entries(self: long[], ): IterableIterator<[number, long]> {
    return new ArrayEntriesIterator_long(self);
}

/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: long[], fn: (value: long, i: number, self: long[]) => long): long[] {
    const len = self.length;
    let res = new long[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number, self);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: long[], fn: (value: long, i: number) => long): long[] {
    const len = self.length;
    let res = new long[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: long[], fn: (value: long) => long): long[] {
    const len = self.length;
    let res = new long[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i]);
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: long[], fn: (v: long, k: number) => boolean): long[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new long[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: long[], fst: long[], ...more: long[][]): long[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new long[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: long[], comparator: (a: long, b: long) => number): long[] {
    sort_subarray(self, 0, self.length, (l: long, r: long): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: long[], ): long[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: long[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_long implements IterableIterator<long> {
    private parent: long[]
    private idx: int = 0

    constructor(parent: long[]) {
        this.parent = parent
    }

    override next(): IteratorResult<long> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<long>()
        }
        return new IteratorResult<long>(this.parent[this.idx++])
    }

    override iterator(): IterableIterator<long> {
        return this;
    }
}

class ArrayEntriesIterator_long implements IterableIterator<[number, long]> {
    private parent: long[]
    private idx: int = 0

    constructor(parent: long[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, long]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, long]>()
        }
        const i = this.idx++;
        const vl: [number, long] = [i as number, this.parent[i]]
        return new IteratorResult<[number, long]>(vl);
    }

    override iterator(): IterableIterator<[number, long]> {
        return this;
    }
}

function cloneArray(self: float[]): float[] {
    const ret = new float[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: float[], index: number): Float | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: float[], ...items: (float | Concatfloat[])[]): float[] {
//     throw new Error("not implemented")
// }

export function concat(self: float[], ...items: ConcatArray<float>[]): float[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new float[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: float[], index: int): Float | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: float[], target: number, start: number, end?: Number): float[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: float[], target: int, start: int, end: int): float[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: float[], target: int, start: int): float[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: float[], target: int): float[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: float[], value: float, start?: Number, end?: Number): float[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: float[], value: float, start: int, end: int): float[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

export function find(self: float[], predicate: (value: float, i: number, self: float[]) => boolean): Float | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: float[], fn: (value: float, i: number, self: float[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: float[], fn: (elem: float, i: number, self: float[]) => boolean): Float | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: float[], fn: (v: float, i: number, self: float[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: float[], fn: (v: float, i: number, self: float[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: float[], fn: (v: float, i: number, self: float[]) => boolean): float[] {
    return filter(self, (v: float, i: number): boolean => fn(v, i as number, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: float[], fn: (element: float, i: number, self: float[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: float[], fn: (a: float, b: float, i: number, self: float[]) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = float>(self: float[], fn: (previousValue: U, currentValue: float, i: number, self: float[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: float[], fn: (a: float, b: float, i: number, self: float[]) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: float[], fn: (a: U, b: float, i: number, self: float[]) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: float[], fn: (a: float, i: number, self: float[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number, self)
    }
}

export function find(self: float[], predicate: (value: float, i: number) => boolean): Float | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: float[], fn: (value: float, i: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: float[], fn: (elem: float, i: number) => boolean): Float | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: float[], fn: (v: float, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: float[], fn: (v: float, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: float[], fn: (element: float, i: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: float[], fn: (a: float, b: float, i: number) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = float>(self: float[], fn: (previousValue: U, currentValue: float, i: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: float[], fn: (a: float, b: float, i: number) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: float[], fn: (a: U, b: float, i: number) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: float[], fn: (a: float, i: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number)
    }
}

export function find(self: float[], predicate: (value: float) => boolean): Float | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: float[], fn: (value: float) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: float[], fn: (elem: float) => boolean): Float | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: float[], fn: (v: float) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: float[], fn: (v: float) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: float[], fn: (v: float) => boolean): float[] {
    return filter(self, (v: float, i: number): boolean => fn(v));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: float[], fn: (element: float) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: float[], fn: (a: float, b: float) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = float>(self: float[], fn: (previousValue: U, currentValue: float) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: float[], fn: (a: float, b: float) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: float[], fn: (a: U, b: float) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: float[], fn: (a: float) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: float[], start?: Number, end?: Number): float[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: float[], start: int, end: int): float[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new float[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: float[], start: int): float[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: float[], element: float, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: float[], element: float, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: float[], sep?: String): string {
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder();
    for (let i: int = 0; i < self.length; i++) {
        if (i != 0) {
            sb.append(sepReal);
        }
        sb.append(new String(self[i]));
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: float[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: float[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: float[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: float[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: float[], start?: Number, delete?: Number): float[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: float[], start: number, delete: number, ...items: float[]): float[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: float[], start: int, delete: int, ...items: float[]): float[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new float[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: float[], start: int): float[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: float[], val: float, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    if (isNaN(val)) {
        for (let i = fi; i < len; i++) {
            if (isNaN(self[i])) {
                return true;
            }
        }
        return false;
    }
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: float[], val: float, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: float[], val: float, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: float[], ): float[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: float[], comparator: (a: float, b: float) => number): float[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: float[], ): float[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: float[], ): float[] {
    let arr = new float[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: float[], index: number, value: float): float[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: float[], index: int, value: float): float[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: float[], ): IterableIterator<float> {
    return new ArrayValuesIterator_float(self);
}

/**
 * Returns an iterator over all entries
 */
export function entries(self: float[], ): IterableIterator<[number, float]> {
    return new ArrayEntriesIterator_float(self);
}

/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: float[], fn: (value: float, i: number, self: float[]) => float): float[] {
    const len = self.length;
    let res = new float[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number, self);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: float[], fn: (value: float, i: number) => float): float[] {
    const len = self.length;
    let res = new float[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: float[], fn: (value: float) => float): float[] {
    const len = self.length;
    let res = new float[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i]);
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: float[], fn: (v: float, k: number) => boolean): float[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new float[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: float[], fst: float[], ...more: float[][]): float[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new float[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: float[], comparator: (a: float, b: float) => number): float[] {
    sort_subarray(self, 0, self.length, (l: float, r: float): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: float[], ): float[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: float[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_float implements IterableIterator<float> {
    private parent: float[]
    private idx: int = 0

    constructor(parent: float[]) {
        this.parent = parent
    }

    override next(): IteratorResult<float> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<float>()
        }
        return new IteratorResult<float>(this.parent[this.idx++])
    }

    override iterator(): IterableIterator<float> {
        return this;
    }
}

class ArrayEntriesIterator_float implements IterableIterator<[number, float]> {
    private parent: float[]
    private idx: int = 0

    constructor(parent: float[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, float]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, float]>()
        }
        const i = this.idx++;
        const vl: [number, float] = [i as number, this.parent[i]]
        return new IteratorResult<[number, float]>(vl);
    }

    override iterator(): IterableIterator<[number, float]> {
        return this;
    }
}

function cloneArray(self: double[]): double[] {
    const ret = new double[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: double[], index: number): Double | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: double[], ...items: (double | Concatdouble[])[]): double[] {
//     throw new Error("not implemented")
// }

export function concat(self: double[], ...items: ConcatArray<double>[]): double[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new double[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: double[], index: int): Double | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: double[], target: number, start: number, end?: Number): double[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: double[], target: int, start: int, end: int): double[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: double[], target: int, start: int): double[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: double[], target: int): double[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: double[], value: double, start?: Number, end?: Number): double[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: double[], value: double, start: int, end: int): double[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

export function find(self: double[], predicate: (value: double, i: number, self: double[]) => boolean): Double | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: double[], fn: (value: double, i: number, self: double[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: double[], fn: (elem: double, i: number, self: double[]) => boolean): Double | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: double[], fn: (v: double, i: number, self: double[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: double[], fn: (v: double, i: number, self: double[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: double[], fn: (v: double, i: number, self: double[]) => boolean): double[] {
    return filter(self, (v: double, i: number): boolean => fn(v, i as number, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: double[], fn: (element: double, i: number, self: double[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: double[], fn: (a: double, b: double, i: number, self: double[]) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = double>(self: double[], fn: (previousValue: U, currentValue: double, i: number, self: double[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: double[], fn: (a: double, b: double, i: number, self: double[]) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: double[], fn: (a: U, b: double, i: number, self: double[]) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: double[], fn: (a: double, i: number, self: double[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number, self)
    }
}

export function find(self: double[], predicate: (value: double, i: number) => boolean): Double | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: double[], fn: (value: double, i: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: double[], fn: (elem: double, i: number) => boolean): Double | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: double[], fn: (v: double, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: double[], fn: (v: double, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: double[], fn: (element: double, i: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: double[], fn: (a: double, b: double, i: number) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = double>(self: double[], fn: (previousValue: U, currentValue: double, i: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: double[], fn: (a: double, b: double, i: number) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: double[], fn: (a: U, b: double, i: number) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: double[], fn: (a: double, i: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number)
    }
}

export function find(self: double[], predicate: (value: double) => boolean): Double | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: double[], fn: (value: double) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: double[], fn: (elem: double) => boolean): Double | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: double[], fn: (v: double) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: double[], fn: (v: double) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: double[], fn: (v: double) => boolean): double[] {
    return filter(self, (v: double, i: number): boolean => fn(v));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: double[], fn: (element: double) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: double[], fn: (a: double, b: double) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = double>(self: double[], fn: (previousValue: U, currentValue: double) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: double[], fn: (a: double, b: double) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: double[], fn: (a: U, b: double) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: double[], fn: (a: double) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: double[], start?: Number, end?: Number): double[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: double[], start: int, end: int): double[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new double[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: double[], start: int): double[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: double[], element: double, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: double[], element: double, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: double[], sep?: String): string {
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder();
    for (let i: int = 0; i < self.length; i++) {
        if (i != 0) {
            sb.append(sepReal);
        }
        sb.append(new String(self[i]));
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: double[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: double[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: double[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: double[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: double[], start?: Number, delete?: Number): double[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: double[], start: number, delete: number, ...items: double[]): double[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: double[], start: int, delete: int, ...items: double[]): double[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new double[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: double[], start: int): double[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: double[], val: double, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    if (isNaN(val)) {
        for (let i = fi; i < len; i++) {
            if (isNaN(self[i])) {
                return true;
            }
        }
        return false;
    }
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: double[], val: double, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: double[], val: double, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: double[], ): double[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: double[], comparator: (a: double, b: double) => number): double[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: double[], ): double[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: double[], ): double[] {
    let arr = new double[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: double[], index: number, value: double): double[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: double[], index: int, value: double): double[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: double[], ): IterableIterator<double> {
    return new ArrayValuesIterator_double(self);
}

/**
 * Returns an iterator over all entries
 */
export function entries(self: double[], ): IterableIterator<[number, double]> {
    return new ArrayEntriesIterator_double(self);
}

/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: double[], fn: (value: double, i: number, self: double[]) => double): double[] {
    const len = self.length;
    let res = new double[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number, self);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: double[], fn: (value: double, i: number) => double): double[] {
    const len = self.length;
    let res = new double[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: double[], fn: (value: double) => double): double[] {
    const len = self.length;
    let res = new double[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i]);
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: double[], fn: (v: double, k: number) => boolean): double[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new double[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: double[], fst: double[], ...more: double[][]): double[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new double[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: double[], comparator: (a: double, b: double) => number): double[] {
    sort_subarray(self, 0, self.length, (l: double, r: double): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: double[], ): double[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: double[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_double implements IterableIterator<double> {
    private parent: double[]
    private idx: int = 0

    constructor(parent: double[]) {
        this.parent = parent
    }

    override next(): IteratorResult<double> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<double>()
        }
        return new IteratorResult<double>(this.parent[this.idx++])
    }

    override iterator(): IterableIterator<double> {
        return this;
    }
}

class ArrayEntriesIterator_double implements IterableIterator<[number, double]> {
    private parent: double[]
    private idx: int = 0

    constructor(parent: double[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, double]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, double]>()
        }
        const i = this.idx++;
        const vl: [number, double] = [i as number, this.parent[i]]
        return new IteratorResult<[number, double]>(vl);
    }

    override iterator(): IterableIterator<[number, double]> {
        return this;
    }
}

function cloneArray(self: char[]): char[] {
    const ret = new char[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: char[], index: number): Char | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: char[], ...items: (char | Concatchar[])[]): char[] {
//     throw new Error("not implemented")
// }

export function concat(self: char[], ...items: ConcatArray<char>[]): char[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new char[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: char[], index: int): Char | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: char[], target: number, start: number, end?: Number): char[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: char[], target: int, start: int, end: int): char[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: char[], target: int, start: int): char[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: char[], target: int): char[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: char[], value: char, start?: Number, end?: Number): char[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: char[], value: char, start: int, end: int): char[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

export function find(self: char[], predicate: (value: char, i: number, self: char[]) => boolean): Char | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: char[], fn: (value: char, i: number, self: char[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: char[], fn: (elem: char, i: number, self: char[]) => boolean): Char | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: char[], fn: (v: char, i: number, self: char[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: char[], fn: (v: char, i: number, self: char[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: char[], fn: (v: char, i: number, self: char[]) => boolean): char[] {
    return filter(self, (v: char, i: number): boolean => fn(v, i as number, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: char[], fn: (element: char, i: number, self: char[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: char[], fn: (a: char, b: char, i: number, self: char[]) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = char>(self: char[], fn: (previousValue: U, currentValue: char, i: number, self: char[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: char[], fn: (a: char, b: char, i: number, self: char[]) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: char[], fn: (a: U, b: char, i: number, self: char[]) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: char[], fn: (a: char, i: number, self: char[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number, self)
    }
}

export function find(self: char[], predicate: (value: char, i: number) => boolean): Char | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: char[], fn: (value: char, i: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: char[], fn: (elem: char, i: number) => boolean): Char | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: char[], fn: (v: char, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: char[], fn: (v: char, i: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: char[], fn: (element: char, i: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: char[], fn: (a: char, b: char, i: number) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = char>(self: char[], fn: (previousValue: U, currentValue: char, i: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: char[], fn: (a: char, b: char, i: number) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: char[], fn: (a: U, b: char, i: number) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: char[], fn: (a: char, i: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i], i as number)
    }
}

export function find(self: char[], predicate: (value: char) => boolean): Char | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in an array that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: char[], fn: (value: char) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param fn testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: char[], fn: (elem: char) => boolean): Char | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (fn(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Tests whether all elements in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: char[], fn: (v: char) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!fn(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Tests whether at least one element in the array pass the test
 * implemented by the provided function. It returns a Boolean value.
 *
 * @param fn function to execute for each element in the array.
 * It should return a `true` to indicate the element passes the test, and a `false` value otherwise.
 *
 * @returns `true` if `fn` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: char[], fn: (v: char) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (fn(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function filter(self: char[], fn: (v: char) => boolean): char[] {
    return filter(self, (v: char, i: number): boolean => fn(v));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param fn testing function
 *
 * @returns index of first element satisfying to fn, -1 if no such element
 */
export function findLastIndex(self: char[], fn: (element: char) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (fn(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce(self: char[], fn: (a: char, b: char) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from left-to-right.
 *
 * @param fn reduce function
 *
 * @param initialValue initial value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduce<U = char>(self: char[], fn: (previousValue: U, currentValue: char) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight(self: char[], fn: (a: char, b: char) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a user-supplied "reducer" callback function on each element of the array,
 * in order, passing in the return value from the calculation on the preceding element.
 * The final result of running the reducer across all elements of the array is a single value.
 * Order is from right-to-left.
 *
 * @param fn reduce function
 *
 * @param initVal start value
 *
 * @returns a result after applying fn over all elements of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function reduceRight<U>(self: char[], fn: (a: U, b: char) => U, initVal: U): U {
    let acc = initVal
    for (let i = self.length - 1; i >= 0; i--) {
        acc = fn(acc, self[i])
    }
    return acc
}

/**
 * Executes a provided function once for each array element.
 *
 * @param fn to apply for each element of the Array
 */
// NOTE(gogabr): should override from ReadonlyArray, but blocked by #15096
export function forEach(self: char[], fn: (a: char) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        fn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: char[], start?: Number, end?: Number): char[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: char[], start: int, end: int): char[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new char[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: char[], start: int): char[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: char[], element: char, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: char[], element: char, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: char[], sep?: String): string {
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder();
    for (let i: int = 0; i < self.length; i++) {
        if (i != 0) {
            sb.append(sepReal);
        }
        sb.append(new String(self[i]));
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: char[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: char[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: char[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: char[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: char[], start?: Number, delete?: Number): char[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: char[], start: number, delete: number, ...items: char[]): char[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: char[], start: int, delete: int, ...items: char[]): char[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new char[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: char[], start: int): char[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: char[], val: char, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: char[], val: char, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: char[], val: char, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: char[], ): char[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: char[], comparator: (a: char, b: char) => number): char[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: char[], ): char[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: char[], ): char[] {
    let arr = new char[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: char[], index: number, value: char): char[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: char[], index: int, value: char): char[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: char[], ): IterableIterator<char> {
    return new ArrayValuesIterator_char(self);
}

/**
 * Returns an iterator over all entries
 */
export function entries(self: char[], ): IterableIterator<[number, char]> {
    return new ArrayEntriesIterator_char(self);
}

/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: char[], fn: (value: char, i: number, self: char[]) => char): char[] {
    const len = self.length;
    let res = new char[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number, self);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: char[], fn: (value: char, i: number) => char): char[] {
    const len = self.length;
    let res = new char[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i], i as number);
    }
    return res;
}
/**
 * Creates a new `Array` object and populates
 * it with the results of calling a provided function on every element in `this` instance of `Array` class.
 *
 * @param fn mapping function, applied to each element of an array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: char[], fn: (value: char) => char): char[] {
    const len = self.length;
    let res = new char[len];
    for (let i = 0; i < len; i++) {
        res[i] = fn(self[i]);
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: char[], fn: (v: char, k: number) => boolean): char[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new char[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: char[], fst: char[], ...more: char[][]): char[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new char[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: char[], comparator: (a: char, b: char) => number): char[] {
    sort_subarray(self, 0, self.length, (l: char, r: char): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: char[], ): char[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: char[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_char implements IterableIterator<char> {
    private parent: char[]
    private idx: int = 0

    constructor(parent: char[]) {
        this.parent = parent
    }

    override next(): IteratorResult<char> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<char>()
        }
        return new IteratorResult<char>(this.parent[this.idx++])
    }

    override iterator(): IterableIterator<char> {
        return this;
    }
}

class ArrayEntriesIterator_char implements IterableIterator<[number, char]> {
    private parent: char[]
    private idx: int = 0

    constructor(parent: char[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, char]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, char]>()
        }
        const i = this.idx++;
        const vl: [number, char] = [i as number, this.parent[i]]
        return new IteratorResult<[number, char]>(vl);
    }

    override iterator(): IterableIterator<[number, char]> {
        return this;
    }
}

function builtin_insertion_sort<T>(arr: T[], startIndex: int, endIndex: int, comp: (lhs: T, rhs: T) => number): void {
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if (comp(tmp, arr[startIndex]) as int < 0) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while (comp(tmp, arr[pos - 1]) as int < 0) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}

function perform_merge<T>(arr: T[], startIndex: int, midIndex: int, endIndex: int, to: T[], toStart: int, comp: (lhs: T, rhs: T) => number): void {
    let startIndex2 = midIndex
    while (startIndex < midIndex && startIndex2 < endIndex) {
        if (comp(arr[startIndex], arr[startIndex2]) as int <= 0) {
            to[toStart++] = arr[startIndex++]
        } else {
            to[toStart++] = arr[startIndex2++]
        }
    }

    while (startIndex < midIndex) {
        to[toStart++] = arr[startIndex++]
    }
    while (startIndex2 < endIndex) {
        to[toStart++] = arr[startIndex2++]
    }
}

export function sort_stable<T>(arr: T[], startIndex: int, endIndex: int, comp: (lhs: T, rhs: T) => number): void {
    if (endIndex <= startIndex) {
        return;
    }
    const INS_SORT_DELTA = 16
    for (let i = startIndex; i < endIndex; i += INS_SORT_DELTA ) {
        builtin_insertion_sort<T>(arr, i, min(i + INS_SORT_DELTA , endIndex), comp)
    }

    let prevSize = INS_SORT_DELTA

    const delta = endIndex - startIndex
    const initialArr = arr
    let buf = __alloc_array<T>(delta, arr)
    let buf0 = 0
    let arr0 = startIndex
    while (prevSize < delta) {
        for (let strt = 0; strt < delta; strt += 2 * prevSize) {
            const mid = strt + prevSize
            if (mid >= delta) {
                break
            }
            const end = min(mid + prevSize, delta)
            perform_merge(arr, strt + arr0, mid + arr0, end + arr0, buf, strt + buf0, comp)
        }
        const tmp = arr
        arr = buf
        buf = tmp
        const buf0Tmp = buf0
        buf0 = arr0
        arr0 = buf0Tmp

        prevSize *= 2
    }

    if (!runtime.isSameReference(arr, initialArr)) {
        for (let i = 0; i < delta; i++) {
            initialArr[startIndex + i] = arr[i + arr0]
        }
    }
}
