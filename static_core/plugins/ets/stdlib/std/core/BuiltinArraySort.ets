/**
 * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package std.core;

// NOTE: autogenerated file
//

function insertion_sort(arr: FixedArray<Byte>, startIndex: int, endIndex: int, comp: (lhs: byte, rhs: byte) => number): void {
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i];
        if (comp(tmp, arr[startIndex]).toInt() < 0) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let j = i - 1;
            while (comp(tmp, arr[j]).toInt() < 0) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = tmp;
        }
    }
}

function arr_perform_merge(arr: FixedArray<Byte>, startIndex: int, midIndex: int, endIndex: int, comp: (lhs: byte, rhs: byte) => number): void {
    const len1 = midIndex - startIndex + 1;
    const len2 = endIndex - midIndex;
    let left : FixedArray<Byte> = new Byte[len1];
    let right : FixedArray<Byte> = new Byte[len2];
    for (let i = 0; i < len1; i++) {
        left[i] = arr[startIndex + i];
    }
    for (let i = 0; i < len2; i++) {
        right[i] = arr[midIndex + 1 + i];
    }
    let i = 0;
    let j = 0;
    let k = startIndex;
    while (i < len1 && j < len2) {
        if (comp(left[i], right[j]!).toInt() <= 0) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }
    while (i < len1) {
        arr[k] = left[i];
        k++;
        i++;
    }
    while (j < len2) {
        arr[k] = right[j];
        k++;
        j++;
    }
}

export function arr_sort_stable(arr: FixedArray<Byte>, startIndex: int, endIndex: int, comp: (lhs: byte, rhs: byte) => number): void {
    if (endIndex <= startIndex) {
        return;
    }

    const INS_SORT_DELTA = 16
    for (let i = startIndex; i < endIndex; i += INS_SORT_DELTA ) {
        insertion_sort(arr, i, min(i + INS_SORT_DELTA , endIndex), comp)
    }
    if ((endIndex - startIndex) < INS_SORT_DELTA) {
        return;
    }
    for (let size = INS_SORT_DELTA; size < endIndex; size = 2 * size) {
        for (let left = startIndex; left < endIndex; left += 2 * size) {

            // Find ending point of left subarray and right subarray
            const mid = min(left + size - 1, endIndex - 1);
            const right = min((left + 2 * size - 1), (endIndex - 1));

            // Merge sub array arr[left.....mid] and arr[mid + 1....right]
            if (mid < right) {
                arr_perform_merge(arr, left, mid, right, comp);
            }
        }
    }
}
function insertion_sort(arr: FixedArray<Short>, startIndex: int, endIndex: int, comp: (lhs: short, rhs: short) => number): void {
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i];
        if (comp(tmp, arr[startIndex]).toInt() < 0) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let j = i - 1;
            while (comp(tmp, arr[j]).toInt() < 0) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = tmp;
        }
    }
}

function arr_perform_merge(arr: FixedArray<Short>, startIndex: int, midIndex: int, endIndex: int, comp: (lhs: short, rhs: short) => number): void {
    const len1 = midIndex - startIndex + 1;
    const len2 = endIndex - midIndex;
    let left : FixedArray<Short> = new Short[len1];
    let right : FixedArray<Short> = new Short[len2];
    for (let i = 0; i < len1; i++) {
        left[i] = arr[startIndex + i];
    }
    for (let i = 0; i < len2; i++) {
        right[i] = arr[midIndex + 1 + i];
    }
    let i = 0;
    let j = 0;
    let k = startIndex;
    while (i < len1 && j < len2) {
        if (comp(left[i], right[j]!).toInt() <= 0) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }
    while (i < len1) {
        arr[k] = left[i];
        k++;
        i++;
    }
    while (j < len2) {
        arr[k] = right[j];
        k++;
        j++;
    }
}

export function arr_sort_stable(arr: FixedArray<Short>, startIndex: int, endIndex: int, comp: (lhs: short, rhs: short) => number): void {
    if (endIndex <= startIndex) {
        return;
    }

    const INS_SORT_DELTA = 16
    for (let i = startIndex; i < endIndex; i += INS_SORT_DELTA ) {
        insertion_sort(arr, i, min(i + INS_SORT_DELTA , endIndex), comp)
    }
    if ((endIndex - startIndex) < INS_SORT_DELTA) {
        return;
    }
    for (let size = INS_SORT_DELTA; size < endIndex; size = 2 * size) {
        for (let left = startIndex; left < endIndex; left += 2 * size) {

            // Find ending point of left subarray and right subarray
            const mid = min(left + size - 1, endIndex - 1);
            const right = min((left + 2 * size - 1), (endIndex - 1));

            // Merge sub array arr[left.....mid] and arr[mid + 1....right]
            if (mid < right) {
                arr_perform_merge(arr, left, mid, right, comp);
            }
        }
    }
}
function insertion_sort(arr: FixedArray<Int>, startIndex: int, endIndex: int, comp: (lhs: int, rhs: int) => number): void {
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i];
        if (comp(tmp, arr[startIndex]).toInt() < 0) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let j = i - 1;
            while (comp(tmp, arr[j]).toInt() < 0) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = tmp;
        }
    }
}

function arr_perform_merge(arr: FixedArray<Int>, startIndex: int, midIndex: int, endIndex: int, comp: (lhs: int, rhs: int) => number): void {
    const len1 = midIndex - startIndex + 1;
    const len2 = endIndex - midIndex;
    let left : FixedArray<Int> = new Int[len1];
    let right : FixedArray<Int> = new Int[len2];
    for (let i = 0; i < len1; i++) {
        left[i] = arr[startIndex + i];
    }
    for (let i = 0; i < len2; i++) {
        right[i] = arr[midIndex + 1 + i];
    }
    let i = 0;
    let j = 0;
    let k = startIndex;
    while (i < len1 && j < len2) {
        if (comp(left[i], right[j]!).toInt() <= 0) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }
    while (i < len1) {
        arr[k] = left[i];
        k++;
        i++;
    }
    while (j < len2) {
        arr[k] = right[j];
        k++;
        j++;
    }
}

export function arr_sort_stable(arr: FixedArray<Int>, startIndex: int, endIndex: int, comp: (lhs: int, rhs: int) => number): void {
    if (endIndex <= startIndex) {
        return;
    }

    const INS_SORT_DELTA = 16
    for (let i = startIndex; i < endIndex; i += INS_SORT_DELTA ) {
        insertion_sort(arr, i, min(i + INS_SORT_DELTA , endIndex), comp)
    }
    if ((endIndex - startIndex) < INS_SORT_DELTA) {
        return;
    }
    for (let size = INS_SORT_DELTA; size < endIndex; size = 2 * size) {
        for (let left = startIndex; left < endIndex; left += 2 * size) {

            // Find ending point of left subarray and right subarray
            const mid = min(left + size - 1, endIndex - 1);
            const right = min((left + 2 * size - 1), (endIndex - 1));

            // Merge sub array arr[left.....mid] and arr[mid + 1....right]
            if (mid < right) {
                arr_perform_merge(arr, left, mid, right, comp);
            }
        }
    }
}
function insertion_sort(arr: FixedArray<Long>, startIndex: int, endIndex: int, comp: (lhs: long, rhs: long) => number): void {
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i];
        if (comp(tmp, arr[startIndex]).toInt() < 0) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let j = i - 1;
            while (comp(tmp, arr[j]).toInt() < 0) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = tmp;
        }
    }
}

function arr_perform_merge(arr: FixedArray<Long>, startIndex: int, midIndex: int, endIndex: int, comp: (lhs: long, rhs: long) => number): void {
    const len1 = midIndex - startIndex + 1;
    const len2 = endIndex - midIndex;
    let left : FixedArray<Long> = new Long[len1];
    let right : FixedArray<Long> = new Long[len2];
    for (let i = 0; i < len1; i++) {
        left[i] = arr[startIndex + i];
    }
    for (let i = 0; i < len2; i++) {
        right[i] = arr[midIndex + 1 + i];
    }
    let i = 0;
    let j = 0;
    let k = startIndex;
    while (i < len1 && j < len2) {
        if (comp(left[i], right[j]!).toInt() <= 0) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }
    while (i < len1) {
        arr[k] = left[i];
        k++;
        i++;
    }
    while (j < len2) {
        arr[k] = right[j];
        k++;
        j++;
    }
}

export function arr_sort_stable(arr: FixedArray<Long>, startIndex: int, endIndex: int, comp: (lhs: long, rhs: long) => number): void {
    if (endIndex <= startIndex) {
        return;
    }

    const INS_SORT_DELTA = 16
    for (let i = startIndex; i < endIndex; i += INS_SORT_DELTA ) {
        insertion_sort(arr, i, min(i + INS_SORT_DELTA , endIndex), comp)
    }
    if ((endIndex - startIndex) < INS_SORT_DELTA) {
        return;
    }
    for (let size = INS_SORT_DELTA; size < endIndex; size = 2 * size) {
        for (let left = startIndex; left < endIndex; left += 2 * size) {

            // Find ending point of left subarray and right subarray
            const mid = min(left + size - 1, endIndex - 1);
            const right = min((left + 2 * size - 1), (endIndex - 1));

            // Merge sub array arr[left.....mid] and arr[mid + 1....right]
            if (mid < right) {
                arr_perform_merge(arr, left, mid, right, comp);
            }
        }
    }
}
function insertion_sort(arr: FixedArray<Float>, startIndex: int, endIndex: int, comp: (lhs: float, rhs: float) => number): void {
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i];
        if (comp(tmp, arr[startIndex]).toInt() < 0) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let j = i - 1;
            while (comp(tmp, arr[j]).toInt() < 0) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = tmp;
        }
    }
}

function arr_perform_merge(arr: FixedArray<Float>, startIndex: int, midIndex: int, endIndex: int, comp: (lhs: float, rhs: float) => number): void {
    const len1 = midIndex - startIndex + 1;
    const len2 = endIndex - midIndex;
    let left : FixedArray<Float> = new Float[len1];
    let right : FixedArray<Float> = new Float[len2];
    for (let i = 0; i < len1; i++) {
        left[i] = arr[startIndex + i];
    }
    for (let i = 0; i < len2; i++) {
        right[i] = arr[midIndex + 1 + i];
    }
    let i = 0;
    let j = 0;
    let k = startIndex;
    while (i < len1 && j < len2) {
        if (comp(left[i], right[j]!).toInt() <= 0) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }
    while (i < len1) {
        arr[k] = left[i];
        k++;
        i++;
    }
    while (j < len2) {
        arr[k] = right[j];
        k++;
        j++;
    }
}

export function arr_sort_stable(arr: FixedArray<Float>, startIndex: int, endIndex: int, comp: (lhs: float, rhs: float) => number): void {
    if (endIndex <= startIndex) {
        return;
    }

    const INS_SORT_DELTA = 16
    for (let i = startIndex; i < endIndex; i += INS_SORT_DELTA ) {
        insertion_sort(arr, i, min(i + INS_SORT_DELTA , endIndex), comp)
    }
    if ((endIndex - startIndex) < INS_SORT_DELTA) {
        return;
    }
    for (let size = INS_SORT_DELTA; size < endIndex; size = 2 * size) {
        for (let left = startIndex; left < endIndex; left += 2 * size) {

            // Find ending point of left subarray and right subarray
            const mid = min(left + size - 1, endIndex - 1);
            const right = min((left + 2 * size - 1), (endIndex - 1));

            // Merge sub array arr[left.....mid] and arr[mid + 1....right]
            if (mid < right) {
                arr_perform_merge(arr, left, mid, right, comp);
            }
        }
    }
}
function insertion_sort(arr: FixedArray<Double>, startIndex: int, endIndex: int, comp: (lhs: double, rhs: double) => number): void {
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i];
        if (comp(tmp, arr[startIndex]).toInt() < 0) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let j = i - 1;
            while (comp(tmp, arr[j]).toInt() < 0) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = tmp;
        }
    }
}

function arr_perform_merge(arr: FixedArray<Double>, startIndex: int, midIndex: int, endIndex: int, comp: (lhs: double, rhs: double) => number): void {
    const len1 = midIndex - startIndex + 1;
    const len2 = endIndex - midIndex;
    let left : FixedArray<Double> = new Double[len1];
    let right : FixedArray<Double> = new Double[len2];
    for (let i = 0; i < len1; i++) {
        left[i] = arr[startIndex + i];
    }
    for (let i = 0; i < len2; i++) {
        right[i] = arr[midIndex + 1 + i];
    }
    let i = 0;
    let j = 0;
    let k = startIndex;
    while (i < len1 && j < len2) {
        if (comp(left[i], right[j]!).toInt() <= 0) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }
    while (i < len1) {
        arr[k] = left[i];
        k++;
        i++;
    }
    while (j < len2) {
        arr[k] = right[j];
        k++;
        j++;
    }
}

export function arr_sort_stable(arr: FixedArray<Double>, startIndex: int, endIndex: int, comp: (lhs: double, rhs: double) => number): void {
    if (endIndex <= startIndex) {
        return;
    }

    const INS_SORT_DELTA = 16
    for (let i = startIndex; i < endIndex; i += INS_SORT_DELTA ) {
        insertion_sort(arr, i, min(i + INS_SORT_DELTA , endIndex), comp)
    }
    if ((endIndex - startIndex) < INS_SORT_DELTA) {
        return;
    }
    for (let size = INS_SORT_DELTA; size < endIndex; size = 2 * size) {
        for (let left = startIndex; left < endIndex; left += 2 * size) {

            // Find ending point of left subarray and right subarray
            const mid = min(left + size - 1, endIndex - 1);
            const right = min((left + 2 * size - 1), (endIndex - 1));

            // Merge sub array arr[left.....mid] and arr[mid + 1....right]
            if (mid < right) {
                arr_perform_merge(arr, left, mid, right, comp);
            }
        }
    }
}

function insertionSort(arr: FixedArray<boolean>, startIndex: int, endIndex: int, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while (((tmp) ? 1 : 0) < ((arr[pos - 1]) ? 1 : 0)) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if (((tmp) ? 1 : 0) < ((arr[startIndex]) ? 1 : 0)) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while (((tmp) ? 1 : 0) < ((arr[pos - 1]) ? 1 : 0)) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort(arr: FixedArray<boolean>, startIndex: int, endIndex: int): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    countSortBools(arr, startIndex, endIndex)
}

export function swap(arr: FixedArray<boolean>, i: int, j: int): void {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

function insertionSort(arr: FixedArray<boolean>, startIndex: int, endIndex: int, mustPrecede: (lhs: boolean, rhs: boolean) => boolean, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if (mustPrecede(tmp, arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort_subarray(arr: FixedArray<boolean>, startIndex: int, endIndex: int, mustPrecede: (lhs: boolean, rhs: boolean) => boolean): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    if (mustPrecede(false, true)) {
        countSortBools(arr, startIndex, endIndex)
    } else {
        countSortBoolsInv(arr, startIndex, endIndex)
    }
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 */
export function sort_subarray(arr: FixedArray<boolean>, mustPrecede: (lhs: boolean, rhs: boolean) => boolean): void {
    sort_subarray(arr, 0, arr.length, mustPrecede);
}

export function sort_subarray(arr: FixedArray<boolean>, startIndex: int, mustPrecede: (lhs: boolean, rhs: boolean) => boolean): void {
    sort_subarray(arr, startIndex, arr.length, mustPrecede)
}

function countSortTruthCnt(arr: FixedArray<boolean>, startIndex: int, endIndex: int): int {
    let truthCnt = 0
    for (let i = startIndex; i < endIndex; i++) {
        if (arr[i]) {
            truthCnt++
        }
    }
    return truthCnt
}

function countSortBools(arr: FixedArray<boolean>, startIndex: int, endIndex: int): void {
    const truthCnt = countSortTruthCnt(arr, startIndex, endIndex)
    for (let i = startIndex; i < endIndex - truthCnt; i++) {
            arr[i] = false
        }
    for (let i = 0; i < truthCnt; i++) {
        arr[endIndex - truthCnt + i] = true
    }
}
function countSortBoolsInv(arr: FixedArray<boolean>, startIndex: int, endIndex: int): void {
    const truthCnt = countSortTruthCnt(arr, startIndex, endIndex)
    for (let i = 0; i < truthCnt; i++) {
        arr[startIndex + i] = true
    }
    for (let i = startIndex + truthCnt; i < endIndex; i++) {
        arr[i] = false
    }
}

function copyPart(dst: FixedArray<byte>, counter: int, src: FixedArray<byte>, start: int, end?: int) {
    if (end == undefined) {
        end = src.length
    }
    for (let i = start; i < end!; ++i) {
        dst[counter++] = src[i]
    }
}

function merge(left: FixedArray<byte>, right: FixedArray<byte>, cmp: (lhs: byte, rhs: byte) => number): FixedArray<byte> {
    const result:FixedArray<byte> = new byte[right.length + left.length]
    let leftIndex = 0;
    let rightIndex = 0;
    let counter: int = 0

    while (leftIndex < left.length &&
        rightIndex < right.length) {
        if (cmp(left[leftIndex], right[rightIndex]) <= 0) {
            result[counter++] = left[leftIndex];
            leftIndex++;
        } else {
            result[counter++] = right[rightIndex]
            rightIndex++;
        }
    }
    copyPart(result, counter, left, leftIndex)
    copyPart(result, counter, right, rightIndex)

    return result
}

export function mergeSort(array: FixedArray<byte>, cmp: (lhs: byte, rhs: byte) => number, begin: int = 0, end: int = 0): FixedArray<byte> {
    if (end == 0) {
        end = array.length
    }
    const arrLength = end - begin
    if (arrLength <= 1) {
        return array;
    }
    const middle = Math.floor(begin + arrLength / 2).toInt()
    const leftHalf:FixedArray<byte> = new byte[middle]
    let counter: int = 0
    copyPart(leftHalf, counter, array, 0, middle)

    counter = 0
    const rightHalf:FixedArray<byte> = new byte[arrLength - middle]
    copyPart(rightHalf, counter, array, middle)

    return merge(mergeSort(leftHalf, cmp), mergeSort(rightHalf, cmp), cmp);
}

function insertionSort(arr: FixedArray<byte>, startIndex: int, endIndex: int, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if ((tmp < arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<byte>, idxFromStart: int, startIndex: int, heapRoot: int): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!(arr[startIndex + p] < tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<byte>, idxFromStart: int, startIndex: int, endIndex: int): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if ((arr[childIndex] < arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot)
}

function heapSort(arr: FixedArray<byte>, startIndex: int, endIndex: int): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<byte>, index1: int, index2: int, index3: int): void {
    let swap_idx = index2
    if ((arr[index1] < arr[index2])) {
        if ((arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index3] < arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!(arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index2] < arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<byte>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((arr[i] < pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !(arr[j] < pivot)) {
            j--
        }
    } else {
        while (!(arr[j] < pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !(arr[i] < pivot) and (arr[j] < pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while ((arr[++i] < pivot)) {}
        while (!(arr[--j] < pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<byte>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((pivot < arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !(pivot < arr[i])) {
            i++
        }
    } else {
        while (!(pivot < arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here (pivot < arr[i]) and !(pivot < arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!(pivot < arr[++i])) {}
        while ((pivot < arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<byte>, startIndex: int, endIndex: int, maxDepth: int, initIndex: int = startIndex): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex)
            return
        }
        // Here we assume that current interval is not the most left in the sorted range
        if (startIndex != initIndex && arr[startIndex - 1] >= arr[startIndex]) {
            // We call quickSortSplitLeft here to move all elements equal to pivot (and arr[startIndex - 1]) to the left part;
            // after that only the right part needs to be sorted
            // If we always used quickSortSplitLeft instead of quickSortSplit, this would not work well for array
            // with many occurencies of the smallest element
            startIndex = quickSortSplitLeft(arr, startIndex, endIndex) + 1
            continue
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2)
        let p = quickSortSplit(arr, startIndex, endIndex)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, initIndex)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, initIndex)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, initIndex)
}

function quickSort(arr: FixedArray<byte>, startIndex: int, endIndex: int): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort(arr: FixedArray<byte>, startIndex: int, endIndex: int): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    if (endIndex - startIndex > 1024) {
        countSort(arr, startIndex, endIndex)
    }
    quickSort(arr, startIndex, endIndex);
}

export function swap(arr: FixedArray<byte>, i: int, j: int): void {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

function insertionSort(arr: FixedArray<byte>, startIndex: int, endIndex: int, mustPrecede: (lhs: byte, rhs: byte) => boolean, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if (mustPrecede(tmp, arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<byte>, idxFromStart: int, startIndex: int, heapRoot: int, mustPrecede: (lhs: byte, rhs: byte) => boolean): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!mustPrecede(arr[startIndex + p], tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<byte>, idxFromStart: int, startIndex: int, endIndex: int, mustPrecede: (lhs: byte, rhs: byte) => boolean): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if (mustPrecede(arr[childIndex], arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot, mustPrecede)
}

function heapSort(arr: FixedArray<byte>, startIndex: int, endIndex: int, mustPrecede: (lhs: byte, rhs: byte) => boolean): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex, mustPrecede)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i, mustPrecede)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<byte>, index1: int, index2: int, index3: int, mustPrecede: (lhs: byte, rhs: byte) => boolean): void {
    let swap_idx = index2
    if (mustPrecede(arr[index1], arr[index2])) {
        if (mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index3], arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index2], arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<byte>, startIndex: int, endIndex: int, mustPrecede: (lhs: byte, rhs: byte) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(arr[i], pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !mustPrecede(arr[j], pivot)) {
            j--
        }
    } else {
        while (!mustPrecede(arr[j], pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !mustPrecede(arr[i], pivot) and mustPrecede(arr[j], pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (mustPrecede(arr[++i], pivot)) {}
        while (!mustPrecede(arr[--j], pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<byte>, startIndex: int, endIndex: int, mustPrecede: (lhs: byte, rhs: byte) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(pivot, arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !mustPrecede(pivot, arr[i])) {
            i++
        }
    } else {
        while (!mustPrecede(pivot, arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here mustPrecede(pivot, arr[i]) and !mustPrecede(pivot, arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!mustPrecede(pivot, arr[++i])) {}
        while (mustPrecede(pivot, arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<byte>, startIndex: int, endIndex: int, maxDepth: int, mustPrecede: (lhs: byte, rhs: byte) => boolean): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex, mustPrecede)
            return
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2, mustPrecede)
        let p = quickSortSplit(arr, startIndex, endIndex, mustPrecede)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, mustPrecede)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, mustPrecede)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, mustPrecede)
}

function quickSort(arr: FixedArray<byte>, startIndex: int, endIndex: int, mustPrecede: (lhs: byte, rhs: byte) => boolean): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3, mustPrecede)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort_subarray(arr: FixedArray<byte>, startIndex: int, endIndex: int, mustPrecede: (lhs: byte, rhs: byte) => boolean): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex, mustPrecede);
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 */
export function sort_subarray(arr: FixedArray<byte>, mustPrecede: (lhs: byte, rhs: byte) => boolean): void {
    sort_subarray(arr, 0, arr.length, mustPrecede);
}

export function sort_subarray(arr: FixedArray<byte>, startIndex: int, mustPrecede: (lhs: byte, rhs: byte) => boolean): void {
    sort_subarray(arr, startIndex, arr.length, mustPrecede)
}

function countSort(arr: FixedArray<byte>, startIndex: int, endIndex: int): void {
    const cnts : FixedArray<int> = new int[256]
    for (let i = startIndex; i < endIndex; i++) {
        cnts[arr[i] + 128]++
    }
    let idx = 0
    for (let i = 0; i < 256; i++) {
        for (let j = 0; j < cnts[i]; j++) {
            arr[startIndex + idx++] = (i - 128).toByte()
        }
    }
}

function copyPart(dst: FixedArray<short>, counter: int, src: FixedArray<short>, start: int, end?: int) {
    if (end == undefined) {
        end = src.length
    }
    for (let i = start; i < end!; ++i) {
        dst[counter++] = src[i]
    }
}

function merge(left: FixedArray<short>, right: FixedArray<short>, cmp: (lhs: short, rhs: short) => number): FixedArray<short> {
    const result:FixedArray<short> = new short[right.length + left.length]
    let leftIndex = 0;
    let rightIndex = 0;
    let counter: int = 0

    while (leftIndex < left.length &&
        rightIndex < right.length) {
        if (cmp(left[leftIndex], right[rightIndex]) <= 0) {
            result[counter++] = left[leftIndex];
            leftIndex++;
        } else {
            result[counter++] = right[rightIndex]
            rightIndex++;
        }
    }
    copyPart(result, counter, left, leftIndex)
    copyPart(result, counter, right, rightIndex)

    return result
}

export function mergeSort(array: FixedArray<short>, cmp: (lhs: short, rhs: short) => number, begin: int = 0, end: int = 0): FixedArray<short> {
    if (end == 0) {
        end = array.length
    }
    const arrLength = end - begin
    if (arrLength <= 1) {
        return array;
    }
    const middle = Math.floor(begin + arrLength / 2).toInt()
    const leftHalf:FixedArray<short> = new short[middle]
    let counter: int = 0
    copyPart(leftHalf, counter, array, 0, middle)

    counter = 0
    const rightHalf:FixedArray<short> = new short[arrLength - middle]
    copyPart(rightHalf, counter, array, middle)

    return merge(mergeSort(leftHalf, cmp), mergeSort(rightHalf, cmp), cmp);
}

function insertionSort(arr: FixedArray<short>, startIndex: int, endIndex: int, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if ((tmp < arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<short>, idxFromStart: int, startIndex: int, heapRoot: int): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!(arr[startIndex + p] < tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<short>, idxFromStart: int, startIndex: int, endIndex: int): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if ((arr[childIndex] < arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot)
}

function heapSort(arr: FixedArray<short>, startIndex: int, endIndex: int): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<short>, index1: int, index2: int, index3: int): void {
    let swap_idx = index2
    if ((arr[index1] < arr[index2])) {
        if ((arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index3] < arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!(arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index2] < arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<short>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((arr[i] < pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !(arr[j] < pivot)) {
            j--
        }
    } else {
        while (!(arr[j] < pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !(arr[i] < pivot) and (arr[j] < pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while ((arr[++i] < pivot)) {}
        while (!(arr[--j] < pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<short>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((pivot < arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !(pivot < arr[i])) {
            i++
        }
    } else {
        while (!(pivot < arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here (pivot < arr[i]) and !(pivot < arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!(pivot < arr[++i])) {}
        while ((pivot < arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<short>, startIndex: int, endIndex: int, maxDepth: int, initIndex: int = startIndex): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex)
            return
        }
        // Here we assume that current interval is not the most left in the sorted range
        if (startIndex != initIndex && arr[startIndex - 1] >= arr[startIndex]) {
            // We call quickSortSplitLeft here to move all elements equal to pivot (and arr[startIndex - 1]) to the left part;
            // after that only the right part needs to be sorted
            // If we always used quickSortSplitLeft instead of quickSortSplit, this would not work well for array
            // with many occurencies of the smallest element
            startIndex = quickSortSplitLeft(arr, startIndex, endIndex) + 1
            continue
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2)
        let p = quickSortSplit(arr, startIndex, endIndex)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, initIndex)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, initIndex)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, initIndex)
}

function quickSort(arr: FixedArray<short>, startIndex: int, endIndex: int): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort(arr: FixedArray<short>, startIndex: int, endIndex: int): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex);
}

export function swap(arr: FixedArray<short>, i: int, j: int): void {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

function insertionSort(arr: FixedArray<short>, startIndex: int, endIndex: int, mustPrecede: (lhs: short, rhs: short) => boolean, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if (mustPrecede(tmp, arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<short>, idxFromStart: int, startIndex: int, heapRoot: int, mustPrecede: (lhs: short, rhs: short) => boolean): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!mustPrecede(arr[startIndex + p], tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<short>, idxFromStart: int, startIndex: int, endIndex: int, mustPrecede: (lhs: short, rhs: short) => boolean): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if (mustPrecede(arr[childIndex], arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot, mustPrecede)
}

function heapSort(arr: FixedArray<short>, startIndex: int, endIndex: int, mustPrecede: (lhs: short, rhs: short) => boolean): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex, mustPrecede)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i, mustPrecede)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<short>, index1: int, index2: int, index3: int, mustPrecede: (lhs: short, rhs: short) => boolean): void {
    let swap_idx = index2
    if (mustPrecede(arr[index1], arr[index2])) {
        if (mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index3], arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index2], arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<short>, startIndex: int, endIndex: int, mustPrecede: (lhs: short, rhs: short) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(arr[i], pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !mustPrecede(arr[j], pivot)) {
            j--
        }
    } else {
        while (!mustPrecede(arr[j], pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !mustPrecede(arr[i], pivot) and mustPrecede(arr[j], pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (mustPrecede(arr[++i], pivot)) {}
        while (!mustPrecede(arr[--j], pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<short>, startIndex: int, endIndex: int, mustPrecede: (lhs: short, rhs: short) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(pivot, arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !mustPrecede(pivot, arr[i])) {
            i++
        }
    } else {
        while (!mustPrecede(pivot, arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here mustPrecede(pivot, arr[i]) and !mustPrecede(pivot, arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!mustPrecede(pivot, arr[++i])) {}
        while (mustPrecede(pivot, arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<short>, startIndex: int, endIndex: int, maxDepth: int, mustPrecede: (lhs: short, rhs: short) => boolean): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex, mustPrecede)
            return
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2, mustPrecede)
        let p = quickSortSplit(arr, startIndex, endIndex, mustPrecede)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, mustPrecede)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, mustPrecede)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, mustPrecede)
}

function quickSort(arr: FixedArray<short>, startIndex: int, endIndex: int, mustPrecede: (lhs: short, rhs: short) => boolean): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3, mustPrecede)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort_subarray(arr: FixedArray<short>, startIndex: int, endIndex: int, mustPrecede: (lhs: short, rhs: short) => boolean): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex, mustPrecede);
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 */
export function sort_subarray(arr: FixedArray<short>, mustPrecede: (lhs: short, rhs: short) => boolean): void {
    sort_subarray(arr, 0, arr.length, mustPrecede);
}

export function sort_subarray(arr: FixedArray<short>, startIndex: int, mustPrecede: (lhs: short, rhs: short) => boolean): void {
    sort_subarray(arr, startIndex, arr.length, mustPrecede)
}

function copyPart(dst: FixedArray<int>, counter: int, src: FixedArray<int>, start: int, end?: int) {
    if (end == undefined) {
        end = src.length
    }
    for (let i = start; i < end!; ++i) {
        dst[counter++] = src[i]
    }
}

function merge(left: FixedArray<int>, right: FixedArray<int>, cmp: (lhs: int, rhs: int) => number): FixedArray<int> {
    const result:FixedArray<int> = new int[right.length + left.length]
    let leftIndex = 0;
    let rightIndex = 0;
    let counter: int = 0

    while (leftIndex < left.length &&
        rightIndex < right.length) {
        if (cmp(left[leftIndex], right[rightIndex]) <= 0) {
            result[counter++] = left[leftIndex];
            leftIndex++;
        } else {
            result[counter++] = right[rightIndex]
            rightIndex++;
        }
    }
    copyPart(result, counter, left, leftIndex)
    copyPart(result, counter, right, rightIndex)

    return result
}

export function mergeSort(array: FixedArray<int>, cmp: (lhs: int, rhs: int) => number, begin: int = 0, end: int = 0): FixedArray<int> {
    if (end == 0) {
        end = array.length
    }
    const arrLength = end - begin
    if (arrLength <= 1) {
        return array;
    }
    const middle = Math.floor(begin + arrLength / 2).toInt()
    const leftHalf:FixedArray<int> = new int[middle]
    let counter: int = 0
    copyPart(leftHalf, counter, array, 0, middle)

    counter = 0
    const rightHalf:FixedArray<int> = new int[arrLength - middle]
    copyPart(rightHalf, counter, array, middle)

    return merge(mergeSort(leftHalf, cmp), mergeSort(rightHalf, cmp), cmp);
}

function insertionSort(arr: FixedArray<int>, startIndex: int, endIndex: int, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if ((tmp < arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<int>, idxFromStart: int, startIndex: int, heapRoot: int): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!(arr[startIndex + p] < tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<int>, idxFromStart: int, startIndex: int, endIndex: int): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if ((arr[childIndex] < arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot)
}

function heapSort(arr: FixedArray<int>, startIndex: int, endIndex: int): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<int>, index1: int, index2: int, index3: int): void {
    let swap_idx = index2
    if ((arr[index1] < arr[index2])) {
        if ((arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index3] < arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!(arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index2] < arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<int>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((arr[i] < pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !(arr[j] < pivot)) {
            j--
        }
    } else {
        while (!(arr[j] < pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !(arr[i] < pivot) and (arr[j] < pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while ((arr[++i] < pivot)) {}
        while (!(arr[--j] < pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<int>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((pivot < arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !(pivot < arr[i])) {
            i++
        }
    } else {
        while (!(pivot < arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here (pivot < arr[i]) and !(pivot < arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!(pivot < arr[++i])) {}
        while ((pivot < arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<int>, startIndex: int, endIndex: int, maxDepth: int, initIndex: int = startIndex): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex)
            return
        }
        // Here we assume that current interval is not the most left in the sorted range
        if (startIndex != initIndex && arr[startIndex - 1] >= arr[startIndex]) {
            // We call quickSortSplitLeft here to move all elements equal to pivot (and arr[startIndex - 1]) to the left part;
            // after that only the right part needs to be sorted
            // If we always used quickSortSplitLeft instead of quickSortSplit, this would not work well for array
            // with many occurencies of the smallest element
            startIndex = quickSortSplitLeft(arr, startIndex, endIndex) + 1
            continue
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2)
        let p = quickSortSplit(arr, startIndex, endIndex)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, initIndex)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, initIndex)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, initIndex)
}

function quickSort(arr: FixedArray<int>, startIndex: int, endIndex: int): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort(arr: FixedArray<int>, startIndex: int, endIndex: int): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex);
}

export function swap(arr: FixedArray<int>, i: int, j: int): void {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

function insertionSort(arr: FixedArray<int>, startIndex: int, endIndex: int, mustPrecede: (lhs: int, rhs: int) => boolean, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if (mustPrecede(tmp, arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<int>, idxFromStart: int, startIndex: int, heapRoot: int, mustPrecede: (lhs: int, rhs: int) => boolean): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!mustPrecede(arr[startIndex + p], tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<int>, idxFromStart: int, startIndex: int, endIndex: int, mustPrecede: (lhs: int, rhs: int) => boolean): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if (mustPrecede(arr[childIndex], arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot, mustPrecede)
}

function heapSort(arr: FixedArray<int>, startIndex: int, endIndex: int, mustPrecede: (lhs: int, rhs: int) => boolean): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex, mustPrecede)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i, mustPrecede)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<int>, index1: int, index2: int, index3: int, mustPrecede: (lhs: int, rhs: int) => boolean): void {
    let swap_idx = index2
    if (mustPrecede(arr[index1], arr[index2])) {
        if (mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index3], arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index2], arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<int>, startIndex: int, endIndex: int, mustPrecede: (lhs: int, rhs: int) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(arr[i], pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !mustPrecede(arr[j], pivot)) {
            j--
        }
    } else {
        while (!mustPrecede(arr[j], pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !mustPrecede(arr[i], pivot) and mustPrecede(arr[j], pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (mustPrecede(arr[++i], pivot)) {}
        while (!mustPrecede(arr[--j], pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<int>, startIndex: int, endIndex: int, mustPrecede: (lhs: int, rhs: int) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(pivot, arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !mustPrecede(pivot, arr[i])) {
            i++
        }
    } else {
        while (!mustPrecede(pivot, arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here mustPrecede(pivot, arr[i]) and !mustPrecede(pivot, arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!mustPrecede(pivot, arr[++i])) {}
        while (mustPrecede(pivot, arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<int>, startIndex: int, endIndex: int, maxDepth: int, mustPrecede: (lhs: int, rhs: int) => boolean): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex, mustPrecede)
            return
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2, mustPrecede)
        let p = quickSortSplit(arr, startIndex, endIndex, mustPrecede)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, mustPrecede)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, mustPrecede)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, mustPrecede)
}

function quickSort(arr: FixedArray<int>, startIndex: int, endIndex: int, mustPrecede: (lhs: int, rhs: int) => boolean): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3, mustPrecede)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort_subarray(arr: FixedArray<int>, startIndex: int, endIndex: int, mustPrecede: (lhs: int, rhs: int) => boolean): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex, mustPrecede);
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 */
export function sort_subarray(arr: FixedArray<int>, mustPrecede: (lhs: int, rhs: int) => boolean): void {
    sort_subarray(arr, 0, arr.length, mustPrecede);
}

export function sort_subarray(arr: FixedArray<int>, startIndex: int, mustPrecede: (lhs: int, rhs: int) => boolean): void {
    sort_subarray(arr, startIndex, arr.length, mustPrecede)
}

function copyPart(dst: FixedArray<long>, counter: int, src: FixedArray<long>, start: int, end?: int) {
    if (end == undefined) {
        end = src.length
    }
    for (let i = start; i < end!; ++i) {
        dst[counter++] = src[i]
    }
}

function merge(left: FixedArray<long>, right: FixedArray<long>, cmp: (lhs: long, rhs: long) => number): FixedArray<long> {
    const result:FixedArray<long> = new long[right.length + left.length]
    let leftIndex = 0;
    let rightIndex = 0;
    let counter: int = 0

    while (leftIndex < left.length &&
        rightIndex < right.length) {
        if (cmp(left[leftIndex], right[rightIndex]) <= 0) {
            result[counter++] = left[leftIndex];
            leftIndex++;
        } else {
            result[counter++] = right[rightIndex]
            rightIndex++;
        }
    }
    copyPart(result, counter, left, leftIndex)
    copyPart(result, counter, right, rightIndex)

    return result
}

export function mergeSort(array: FixedArray<long>, cmp: (lhs: long, rhs: long) => number, begin: int = 0, end: int = 0): FixedArray<long> {
    if (end == 0) {
        end = array.length
    }
    const arrLength = end - begin
    if (arrLength <= 1) {
        return array;
    }
    const middle = Math.floor(begin + arrLength / 2).toInt()
    const leftHalf:FixedArray<long> = new long[middle]
    let counter: int = 0
    copyPart(leftHalf, counter, array, 0, middle)

    counter = 0
    const rightHalf:FixedArray<long> = new long[arrLength - middle]
    copyPart(rightHalf, counter, array, middle)

    return merge(mergeSort(leftHalf, cmp), mergeSort(rightHalf, cmp), cmp);
}

function insertionSort(arr: FixedArray<long>, startIndex: int, endIndex: int, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if ((tmp < arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<long>, idxFromStart: int, startIndex: int, heapRoot: int): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!(arr[startIndex + p] < tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<long>, idxFromStart: int, startIndex: int, endIndex: int): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if ((arr[childIndex] < arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot)
}

function heapSort(arr: FixedArray<long>, startIndex: int, endIndex: int): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<long>, index1: int, index2: int, index3: int): void {
    let swap_idx = index2
    if ((arr[index1] < arr[index2])) {
        if ((arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index3] < arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!(arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index2] < arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<long>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((arr[i] < pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !(arr[j] < pivot)) {
            j--
        }
    } else {
        while (!(arr[j] < pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !(arr[i] < pivot) and (arr[j] < pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while ((arr[++i] < pivot)) {}
        while (!(arr[--j] < pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<long>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((pivot < arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !(pivot < arr[i])) {
            i++
        }
    } else {
        while (!(pivot < arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here (pivot < arr[i]) and !(pivot < arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!(pivot < arr[++i])) {}
        while ((pivot < arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<long>, startIndex: int, endIndex: int, maxDepth: int, initIndex: int = startIndex): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex)
            return
        }
        // Here we assume that current interval is not the most left in the sorted range
        if (startIndex != initIndex && arr[startIndex - 1] >= arr[startIndex]) {
            // We call quickSortSplitLeft here to move all elements equal to pivot (and arr[startIndex - 1]) to the left part;
            // after that only the right part needs to be sorted
            // If we always used quickSortSplitLeft instead of quickSortSplit, this would not work well for array
            // with many occurencies of the smallest element
            startIndex = quickSortSplitLeft(arr, startIndex, endIndex) + 1
            continue
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2)
        let p = quickSortSplit(arr, startIndex, endIndex)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, initIndex)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, initIndex)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, initIndex)
}

function quickSort(arr: FixedArray<long>, startIndex: int, endIndex: int): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort(arr: FixedArray<long>, startIndex: int, endIndex: int): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex);
}

export function swap(arr: FixedArray<long>, i: int, j: int): void {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

function insertionSort(arr: FixedArray<long>, startIndex: int, endIndex: int, mustPrecede: (lhs: long, rhs: long) => boolean, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if (mustPrecede(tmp, arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<long>, idxFromStart: int, startIndex: int, heapRoot: int, mustPrecede: (lhs: long, rhs: long) => boolean): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!mustPrecede(arr[startIndex + p], tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<long>, idxFromStart: int, startIndex: int, endIndex: int, mustPrecede: (lhs: long, rhs: long) => boolean): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if (mustPrecede(arr[childIndex], arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot, mustPrecede)
}

function heapSort(arr: FixedArray<long>, startIndex: int, endIndex: int, mustPrecede: (lhs: long, rhs: long) => boolean): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex, mustPrecede)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i, mustPrecede)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<long>, index1: int, index2: int, index3: int, mustPrecede: (lhs: long, rhs: long) => boolean): void {
    let swap_idx = index2
    if (mustPrecede(arr[index1], arr[index2])) {
        if (mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index3], arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index2], arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<long>, startIndex: int, endIndex: int, mustPrecede: (lhs: long, rhs: long) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(arr[i], pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !mustPrecede(arr[j], pivot)) {
            j--
        }
    } else {
        while (!mustPrecede(arr[j], pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !mustPrecede(arr[i], pivot) and mustPrecede(arr[j], pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (mustPrecede(arr[++i], pivot)) {}
        while (!mustPrecede(arr[--j], pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<long>, startIndex: int, endIndex: int, mustPrecede: (lhs: long, rhs: long) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(pivot, arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !mustPrecede(pivot, arr[i])) {
            i++
        }
    } else {
        while (!mustPrecede(pivot, arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here mustPrecede(pivot, arr[i]) and !mustPrecede(pivot, arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!mustPrecede(pivot, arr[++i])) {}
        while (mustPrecede(pivot, arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<long>, startIndex: int, endIndex: int, maxDepth: int, mustPrecede: (lhs: long, rhs: long) => boolean): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex, mustPrecede)
            return
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2, mustPrecede)
        let p = quickSortSplit(arr, startIndex, endIndex, mustPrecede)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, mustPrecede)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, mustPrecede)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, mustPrecede)
}

function quickSort(arr: FixedArray<long>, startIndex: int, endIndex: int, mustPrecede: (lhs: long, rhs: long) => boolean): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3, mustPrecede)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort_subarray(arr: FixedArray<long>, startIndex: int, endIndex: int, mustPrecede: (lhs: long, rhs: long) => boolean): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex, mustPrecede);
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 */
export function sort_subarray(arr: FixedArray<long>, mustPrecede: (lhs: long, rhs: long) => boolean): void {
    sort_subarray(arr, 0, arr.length, mustPrecede);
}

export function sort_subarray(arr: FixedArray<long>, startIndex: int, mustPrecede: (lhs: long, rhs: long) => boolean): void {
    sort_subarray(arr, startIndex, arr.length, mustPrecede)
}

function copyPart(dst: FixedArray<float>, counter: int, src: FixedArray<float>, start: int, end?: int) {
    if (end == undefined) {
        end = src.length
    }
    for (let i = start; i < end!; ++i) {
        dst[counter++] = src[i]
    }
}

function merge(left: FixedArray<float>, right: FixedArray<float>, cmp: (lhs: float, rhs: float) => number): FixedArray<float> {
    const result:FixedArray<float> = new float[right.length + left.length]
    let leftIndex = 0;
    let rightIndex = 0;
    let counter: int = 0

    while (leftIndex < left.length &&
        rightIndex < right.length) {
        if (cmp(left[leftIndex], right[rightIndex]) <= 0) {
            result[counter++] = left[leftIndex];
            leftIndex++;
        } else {
            result[counter++] = right[rightIndex]
            rightIndex++;
        }
    }
    copyPart(result, counter, left, leftIndex)
    copyPart(result, counter, right, rightIndex)

    return result
}

export function mergeSort(array: FixedArray<float>, cmp: (lhs: float, rhs: float) => number, begin: int = 0, end: int = 0): FixedArray<float> {
    if (end == 0) {
        end = array.length
    }
    const arrLength = end - begin
    if (arrLength <= 1) {
        return array;
    }
    const middle = Math.floor(begin + arrLength / 2).toInt()
    const leftHalf:FixedArray<float> = new float[middle]
    let counter: int = 0
    copyPart(leftHalf, counter, array, 0, middle)

    counter = 0
    const rightHalf:FixedArray<float> = new float[arrLength - middle]
    copyPart(rightHalf, counter, array, middle)

    return merge(mergeSort(leftHalf, cmp), mergeSort(rightHalf, cmp), cmp);
}

function insertionSort(arr: FixedArray<float>, startIndex: int, endIndex: int, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if ((tmp < arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<float>, idxFromStart: int, startIndex: int, heapRoot: int): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!(arr[startIndex + p] < tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<float>, idxFromStart: int, startIndex: int, endIndex: int): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if ((arr[childIndex] < arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot)
}

function heapSort(arr: FixedArray<float>, startIndex: int, endIndex: int): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<float>, index1: int, index2: int, index3: int): void {
    let swap_idx = index2
    if ((arr[index1] < arr[index2])) {
        if ((arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index3] < arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!(arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index2] < arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<float>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((arr[i] < pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !(arr[j] < pivot)) {
            j--
        }
    } else {
        while (!(arr[j] < pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !(arr[i] < pivot) and (arr[j] < pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while ((arr[++i] < pivot)) {}
        while (!(arr[--j] < pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<float>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((pivot < arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !(pivot < arr[i])) {
            i++
        }
    } else {
        while (!(pivot < arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here (pivot < arr[i]) and !(pivot < arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!(pivot < arr[++i])) {}
        while ((pivot < arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<float>, startIndex: int, endIndex: int, maxDepth: int, initIndex: int = startIndex): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex)
            return
        }
        // Here we assume that current interval is not the most left in the sorted range
        if (startIndex != initIndex && arr[startIndex - 1] >= arr[startIndex]) {
            // We call quickSortSplitLeft here to move all elements equal to pivot (and arr[startIndex - 1]) to the left part;
            // after that only the right part needs to be sorted
            // If we always used quickSortSplitLeft instead of quickSortSplit, this would not work well for array
            // with many occurencies of the smallest element
            startIndex = quickSortSplitLeft(arr, startIndex, endIndex) + 1
            continue
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2)
        let p = quickSortSplit(arr, startIndex, endIndex)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, initIndex)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, initIndex)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, initIndex)
}

function quickSort(arr: FixedArray<float>, startIndex: int, endIndex: int): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort(arr: FixedArray<float>, startIndex: int, endIndex: int): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex);
}

export function swap(arr: FixedArray<float>, i: int, j: int): void {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

function insertionSort(arr: FixedArray<float>, startIndex: int, endIndex: int, mustPrecede: (lhs: float, rhs: float) => boolean, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if (mustPrecede(tmp, arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<float>, idxFromStart: int, startIndex: int, heapRoot: int, mustPrecede: (lhs: float, rhs: float) => boolean): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!mustPrecede(arr[startIndex + p], tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<float>, idxFromStart: int, startIndex: int, endIndex: int, mustPrecede: (lhs: float, rhs: float) => boolean): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if (mustPrecede(arr[childIndex], arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot, mustPrecede)
}

function heapSort(arr: FixedArray<float>, startIndex: int, endIndex: int, mustPrecede: (lhs: float, rhs: float) => boolean): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex, mustPrecede)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i, mustPrecede)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<float>, index1: int, index2: int, index3: int, mustPrecede: (lhs: float, rhs: float) => boolean): void {
    let swap_idx = index2
    if (mustPrecede(arr[index1], arr[index2])) {
        if (mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index3], arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index2], arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<float>, startIndex: int, endIndex: int, mustPrecede: (lhs: float, rhs: float) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(arr[i], pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !mustPrecede(arr[j], pivot)) {
            j--
        }
    } else {
        while (!mustPrecede(arr[j], pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !mustPrecede(arr[i], pivot) and mustPrecede(arr[j], pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (mustPrecede(arr[++i], pivot)) {}
        while (!mustPrecede(arr[--j], pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<float>, startIndex: int, endIndex: int, mustPrecede: (lhs: float, rhs: float) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(pivot, arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !mustPrecede(pivot, arr[i])) {
            i++
        }
    } else {
        while (!mustPrecede(pivot, arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here mustPrecede(pivot, arr[i]) and !mustPrecede(pivot, arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!mustPrecede(pivot, arr[++i])) {}
        while (mustPrecede(pivot, arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<float>, startIndex: int, endIndex: int, maxDepth: int, mustPrecede: (lhs: float, rhs: float) => boolean): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex, mustPrecede)
            return
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2, mustPrecede)
        let p = quickSortSplit(arr, startIndex, endIndex, mustPrecede)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, mustPrecede)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, mustPrecede)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, mustPrecede)
}

function quickSort(arr: FixedArray<float>, startIndex: int, endIndex: int, mustPrecede: (lhs: float, rhs: float) => boolean): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3, mustPrecede)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort_subarray(arr: FixedArray<float>, startIndex: int, endIndex: int, mustPrecede: (lhs: float, rhs: float) => boolean): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex, mustPrecede);
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 */
export function sort_subarray(arr: FixedArray<float>, mustPrecede: (lhs: float, rhs: float) => boolean): void {
    sort_subarray(arr, 0, arr.length, mustPrecede);
}

export function sort_subarray(arr: FixedArray<float>, startIndex: int, mustPrecede: (lhs: float, rhs: float) => boolean): void {
    sort_subarray(arr, startIndex, arr.length, mustPrecede)
}

function copyPart(dst: FixedArray<double>, counter: int, src: FixedArray<double>, start: int, end?: int) {
    if (end == undefined) {
        end = src.length
    }
    for (let i = start; i < end!; ++i) {
        dst[counter++] = src[i]
    }
}

function merge(left: FixedArray<double>, right: FixedArray<double>, cmp: (lhs: double, rhs: double) => number): FixedArray<double> {
    const result:FixedArray<double> = new double[right.length + left.length]
    let leftIndex = 0;
    let rightIndex = 0;
    let counter: int = 0

    while (leftIndex < left.length &&
        rightIndex < right.length) {
        if (cmp(left[leftIndex], right[rightIndex]) <= 0) {
            result[counter++] = left[leftIndex];
            leftIndex++;
        } else {
            result[counter++] = right[rightIndex]
            rightIndex++;
        }
    }
    copyPart(result, counter, left, leftIndex)
    copyPart(result, counter, right, rightIndex)

    return result
}

export function mergeSort(array: FixedArray<double>, cmp: (lhs: double, rhs: double) => number, begin: int = 0, end: int = 0): FixedArray<double> {
    if (end == 0) {
        end = array.length
    }
    const arrLength = end - begin
    if (arrLength <= 1) {
        return array;
    }
    const middle = Math.floor(begin + arrLength / 2).toInt()
    const leftHalf:FixedArray<double> = new double[middle]
    let counter: int = 0
    copyPart(leftHalf, counter, array, 0, middle)

    counter = 0
    const rightHalf:FixedArray<double> = new double[arrLength - middle]
    copyPart(rightHalf, counter, array, middle)

    return merge(mergeSort(leftHalf, cmp), mergeSort(rightHalf, cmp), cmp);
}

function insertionSort(arr: FixedArray<double>, startIndex: int, endIndex: int, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if ((tmp < arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<double>, idxFromStart: int, startIndex: int, heapRoot: int): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!(arr[startIndex + p] < tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<double>, idxFromStart: int, startIndex: int, endIndex: int): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if ((arr[childIndex] < arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot)
}

function heapSort(arr: FixedArray<double>, startIndex: int, endIndex: int): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<double>, index1: int, index2: int, index3: int): void {
    let swap_idx = index2
    if ((arr[index1] < arr[index2])) {
        if ((arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index3] < arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!(arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index2] < arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<double>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((arr[i] < pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !(arr[j] < pivot)) {
            j--
        }
    } else {
        while (!(arr[j] < pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !(arr[i] < pivot) and (arr[j] < pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while ((arr[++i] < pivot)) {}
        while (!(arr[--j] < pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<double>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((pivot < arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !(pivot < arr[i])) {
            i++
        }
    } else {
        while (!(pivot < arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here (pivot < arr[i]) and !(pivot < arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!(pivot < arr[++i])) {}
        while ((pivot < arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<double>, startIndex: int, endIndex: int, maxDepth: int, initIndex: int = startIndex): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex)
            return
        }
        // Here we assume that current interval is not the most left in the sorted range
        if (startIndex != initIndex && arr[startIndex - 1] >= arr[startIndex]) {
            // We call quickSortSplitLeft here to move all elements equal to pivot (and arr[startIndex - 1]) to the left part;
            // after that only the right part needs to be sorted
            // If we always used quickSortSplitLeft instead of quickSortSplit, this would not work well for array
            // with many occurencies of the smallest element
            startIndex = quickSortSplitLeft(arr, startIndex, endIndex) + 1
            continue
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2)
        let p = quickSortSplit(arr, startIndex, endIndex)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, initIndex)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, initIndex)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, initIndex)
}

function quickSort(arr: FixedArray<double>, startIndex: int, endIndex: int): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort(arr: FixedArray<double>, startIndex: int, endIndex: int): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex);
}

export function swap(arr: FixedArray<double>, i: int, j: int): void {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

function insertionSort(arr: FixedArray<double>, startIndex: int, endIndex: int, mustPrecede: (lhs: double, rhs: double) => boolean, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if (mustPrecede(tmp, arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<double>, idxFromStart: int, startIndex: int, heapRoot: int, mustPrecede: (lhs: double, rhs: double) => boolean): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!mustPrecede(arr[startIndex + p], tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<double>, idxFromStart: int, startIndex: int, endIndex: int, mustPrecede: (lhs: double, rhs: double) => boolean): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if (mustPrecede(arr[childIndex], arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot, mustPrecede)
}

function heapSort(arr: FixedArray<double>, startIndex: int, endIndex: int, mustPrecede: (lhs: double, rhs: double) => boolean): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex, mustPrecede)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i, mustPrecede)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<double>, index1: int, index2: int, index3: int, mustPrecede: (lhs: double, rhs: double) => boolean): void {
    let swap_idx = index2
    if (mustPrecede(arr[index1], arr[index2])) {
        if (mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index3], arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index2], arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<double>, startIndex: int, endIndex: int, mustPrecede: (lhs: double, rhs: double) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(arr[i], pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !mustPrecede(arr[j], pivot)) {
            j--
        }
    } else {
        while (!mustPrecede(arr[j], pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !mustPrecede(arr[i], pivot) and mustPrecede(arr[j], pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (mustPrecede(arr[++i], pivot)) {}
        while (!mustPrecede(arr[--j], pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<double>, startIndex: int, endIndex: int, mustPrecede: (lhs: double, rhs: double) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(pivot, arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !mustPrecede(pivot, arr[i])) {
            i++
        }
    } else {
        while (!mustPrecede(pivot, arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here mustPrecede(pivot, arr[i]) and !mustPrecede(pivot, arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!mustPrecede(pivot, arr[++i])) {}
        while (mustPrecede(pivot, arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<double>, startIndex: int, endIndex: int, maxDepth: int, mustPrecede: (lhs: double, rhs: double) => boolean): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex, mustPrecede)
            return
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2, mustPrecede)
        let p = quickSortSplit(arr, startIndex, endIndex, mustPrecede)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, mustPrecede)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, mustPrecede)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, mustPrecede)
}

function quickSort(arr: FixedArray<double>, startIndex: int, endIndex: int, mustPrecede: (lhs: double, rhs: double) => boolean): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3, mustPrecede)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort_subarray(arr: FixedArray<double>, startIndex: int, endIndex: int, mustPrecede: (lhs: double, rhs: double) => boolean): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex, mustPrecede);
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 */
export function sort_subarray(arr: FixedArray<double>, mustPrecede: (lhs: double, rhs: double) => boolean): void {
    sort_subarray(arr, 0, arr.length, mustPrecede);
}

export function sort_subarray(arr: FixedArray<double>, startIndex: int, mustPrecede: (lhs: double, rhs: double) => boolean): void {
    sort_subarray(arr, startIndex, arr.length, mustPrecede)
}

function insertionSort(arr: FixedArray<char>, startIndex: int, endIndex: int, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if ((tmp < arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while ((tmp < arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<char>, idxFromStart: int, startIndex: int, heapRoot: int): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!(arr[startIndex + p] < tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<char>, idxFromStart: int, startIndex: int, endIndex: int): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if ((arr[childIndex] < arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot)
}

function heapSort(arr: FixedArray<char>, startIndex: int, endIndex: int): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<char>, index1: int, index2: int, index3: int): void {
    let swap_idx = index2
    if ((arr[index1] < arr[index2])) {
        if ((arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index3] < arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!(arr[index3] < arr[index1])) {
            return
        }
        if ((arr[index2] < arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<char>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((arr[i] < pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !(arr[j] < pivot)) {
            j--
        }
    } else {
        while (!(arr[j] < pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !(arr[i] < pivot) and (arr[j] < pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while ((arr[++i] < pivot)) {}
        while (!(arr[--j] < pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<char>, startIndex: int, endIndex: int): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while ((pivot < arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !(pivot < arr[i])) {
            i++
        }
    } else {
        while (!(pivot < arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here (pivot < arr[i]) and !(pivot < arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!(pivot < arr[++i])) {}
        while ((pivot < arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<char>, startIndex: int, endIndex: int, maxDepth: int, initIndex: int = startIndex): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex)
            return
        }
        // Here we assume that current interval is not the most left in the sorted range
        if (startIndex != initIndex && arr[startIndex - 1] >= arr[startIndex]) {
            // We call quickSortSplitLeft here to move all elements equal to pivot (and arr[startIndex - 1]) to the left part;
            // after that only the right part needs to be sorted
            // If we always used quickSortSplitLeft instead of quickSortSplit, this would not work well for array
            // with many occurencies of the smallest element
            startIndex = quickSortSplitLeft(arr, startIndex, endIndex) + 1
            continue
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2)
        let p = quickSortSplit(arr, startIndex, endIndex)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, initIndex)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, initIndex)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, initIndex)
}

function quickSort(arr: FixedArray<char>, startIndex: int, endIndex: int): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort(arr: FixedArray<char>, startIndex: int, endIndex: int): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex);
}

export function swap(arr: FixedArray<char>, i: int, j: int): void {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

function insertionSort(arr: FixedArray<char>, startIndex: int, endIndex: int, mustPrecede: (lhs: char, rhs: char) => boolean, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if (mustPrecede(tmp, arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp(arr: FixedArray<char>, idxFromStart: int, startIndex: int, heapRoot: int, mustPrecede: (lhs: char, rhs: char) => boolean): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!mustPrecede(arr[startIndex + p], tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown(arr: FixedArray<char>, idxFromStart: int, startIndex: int, endIndex: int, mustPrecede: (lhs: char, rhs: char) => boolean): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if (mustPrecede(arr[childIndex], arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot, mustPrecede)
}

function heapSort(arr: FixedArray<char>, startIndex: int, endIndex: int, mustPrecede: (lhs: char, rhs: char) => boolean): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex, mustPrecede)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i, mustPrecede)
    }
}

// Put median of three array elements to arr[index1]
function median3(arr: FixedArray<char>, index1: int, index2: int, index3: int, mustPrecede: (lhs: char, rhs: char) => boolean): void {
    let swap_idx = index2
    if (mustPrecede(arr[index1], arr[index2])) {
        if (mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index3], arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index2], arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit(arr: FixedArray<char>, startIndex: int, endIndex: int, mustPrecede: (lhs: char, rhs: char) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(arr[i], pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !mustPrecede(arr[j], pivot)) {
            j--
        }
    } else {
        while (!mustPrecede(arr[j], pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !mustPrecede(arr[i], pivot) and mustPrecede(arr[j], pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (mustPrecede(arr[++i], pivot)) {}
        while (!mustPrecede(arr[--j], pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft(arr: FixedArray<char>, startIndex: int, endIndex: int, mustPrecede: (lhs: char, rhs: char) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(pivot, arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !mustPrecede(pivot, arr[i])) {
            i++
        }
    } else {
        while (!mustPrecede(pivot, arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here mustPrecede(pivot, arr[i]) and !mustPrecede(pivot, arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!mustPrecede(pivot, arr[++i])) {}
        while (mustPrecede(pivot, arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40(arr: FixedArray<char>, startIndex: int, endIndex: int, maxDepth: int, mustPrecede: (lhs: char, rhs: char) => boolean): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex, mustPrecede)
            return
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2, mustPrecede)
        let p = quickSortSplit(arr, startIndex, endIndex, mustPrecede)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, mustPrecede)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, mustPrecede)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, mustPrecede)
}

function quickSort(arr: FixedArray<char>, startIndex: int, endIndex: int, mustPrecede: (lhs: char, rhs: char) => boolean): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3, mustPrecede)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort_subarray(arr: FixedArray<char>, startIndex: int, endIndex: int, mustPrecede: (lhs: char, rhs: char) => boolean): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex, mustPrecede);
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 */
export function sort_subarray(arr: FixedArray<char>, mustPrecede: (lhs: char, rhs: char) => boolean): void {
    sort_subarray(arr, 0, arr.length, mustPrecede);
}

export function sort_subarray(arr: FixedArray<char>, startIndex: int, mustPrecede: (lhs: char, rhs: char) => boolean): void {
    sort_subarray(arr, startIndex, arr.length, mustPrecede)
}

export function swap<T>(arr: FixedArray<T>, i: int, j: int): void {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

function insertionSort<T>(arr: FixedArray<T>, startIndex: int, endIndex: int, mustPrecede: (lhs: T, rhs: T) => boolean, initIndex: int = startIndex): void {
    if (startIndex != initIndex) {
        // arr[startIndex - 1] exists and is less than or equal to all elements in range
        for (let i = startIndex + 1; i < endIndex; i++) {
            const tmp = arr[i]
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
        return
    }
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        if (mustPrecede(tmp, arr[startIndex])) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let pos = i
            while (mustPrecede(tmp, arr[pos - 1])) {
                arr[pos] = arr[pos - 1]
                pos--
            }
            arr[pos] = tmp
        }
    }
}
function heapSortUp<T>(arr: FixedArray<T>, idxFromStart: int, startIndex: int, heapRoot: int, mustPrecede: (lhs: T, rhs: T) => boolean): void {
    const tmp = arr[startIndex + idxFromStart]
    while (startIndex + idxFromStart > heapRoot) {
        const p = (idxFromStart - 1) / 2
        if (!mustPrecede(arr[startIndex + p], tmp)) {
            break
        }
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        idxFromStart = p
    }
    arr[startIndex + idxFromStart] = tmp
}

// Build max heap with root in startIndex given its children are roots of valid heaps
function heapSortDown<T>(arr: FixedArray<T>, idxFromStart: int, startIndex: int, endIndex: int, mustPrecede: (lhs: T, rhs: T) => boolean): void {
    let heapRoot = startIndex + idxFromStart
    let arrIndex = heapRoot
    let childIndex = startIndex + idxFromStart * 2 + 1
    const tmp = arr[arrIndex]
    // Walk heap to bottom and pull max child up on each level
    while (childIndex + 1 < endIndex) {
        if (mustPrecede(arr[childIndex], arr[childIndex + 1])) {
            childIndex++
        }
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
        childIndex = childIndex * 2 - startIndex + 1
    }
    if (childIndex < endIndex) {
        arr[arrIndex] = arr[childIndex]
        arrIndex = childIndex
    }
    arr[arrIndex] = tmp
    // Now heap is valid in all positions but arrIndex
    heapSortUp(arr, arrIndex - startIndex, startIndex, heapRoot, mustPrecede)
}

function heapSort<T>(arr: FixedArray<T>, startIndex: int, endIndex: int, mustPrecede: (lhs: T, rhs: T) => boolean): void {
    let len = endIndex - startIndex
    for (let i = len / 2 - 1; i >= 0; i--) {
        heapSortDown(arr, i, startIndex, endIndex, mustPrecede)
    }

    for (let i = endIndex - 1; i > startIndex; i--) {
        // move max element to the end of range
        swap(arr, i, startIndex)
        heapSortDown(arr, 0, startIndex, i, mustPrecede)
    }
}

// Put median of three array elements to arr[index1]
function median3<T>(arr: FixedArray<T>, index1: int, index2: int, index3: int, mustPrecede: (lhs: T, rhs: T) => boolean): void {
    let swap_idx = index2
    if (mustPrecede(arr[index1], arr[index2])) {
        if (mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index3], arr[index2])) {
            swap_idx = index3
        }
    } else {
        if (!mustPrecede(arr[index3], arr[index1])) {
            return
        }
        if (mustPrecede(arr[index2], arr[index3])) {
            swap_idx = index3
        }
    }
    swap(arr, index1, swap_idx)
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the right
function quickSortSplit<T>(arr: FixedArray<T>, startIndex: int, endIndex: int, mustPrecede: (lhs: T, rhs: T) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(arr[i], pivot)) {
        i++
    }
    if (i == startIndex + 1) {
        while (i < j && !mustPrecede(arr[j], pivot)) {
            j--
        }
    } else {
        while (!mustPrecede(arr[j], pivot)) {
            j--
        }
    }
    while (i < j) {
        // Here !mustPrecede(arr[i], pivot) and mustPrecede(arr[j], pivot) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (mustPrecede(arr[++i], pivot)) {}
        while (!mustPrecede(arr[--j], pivot)) {}
    }
    let pivotIndex = i - 1
    arr[startIndex] = arr[pivotIndex]
    arr[pivotIndex] = pivot

    return pivotIndex
}

// Split range [startIndex, endIndex) by pivot arr[startIndex] and return pivot position
// Elements equal to pivot go to the left
function quickSortSplitLeft<T>(arr: FixedArray<T>, startIndex: int, endIndex: int, mustPrecede: (lhs: T, rhs: T) => boolean): int {
    const pivot = arr[startIndex]
    let i = startIndex + 1
    let j = endIndex - 1
    // No bounds check because pivot is median of three elements
    while (mustPrecede(pivot, arr[j])) {
        j--
    }
    if (j + 1 == endIndex) {
        while (i < j && !mustPrecede(pivot, arr[i])) {
            i++
        }
    } else {
        while (!mustPrecede(pivot, arr[i])) {
            i++
        }
    }
    while (i < j) {
        // Here mustPrecede(pivot, arr[i]) and !mustPrecede(pivot, arr[j]) holds
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        while (!mustPrecede(pivot, arr[++i])) {}
        while (mustPrecede(pivot, arr[--j])) {}
    }
    arr[startIndex] = arr[j]
    arr[j] = pivot

    return j
}

function quickSortImpl40<T>(arr: FixedArray<T>, startIndex: int, endIndex: int, maxDepth: int, mustPrecede: (lhs: T, rhs: T) => boolean): void {
    while (endIndex - startIndex > 40) {
        if (--maxDepth == 0) {
            heapSort(arr, startIndex, endIndex, mustPrecede)
            return
        }

        median3(arr, startIndex, endIndex - 1, (startIndex + endIndex) / 2, mustPrecede)
        let p = quickSortSplit(arr, startIndex, endIndex, mustPrecede)
        // make a call for the smaller part of array and continue processing the larger part in the loop
        if (p - startIndex < endIndex - p) {
            quickSortImpl40(arr, startIndex, p, maxDepth, mustPrecede)
            startIndex = p + 1
        } else {
            quickSortImpl40(arr, p + 1, endIndex, maxDepth, mustPrecede)
            endIndex = p
        }
    }
    insertionSort(arr, startIndex, endIndex, mustPrecede)
}

function quickSort<T>(arr: FixedArray<T>, startIndex: int, endIndex: int, mustPrecede: (lhs: T, rhs: T) => boolean): void {
    let size = endIndex - startIndex
    if (size <= 1) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    let bits = 32
    for (let i = 2; i < 31; i++) {
        if ((size >> i) == 0) {
            bits = i
            break
        }
    }
    quickSortImpl40(arr, startIndex, endIndex, bits * 3, mustPrecede)
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort_subarray<T>(arr: FixedArray<T>, startIndex: int, endIndex: int, mustPrecede: (lhs: T, rhs: T) => boolean): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    quickSort(arr, startIndex, endIndex, mustPrecede);
}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 */
export function sort_subarray<T>(arr: FixedArray<T>, mustPrecede: (lhs: T, rhs: T) => boolean): void {
    sort_subarray(arr, 0, arr.length, mustPrecede);
}

export function sort_subarray<T>(arr: FixedArray<T>, startIndex: int, mustPrecede: (lhs: T, rhs: T) => boolean): void {
    sort_subarray(arr, startIndex, arr.length, mustPrecede)
}

