/**
 * Copyright (c) 2021-2026 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package std.core;

// NOTE: autogenerated file

/**
 * The key not found constant.
 *
 * @constant
 * @type { int }
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export const KEY_NOT_FOUND = -1;

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param { FixedArray<boolean> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { boolean } key The value to find lower bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than endIndex
 * @throws { RangeError } Throws if the bounds verification failed
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<boolean>, key: boolean, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) < 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param { FixedArray<boolean> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { boolean } key The value to find lower bound of
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than arr.length
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<boolean>, key: boolean): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * Tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<boolean> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { boolean } key The value to find upper bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<boolean>, key: boolean, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) <= 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<boolean> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { boolean } key The value to find upper bound of
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<boolean>, key: boolean): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param { FixedArray<boolean> } src The array to copy
 * @returns { FixedArray<boolean> } The copy of `src`
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function copyOf(src: FixedArray<boolean>): FixedArray<boolean> {
    const r : FixedArray<boolean> = new FixedArray<boolean>(src.length);
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param { FixedArray<boolean> } src The array to copy from
 * @param { FixedArray<boolean> } dst The array to copy into
 * @param { int } dstStart The index of dst to start from
 * @param { int } srcStart The index of src to start from
 * @param { int } srcEnd The last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export native function copyTo(src: FixedArray<boolean>, dst: FixedArray<boolean>, dstStart: int, srcStart: int, srcEnd: int): void;

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param { FixedArray<byte> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { byte } key The value to find lower bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than endIndex
 * @throws { RangeError } Throws if the bounds verification failed
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<byte>, key: byte, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) < 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param { FixedArray<byte> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { byte } key The value to find lower bound of
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than arr.length
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<byte>, key: byte): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * Tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<byte> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { byte } key The value to find upper bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<byte>, key: byte, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) <= 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<byte> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { byte } key The value to find upper bound of
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<byte>, key: byte): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param { FixedArray<byte> } src The array to copy
 * @returns { FixedArray<byte> } The copy of `src`
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function copyOf(src: FixedArray<byte>): FixedArray<byte> {
    const r : FixedArray<byte> = new FixedArray<byte>(src.length);
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param { FixedArray<byte> } src The array to copy from
 * @param { FixedArray<byte> } dst The array to copy into
 * @param { int } dstStart The index of dst to start from
 * @param { int } srcStart The index of src to start from
 * @param { int } srcEnd The last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export native function copyTo(src: FixedArray<byte>, dst: FixedArray<byte>, dstStart: int, srcStart: int, srcEnd: int): void;

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param { FixedArray<short> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { short } key The value to find lower bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than endIndex
 * @throws { RangeError } Throws if the bounds verification failed
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<short>, key: short, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) < 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param { FixedArray<short> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { short } key The value to find lower bound of
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than arr.length
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<short>, key: short): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * Tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<short> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { short } key The value to find upper bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<short>, key: short, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) <= 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<short> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { short } key The value to find upper bound of
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<short>, key: short): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param { FixedArray<short> } src The array to copy
 * @returns { FixedArray<short> } The copy of `src`
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function copyOf(src: FixedArray<short>): FixedArray<short> {
    const r : FixedArray<short> = new FixedArray<short>(src.length);
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param { FixedArray<short> } src The array to copy from
 * @param { FixedArray<short> } dst The array to copy into
 * @param { int } dstStart The index of dst to start from
 * @param { int } srcStart The index of src to start from
 * @param { int } srcEnd The last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export native function copyTo(src: FixedArray<short>, dst: FixedArray<short>, dstStart: int, srcStart: int, srcEnd: int): void;

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param { FixedArray<int> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { int } key The value to find lower bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than endIndex
 * @throws { RangeError } Throws if the bounds verification failed
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<int>, key: int, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) < 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param { FixedArray<int> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { int } key The value to find lower bound of
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than arr.length
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<int>, key: int): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * Tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<int> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { int } key The value to find upper bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<int>, key: int, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) <= 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<int> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { int } key The value to find upper bound of
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<int>, key: int): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param { FixedArray<int> } src The array to copy
 * @returns { FixedArray<int> } The copy of `src`
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function copyOf(src: FixedArray<int>): FixedArray<int> {
    const r : FixedArray<int> = new FixedArray<int>(src.length);
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param { FixedArray<int> } src The array to copy from
 * @param { FixedArray<int> } dst The array to copy into
 * @param { int } dstStart The index of dst to start from
 * @param { int } srcStart The index of src to start from
 * @param { int } srcEnd The last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export native function copyTo(src: FixedArray<int>, dst: FixedArray<int>, dstStart: int, srcStart: int, srcEnd: int): void;

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param { FixedArray<long> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { long } key The value to find lower bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than endIndex
 * @throws { RangeError } Throws if the bounds verification failed
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<long>, key: long, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) < 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param { FixedArray<long> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { long } key The value to find lower bound of
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than arr.length
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<long>, key: long): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * Tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<long> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { long } key The value to find upper bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<long>, key: long, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) <= 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<long> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { long } key The value to find upper bound of
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<long>, key: long): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param { FixedArray<long> } src The array to copy
 * @returns { FixedArray<long> } The copy of `src`
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function copyOf(src: FixedArray<long>): FixedArray<long> {
    const r : FixedArray<long> = new FixedArray<long>(src.length);
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param { FixedArray<long> } src The array to copy from
 * @param { FixedArray<long> } dst The array to copy into
 * @param { int } dstStart The index of dst to start from
 * @param { int } srcStart The index of src to start from
 * @param { int } srcEnd The last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export native function copyTo(src: FixedArray<long>, dst: FixedArray<long>, dstStart: int, srcStart: int, srcEnd: int): void;

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param { FixedArray<float> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { float } key The value to find lower bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than endIndex
 * @throws { RangeError } Throws if the bounds verification failed
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<float>, key: float, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) < 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param { FixedArray<float> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { float } key The value to find lower bound of
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than arr.length
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<float>, key: float): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * Tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<float> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { float } key The value to find upper bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<float>, key: float, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) <= 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<float> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { float } key The value to find upper bound of
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<float>, key: float): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param { FixedArray<float> } src The array to copy
 * @returns { FixedArray<float> } The copy of `src`
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function copyOf(src: FixedArray<float>): FixedArray<float> {
    const r : FixedArray<float> = new FixedArray<float>(src.length);
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param { FixedArray<float> } src The array to copy from
 * @param { FixedArray<float> } dst The array to copy into
 * @param { int } dstStart The index of dst to start from
 * @param { int } srcStart The index of src to start from
 * @param { int } srcEnd The last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export native function copyTo(src: FixedArray<float>, dst: FixedArray<float>, dstStart: int, srcStart: int, srcEnd: int): void;

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param { FixedArray<double> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { double } key The value to find lower bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than endIndex
 * @throws { RangeError } Throws if the bounds verification failed
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<double>, key: double, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) < 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param { FixedArray<double> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { double } key The value to find lower bound of
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than arr.length
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<double>, key: double): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * Tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<double> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { double } key The value to find upper bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<double>, key: double, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) <= 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<double> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { double } key The value to find upper bound of
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<double>, key: double): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param { FixedArray<double> } src The array to copy
 * @returns { FixedArray<double> } The copy of `src`
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function copyOf(src: FixedArray<double>): FixedArray<double> {
    const r : FixedArray<double> = new FixedArray<double>(src.length);
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param { FixedArray<double> } src The array to copy from
 * @param { FixedArray<double> } dst The array to copy into
 * @param { int } dstStart The index of dst to start from
 * @param { int } srcStart The index of src to start from
 * @param { int } srcEnd The last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export native function copyTo(src: FixedArray<double>, dst: FixedArray<double>, dstStart: int, srcStart: int, srcEnd: int): void;

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param { FixedArray<char> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { char } key The value to find lower bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than endIndex
 * @throws { RangeError } Throws if the bounds verification failed
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<char>, key: char, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) < 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * Tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param { FixedArray<char> } arr The array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { char } key The value to find lower bound of
 * @returns { int } The index such (arr[index] < key) is false. If no such index is found than arr.length
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function lowerBoundSearch(arr: FixedArray<char>, key: char): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * Tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<char> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { char } key The value to find upper bound of
 * @param { int } startIndex The index of arr to begin search with
 * @param { int } endIndex The last index to stop search in arr, i.e. arr[endIndex] is not checked
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<char>, key: char, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle].compareTo(key) <= 0) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param { FixedArray<char> } arr The array to find an upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 * @param { char } key The value to find upper bound of
 * @returns { int } The index such (key < arr[index]) is true. If no such index is found than endIndex
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function upperBoundSearch(arr: FixedArray<char>, key: char): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param { FixedArray<char> } src The array to copy
 * @returns { FixedArray<char> } The copy of `src`
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function copyOf(src: FixedArray<char>): FixedArray<char> {
    const r : FixedArray<char> = new FixedArray<char>(src.length);
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param { FixedArray<char> } src The array to copy from
 * @param { FixedArray<char> } dst The array to copy into
 * @param { int } dstStart The index of dst to start from
 * @param { int } srcStart The index of src to start from
 * @param { int } srcEnd The last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export native function copyTo(src: FixedArray<char>, dst: FixedArray<char>, dstStart: int, srcStart: int, srcEnd: int): void;

/**
 * Makes an array shallow copy
 *
 * @param { FixedArray<Any> } src The array to copy
 * @returns { FixedArray<Any> } The copy of `src`
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export function copyOf(src: FixedArray<Any>): FixedArray<Any> {
    const r : FixedArray<Any> = new FixedArray<Any>(src.length);
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param { FixedArray<Any> } src The array to copy from
 * @param { FixedArray<Any> } dst The array to copy into
 * @param { int } dstStart The index of dst to start from
 * @param { int } srcStart The index of src to start from
 * @param { int } srcEnd The last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export native function copyTo(src: FixedArray<Any>, dst: FixedArray<Any>, dstStart: int, srcStart: int, srcEnd: int): void;
