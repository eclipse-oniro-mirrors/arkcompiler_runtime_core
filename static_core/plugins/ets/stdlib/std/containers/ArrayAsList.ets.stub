/*
 * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package std.containers;

export class ArrayAsList<T> implements List {

    private init(capacity: int, val: T): void {
        this.data = new T[capacity];
        for (let i = 0; i < this.data.length; ++i) {
            this.data[i] = val;
        }
        this.curSize = capacity;
    }

    constructor(capacity: int, val: T) {
        init(capacity, val);
    }

    constructor() {
        init(0, new T());
    }

    constructor(capacity: int) {
        init(capacity, new T());
    }

    public reserve(capacity: int): void {
        if (this.data.length < capacity) {
            let newData = new T[capacity];
            for (let i = 0; i < this.curSize; ++i) {
               newData[i] = this.data[i];
            }
            this.data = newData;
        }
    }

    private static getNewCapacity(currentCapacity: int): int {
        // TODO(ivan-tyulyandin): select proper capacity increasing strategy
        const fastGrowThreshold = 8192;
        const multiplier = 2;
        if (currentCapacity < fastGrowThreshold) {
            // Adding 4 to jump over 0
            return (currentCapacity + 4) * multiplier * 2;
        } else {
            return currentCapacity * multiplier;
        }
    }

    public override pushFront(e: T): void {
        let dst = this.data;
        if (this.curSize == this.data.length) {
            dst = new T[getNewCapacity(this.data.length)];
        }
        for (let i = this.curSize; i != 0; --i) {
            dst[i] = this.data[i-1];
        }
        this.data = dst;
        this.data[0] = e;
        ++this.curSize;
    }

    public override popFront(): T {
        arktest.assertLT(0, this.curSize, "No data to popFront from ArrayAsList!")
        let res: T = data[0];
        for (let i = 1; i < this.curSize; ++i) {
            this.data[i-1] = this.data[i];
        }
        --this.curSize;
        return res;
    }

    public override pushBack(e: T): void {
        if (this.curSize == this.data.length) {
            let newData = new T[getNewCapacity(this.data.length)];
            for (let i = 0; i < this.curSize; ++i) {
                newData[i] = this.data[i];
            }
            this.data = newData;
        }
        this.data[this.curSize] = e;
        ++this.curSize;
    }

    public override popBack(): T {
        arktest.assertLT(0, this.curSize, "No data to popBack in ArrayAsList!")
        --this.curSize;
        return this.data[this.curSize];
    }

    public override size(): int {
        return this.curSize;
    }

    public override at(index: int): T {
        return this.data[index];
    }

    public override has(e: T): boolean {
        return false;
    }

    private data: T[];
    private curSize: int;
}
