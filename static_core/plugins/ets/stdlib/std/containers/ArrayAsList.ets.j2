/*
 * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package std.containers;

export namespace containers {

    export class ArrayAsList{{T}} implements List{{T}} {

        private init(capacity: int, val: {{T}}): void {
            this.data = new {{T}}[capacity];
            for (let i = 0; i < this.data.length; ++i) {
                this.data[i] = val;
            }
            this.curSize = capacity;
        }

    /**
     * Gets a shallow-copy of the underlying array
     *
     * @returns a shallow-copy of the underlying array
     */
    public toArray(): {{T}}[] {
        let data = new {{T}}[this.curSize];
        for (let i = 0; i < this.curSize; ++i) {
            data[i] = this.data[i];
        }
        return data;
    }

    private static getNewCapacity(currentCapacity: int): int {
        // TODO(ivan-tyulyandin): select proper capacity increasing strategy
        const fastGrowThreshold = 8192;
        const multiplier = 2;
        if (currentCapacity < fastGrowThreshold) {
            // Adding 4 to jump over 0
            return (currentCapacity + 4) * multiplier * 2;
        } else {
            return currentCapacity * multiplier;
        }
    }

    /**
     * Pushes a value to the begin of the List
     *
     * @param e value to push
     */
    public override pushFront(e: {{T}}): void {
        let dst = this.data;
        if (this.curSize == this.data.length) {
            dst = new {{T}}[ArrayAsList{{T}}.getNewCapacity(this.data.length)];
        }
        for (let i = this.curSize; i != 0; --i) {
            dst[i] = this.data[i-1];
        }
        this.data = dst;
        this.data[0] = e;
        ++this.curSize;
    }

    /**
     * Pops a value from the begin of the List
     *
     * @returns popped value
     */
    public override popFront(): {{T}} {
        arktest.assertLT(0, this.curSize, "No data to popFront from ArrayAsList!")
        let res: {{T}} = this.data[0];
        for (let i = 1; i < this.curSize; ++i) {
            this.data[i-1] = this.data[i];
        }
        --this.curSize;
        return res;
    }

    /**
     * Pushes a value to the end of the List
     *
     * @param e value to push
     */
    public override pushBack(e: {{T}}): void {
        if (this.curSize == this.data.length) {
            let newData = new {{T}}[ArrayAsList{{T}}.getNewCapacity(this.data.length)];
            for (let i = 0; i < this.curSize; ++i) {
                newData[i] = this.data[i];
            }
            this.data = newData;
        }
        this.data[this.curSize] = e;
        ++this.curSize;
    }

    /**
     * Pops a value from the end of the List
     *
     * @returns popped value
     */
    public override popBack(): {{T}} {
        arktest.assertLT(0, this.curSize, "No data to popBack in ArrayAsList!")
        --this.curSize;
        return this.data[this.curSize];
    }

    /**
     * Returns number of elements in the List
     */
    public override size(): int {
        return this.curSize;
    }

    /**
     * Returns an element at the specified index
     *
     * @param index element position
     *
     * @returns an element
     */
    public override at(index: int): {{T}} {
        return this.data[index];
    }

    /**
     * Sets an element at the specified index
     *
     * @param index element position
     *
     * @param e new value
     */
    public override set(index: int, e: {{T}}): void {
        this.data[index] = e;
    }

    /**
     * Checks if an element is in the List
     *
     * @param e value to find
     *
     * @returns true if value present, false otherwise
     */
    public override has(e: {{T}}): boolean {
        /*
        for (let i = 0; i < this.curSize; ++i) {
            if (this.data[i].equals(e)) {
                return true;
            }
        }
        */
        constructor(capacity: int, val: {{T}}) {
            this.init(capacity, val);
        }

        /**
        * Constructs new empty ArrayAsList
        */
        constructor() {
            this.init(0, new {{T}}());
        }

        /**
        * Constructs new ArrayAsList with required capacity
        *
        * @param capacity
        */
        constructor(capacity: int) {
            this.init(capacity, new {{T}}());
        }

        /**
        * Increases capacity if passed argument is greater than current capacity
        *
        * @param capacity
        */
        public reserve(capacity: int): void {
            if (this.data.length < capacity) {
                let newData = new {{T}}[capacity];
                for (let i = 0; i < this.curSize; ++i) {
                newData[i] = this.data[i];
                }
                this.data = newData;
            }
        }

        /**
        * Gets a shallow-copy of the underlying array
        *
        * @returns a shallow-copy of the underlying array
        */
        public toArray(): {{T}}[] {
            let data = new {{T}}[this.curSize];
            for (let i = 0; i < this.curSize; ++i) {
                data[i] = this.data[i];
            }
            return data;
        }

        private static getNewCapacity(currentCapacity: int): int {
            // TODO(ivan-tyulyandin): select proper capacity increasing strategy
            const fastGrowThreshold = 8192;
            const multiplier = 2;
            if (currentCapacity < fastGrowThreshold) {
                // Adding 4 to jump over 0
                return (currentCapacity + 4) * multiplier * 2;
            } else {
                return currentCapacity * multiplier;
            }
        }

        /**
        * Pushes a value to the begin of the List
        *
        * @param e value to push
        */
        public override pushFront(e: {{T}}): void {
            let dst = this.data;
            if (this.curSize == this.data.length) {
                dst = new {{T}}[ArrayAsList{{T}}.getNewCapacity(this.data.length)];
            }
            for (let i = this.curSize; i != 0; --i) {
                dst[i] = this.data[i-1];
            }
            this.data = dst;
            this.data[0] = e;
            ++this.curSize;
        }

        /**
        * Pops a value from the begin of the List
        *
        * @returns popped value
        */
        public override popFront(): {{T}} {
            assertLT(0, this.curSize, "No data to popFront from ArrayAsList!")
            let res: {{T}} = this.data[0];
            for (let i = 1; i < this.curSize; ++i) {
                this.data[i-1] = this.data[i];
            }
            --this.curSize;
            return res;
        }

        /**
        * Pushes a value to the end of the List
        *
        * @param e value to push
        */
        public override pushBack(e: {{T}}): void {
            if (this.curSize == this.data.length) {
                let newData = new {{T}}[ArrayAsList{{T}}.getNewCapacity(this.data.length)];
                for (let i = 0; i < this.curSize; ++i) {
                    newData[i] = this.data[i];
                }
                this.data = newData;
            }
            this.data[this.curSize] = e;
            ++this.curSize;
        }

        /**
        * Pops a value from the end of the List
        *
        * @returns popped value
        */
        public override popBack(): {{T}} {
            assertLT(0, this.curSize, "No data to popBack in ArrayAsList!")
            --this.curSize;
            return this.data[this.curSize];
        }

        /**
        * Returns number of elements in the List
        */
        public override size(): int {
            return this.curSize;
        }

        /**
        * Returns an element at the specified index
        *
        * @param index element position
        *
        * @returns an element
        */
        public override at(index: int): {{T}} {
            return this.data[index];
        }

        /**
        * Sets an element at the specified index
        *
        * @param index element position
        *
        * @param e new value
        */
        public override set(index: int, e: {{T}}): void {
            this.data[index] = e;
        }

        /**
        * Checks if an element is in the List
        *
        * @param e value to find
        *
        * @returns true if value present, false otherwise
        */
        public override has(e: {{T}}): boolean {
            return false;
        }

        private data: {{T}}[] = [];
        private curSize: int;
    }
}
