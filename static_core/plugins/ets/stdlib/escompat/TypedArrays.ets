/**
 * Copyright (c) 2021-2026 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Defines the TypedArrays for ArkTS
 * @kit ArkTS
 */

// Autogenerated file. DO NOT EDIT

package escompat
import {iteratorForEach, tryGetIteratorLength} from "std/core"

function asIntOrDefault(n: int | undefined, def: int): int {
    return n ?? def
}

function asIntOrDefault(n: Number | undefined, def: int): int {
    if (n === undefined) {
        return def
    }
    return (n!).toInt();
}

function normalizeIndex(idx: int, len: int): int {
    if (idx < -len) {
        return 0
    }
    if (idx < 0) {
        return len + idx
    }
    if (idx > len) {
        return len
    }
    return idx
}

class Int8ArrayIteratorKeys implements IterableIterator<int> {
    private length: int
    private idx: int = 0

    constructor(parent: Int8Array) {
        this.length = parent.length
    }

    public override $_iterator(): IterableIterator<int> {
        return this
    }

    override next(): IteratorResult<int> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(false, this.idx++)
    }
}

class Int8ArrayIterator implements IterableIterator<Number> {
    private parent: Int8Array
    private idx: int = 0

    constructor(parent: Int8Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Int8ArrayIteratorEntries implements IterableIterator<[int, Number]> {
    private parent: Int8Array
    private idx: int = 0

    constructor(parent: Int8Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[int, Number]> {
        return this
    }

    override next(): IteratorResult<[int, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<[int, Number]>()
        }
        return new IteratorResult<[int, Number]>(
            false, [this.idx, new Number(this.parent[this.idx++])]
        )
    }
}


/**
 * Defines Int8Array
 *
 * @implements { Iterable<Number>, ArrayLike<Number> }
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export final class Int8Array implements Iterable<Number>, ArrayLike<Number> {
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static readonly BYTES_PER_ELEMENT: int = 1
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly BYTES_PER_ELEMENT: int = Int8Array.BYTES_PER_ELEMENT
    protected readonly lengthInt: int

    /**
     * Creates an empty Int8Array.
     *
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor() {
        this(0)
    }

    /**
     * Creates an Int8Array with respect to length.
     *
     * @param { int } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: int) {
        this(length.toDouble())
    }

    /**
     * Creates an Int8Array with respect to length.
     *
     * @param { number } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: number) {
        if (length < 0 || length > (Int.MAX_VALUE / Int8Array.BYTES_PER_ELEMENT).toInt()) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length.toInt()
        this.byteLength = this.lengthInt * Int8Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates a copy of Int8Array.
     *
     * @param { Int8Array } other - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(other: Int8Array) {
        this.buffer = other.buffer.slice(other.byteOffset, other.byteOffset + other.byteLength) as ArrayBuffer
        this.byteLength = other.byteLength
        this.lengthInt = other.length
        this.byteOffset = 0
    }

    /**
     * Creates an Int8Array from FixedArray<int>
     *
     * @param { FixedArray<int> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].toByte())
        }
    }

    /**
     * Creates an Int8Array from FixedArray<number>
     *
     * @param { FixedArray<number> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<number>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, Int8Array.doubleToInt(numbers[i]))
        }
    }

    /**
     * Creates an Int8Array from Array<int>
     *
     * @param { Array<int> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: Array<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].toByte())
        }
    }

    /**
     * Creates an Int8Array with respect to data accessed via Iterable<Number> interface
     *
     * @param { Iterable<Number> } elements - an iterable object
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(elements: Iterable<Number>) {
        const items: Object = elements as Object
        if (items instanceof ArrayLike) {
            const arr = reflect.internals.Types.identity_cast<Number>(items as ArrayLike<Number>)
            this.byteLength = arr.length * Int8Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, Int8Array.doubleToInt(arr[i]))
            }
        } else {
            let x = Int8Array.from(elements)
            this.byteLength = x.byteLength
            this.lengthInt = x.lengthInt
            this.buffer = x.buffer
            this.byteOffset = x.byteOffset
        }
    }
    private static native doubleToInt(d: double): byte;

    /**
     * Creates an Int8Array with respect to buf and byteOffset.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int8Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { number } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int8Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @param { int } length - size of elements of type byte in newly created Int8Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Int8Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { Number | undefined } byteOffset - byte offset from begin of the buf
     * @param { Number | undefined } length - size of elements of type byte in newly created Int8Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.toInt()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int = buf.getByteLength() - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.toInt()
            if (intLength > (intByteLength / Int8Array.BYTES_PER_ELEMENT).toInt()) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = (intByteLength / Int8Array.BYTES_PER_ELEMENT).toInt()
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < (intByteLength / Int8Array.BYTES_PER_ELEMENT).toInt()) {
            intByteLength = intLength * Int8Array.BYTES_PER_ELEMENT
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Int8Array with respect to buf.
     *
     * @param { ArrayLike<Number> | ArrayBuffer } buf - data initializer
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayLike<Number> | ArrayBuffer) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % Int8Array.BYTES_PER_ELEMENT.toInt() != 0) {
               throw new RangeError("ArrayBuffer.byteLength should be multiple of 1 as Int8Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = (this.byteLength / Int8Array.BYTES_PER_ELEMENT).toInt()
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length * Int8Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, Int8Array.doubleToInt(arr[i]))
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { byte } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_set(index: int, val: byte): void

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { int } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_set(index: int, val: int): void

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { number } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public $_set(index: int, val: number): void {
        this.$_set(index, Int8Array.doubleToInt(val))
    }

    /**
     * Number of byte stored in Int8Array
     *
     * @returns { int } - the number of elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public get length(): int {
        return this.lengthInt
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param { int } index - index to look at
     * @returns { number } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_get(index: int): number

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param { int } index - index to look at
     * @returns { Number | undefined } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } [end] - last index to end copy from, excluded
     * @returns { Int8Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int, start: int, end?: int): Int8Array {
        let arrayLength: int = this.lengthInt;
        target = normalizeIndex(target, arrayLength);
        start = normalizeIndex(start, arrayLength);
        end = normalizeIndex(asIntOrDefault(end, arrayLength), arrayLength);
        let count: int = end - start;
        if (count > (arrayLength - target)) {
            count = arrayLength - target;
        }
        if (count <= 0) {
            return this;
        }

        this.copyWithinImpl(target, start, count)
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } end - last index to end copy from, excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private native copyWithinImpl(target: int, start: int, end: int): void

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Int8Array.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @returns { Int8Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int): Int8Array {
        this.copyWithinImpl(target, 0, this.lengthInt)
        return this
    }

    /**
     * Returns an array of key, value pairs for every entry in the Int8Array
     *
     * @returns { IterableIterator<[int, Number]> } - key, value pairs for every entry in the array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public entries(): IterableIterator<[int, Number]> {
        return new Int8ArrayIteratorEntries(this)
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param { byte } value - new value
     * @param { int } [start] - start index to begin fill from
     * @param { int } [end] - last index to end fill from, excluded
     * @returns { this } - modified Int8Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: byte, start?: int, end?: int): this {
        const k = normalizeIndex(start ?? 0, this.lengthInt)
        const finalPos = normalizeIndex(end ?? this.lengthInt, this.lengthInt)
        this.fillInternal(value, k, finalPos)
        return this
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param { number } value - new value
     * @param { int } [start] - start index to begin fill from
     * @param { int } [end] - last index to end fill from, excluded
     * @returns { this } - modified Int8Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: number, start?: int, end?: int): this {
        this.fill(Int8Array.doubleToInt(value), start, end)
        return this
    }

    private final native fillInternal(value: byte, start: int, end: int): void

    /**
     * Assigns val as element on insertPos.
     *
     * @param { int } insertPos - index to change
     * @param { byte } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(insertPos: int, val: byte): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on insertPos.
     *
     * @param { int } insertPos - index to change
     * @param { number } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(insertPos: int, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Int8Array.
     *
     * @param { FixedArray<byte> } arr - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<byte>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Int8Array starting from insertPos.
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     *
     * @param { FixedArray<byte> } arr - array to copy data from
     * @param { int } insertPos - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<byte>, insertPos: int): void {
        const offset = insertPos
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.setUnsafe(offset + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Int8Array.
     *
     * @param { FixedArray<number> } arr - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<number>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Int8Array starting from insertPos.
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     *
     * @param { FixedArray<number> } arr - array to copy data from
     * @param { int } insertPos - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<number>, insertPos: int): void {
        const offset = insertPos
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.setUnsafe(offset + i, Int8Array.doubleToInt(arr[i]))
        }
    }

    private native final set(array: Array<int>): void;

    /**
     * Copies all elements of array to the current Int8Array.
     *
     * @param { Int8Array } array - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: Int8Array): void
    private native final set(array: Uint8Array): void

    /**
     * Copies all elements of arr to the current Int8Array starting from offset.
     *
     * @param { Int8Array } array - array to copy data from
     * @param { int } offset - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: Int8Array, offset: int): void

    /**
     * Copies elements from an ArrayLike object to the Int8Array.
     *
     * @param { ArrayLike<number> } array - An ArrayLike object containing the elements to copy.
     * @param { int } [offset] - Optional. The offset into the target array at which to begin
     *     writing values from the source array. The default value is 0.
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(array: ArrayLike<number>, offset: int = 0): void {
        const insertPos = offset
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; ++i) {
            this.setUnsafe(insertPos + i, Int8Array.doubleToInt(array[i]))
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<byte> } items - a set of elements to include in the new array object.
     * @returns { Int8Array } - a new Int8Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<byte>): Int8Array {
        let res = new Int8Array(items.length.toInt())
        res.ofByte(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<int> } items - a set of elements to include in the new array object.
     * @returns { Int8Array } - a new Int8Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<int>): Int8Array {
        let res = new Int8Array(items.length.toInt())
        res.ofInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<number> } items - a set of elements to include in the new array object.
     * @returns { Int8Array } - a new Int8Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<number>): Int8Array {
        let res = new Int8Array(items.length.toInt())
        res.ofNumber(items)
        return res
    }

    private final native ofInt(items: FixedArray<int>): void
    private final native ofNumber(items: FixedArray<number>): void
    private final native ofByte(items: FixedArray<byte>): void

    /**
     * Returns a new array from a set of elements.
     *
     * @returns { Int8Array } - a new Int8Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(): Int8Array {
        return new Int8Array(0)
    }

    /**
     * Creates an array from an object of FixedArray<int>.
     *
     * @param { FixedArray<int> } arr - An instance of the FixedArray type to convert to an array.
     * @returns { Int8Array } - A new Int8Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: FixedArray<int>): Int8Array {
        let result = new Int8Array(arr.length)
        result.ofInt(arr)
        return result
    }

    /**
     * Creates an array from a set of type std.core.Set<int>.
     *
     * @param { Set<int> } set - A set object to convert to an array.
     * @returns { Int8Array } - A new Int8Array
     * @throws { AssertionError } - Input parameter error.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(set: Set<int>): Int8Array {
        const length = set.size;
        const result = new Int8Array(length)
        let iter = set.$_iterator()
        for (let i:int = 0; i < length; ++i) {
            const x = iter.next()
            if (x.done) {
                throw new AssertionError('Wrong Length')
            }
            result.setUnsafe(i, x.value!.toByte())
        }
        return result
    }

    /**
     * Creates an array from an array of the same type.
     *
     * @param { Int8Array } arr - An array to convert to a new array.
     * @returns { Int8Array } - A new Int8Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Int8Array): Int8Array {
        let result = new Int8Array(arr.length)
        result.set(arr)
        return result
    }
    /**
     * Creates an array from an array of the same up to the signess type.
     *
     * @param { Uint8Array } arr - An array to convert to a new array.
     * @returns { Int8Array } - A new Int8Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Uint8Array): Int8Array {
        let result = new Int8Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an object of std.core.Array<int>.
     *
     * @param { Array<int> } arr - An instance of the std.core.Array type to convert to an array.
     * @returns { Int8Array } - A new Int8Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Array<int>): Int8Array {
        let result = new Int8Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<number> } arrayLike - An array-like or iterable object to convert to an array.
     * @returns { Int8Array } - A new Int8Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: ArrayLike<number>): Int8Array {
        return Int8Array.from<number>(arrayLike, (x: number, k: number): number => x)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<T> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } mapfn - A mapping function to call on every element of the array.
     * @returns { Int8Array } - A new Int8Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number): Int8Array {
        let res = new Int8Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new FixedArray<int>(1)
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            const mapped = mapfn(x as T, idx[0])
            res.setUnsafe(idx[0], Int8Array.doubleToInt(mapped))
            idx[0]++
        })
        return res
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { Iterable<number> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } [mapfn] - A mapping function to call on every element of the array.
     * @returns { Int8Array } - A new Int8Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Int8Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE (templin.konstantin): This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Int8Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Int8Array(result.buffer, 0, i)
                }
                const mapped = (mapfn)!(x.value!, i)
                result.setUnsafe(i, Int8Array.doubleToInt(mapped))
            }
            return result
        }

        // NOTE (templin.konstantin): Create builtin array as buffer
        let temp = new Int8Array(6)
        let index : FixedArray<int> = new FixedArray<int>(1)
        index[0] = 0

        iteratorForEach<number>(iter, (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE (templin.konstantin): Progressive reallocation
                const curLength = temp.buffer.getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, temp.buffer.at(i))
                }
                temp = new Int8Array(tb)
            }
            const mapped = (mapfn)!(x, index[0])
            temp.setUnsafe(index[0], Int8Array.doubleToInt(mapped))
            index[0]++
        })
        return new Int8Array(temp.buffer, 0, index[0])
    }

    /**
     * Determines whether Int8Array includes a certain element, returning true or false as appropriate
     *
     * @param { byte } searchElement - The element to search for
     * @param { int } fromIndex - The position in this array at which to begin searching for searchElement
     * @returns { boolean } - true if searchElement is in Int8Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: byte, fromIndex: int): boolean {
        return this.indexOf(searchElement.toInt(), fromIndex) != -1
    }

    /**
     * Determines whether Int8Array includes a certain element, returning true or false as appropriate
     *
     * @param { byte } searchElement - The element to search for. The search starts at index 0.
     * @returns { boolean } - true if searchElement is in Int8Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: byte): boolean {
        return this.includes(searchElement, 0)
    }

    /**
     * Determines whether Int8Array includes a certain element, returning true or false as appropriate
     *
     * @param { number } searchElement - The element to search for
     * @param { int } [fromIndex] - The position in this array at which to begin searching for searchElement.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { boolean } - true if searchElement is in Int8Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: number, fromIndex?: int): boolean {
        if (isNaN(searchElement)) {
            return false
        }
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in Int8Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int): int {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Int8Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int, fromIndex: int): int {
        return this.indexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the first occurrence of a value in Int8Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } [fromIndex] - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: number, fromIndex?: int): int {
            return this.indexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Int8Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns {int} - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Int8Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Converts all elements of an array to strings and joins them using the specified separator.
     *
     * @param { String } separator - separates one element of an array from the next in the resulting String.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native joinInternal(separator: String): string;

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param { String } [separator] - A string used to separate one element of an array from the next in the
     *     resulting String. If omitted, the array elements are separated with a comma.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.joinInternal(",")
        }
        return this.joinInternal(separator)
    }

    /**
     * Returns an list of keys in Int8Array
     *
     * @returns { IterableIterator<int> } - iterator over keys
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public keys(): IterableIterator<int> {
        return new Int8ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Int8Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Int8Array.
     *
     * @param { number } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: number): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Int8Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int, fromIndex: int): int {
        return this.lastIndexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the last occurrence of a value in Int8Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int | undefined } fromIndex - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: number, fromIndex: int | undefined): int {
            return this.lastIndexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the last occurrence of a value in Int8Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the last occurrence of a value in Int8Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Creates a new Int8Array using initializer
     *
     * @param { FixedArray<Object> } data - initializer
     * @returns { Int8Array } - a new Int8Array
     * @throws { Error } - function not implemented
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public of(data: FixedArray<Object>): Int8Array {
        throw new Error("Int8Array.of: not implemented")
    }

    /**
     * Creates a new Int8Array using reversed data from the current one
     *
     * @returns { Int8Array } - a new Int8Array using reversed data from the current one
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native reverse(): Int8Array

    /**
     * Creates a slice of current Int8Array using range [begin, this.length).
     *
     * @param { int } begin - start index to be taken into slice
     * @returns { Int8Array } - a new Int8Array with elements of current Int8Array[begin, this.length)
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin: int): Int8Array {
        return this.sliceFromTo(begin, this.lengthInt)
    }

    /**
     * Creates a slice of current Int8Array using range [begin, end)
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sliceFromTo}
     *
     * @param { int } [begin] - start index to be taken into slice
     * @param { int } [end] - last index to be taken into slice
     * @returns { Int8Array } - a new Int8Array with elements of current Int8Array[begin;end),
     *     where end index is excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin?: int, end?: int): Int8Array {
        return this.sliceFromTo(begin ?? 0, end ?? this.lengthInt)
    }

    private sliceFromTo(begin: int, end: int): Int8Array {
        const relStart: int = normalizeIndex(begin, this.lengthInt)
        const relEnd: int = normalizeIndex(end, this.lengthInt)
        let buf: ArrayBuffer = this.buffer.slice(relStart * this.BYTES_PER_ELEMENT + this.byteOffset, relEnd * this.BYTES_PER_ELEMENT + this.byteOffset)
        return new Int8Array(buf)
    }


    /**
     * Creates a Int8Array with the same underlying ArrayBuffer
     *
     * @param { int } [begin] - start index, inclusive
     * @param { int } [end] - last index, exclusive
     * @returns { Int8Array } - a new Int8Array with the same underlying ArrayBuffer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public subarray(begin?: int, end?: int): Int8Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin ?? 0, len)
        const relEnd = normalizeIndex(end ?? this.lengthInt, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Int8Array(this.buffer, relStart * Int8Array.BYTES_PER_ELEMENT + this.byteOffset, count)
    }

    /**
     * Converts Int8Array to a string with respect to locale
     *
     * @returns { string } - string representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(new Number(this.getUnsafe(i)).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append(new Number(this.getUnsafe(this.lengthInt - 1))).toLocaleString()
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns { Int8Array } - a reversed copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toReversed(): Int8Array {
        let newArray = new Int8Array(this.lengthInt);
        if (this.lengthInt > 0) {
            Int8Array.reverseCopyBuffer(newArray.buffer, this.buffer, this.byteOffset, this.lengthInt);
        }
        return newArray
    }

    /**
     * Creates a sorted copy
     *
     * @returns { Int8Array } - a sorted copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toSorted(): Int8Array {
        return new Int8Array(this).sort()
    }

    /**
     * Returns a string representation of the Int8Array
     *
     * @returns { string } - a string representation of the Int8Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns { IterableIterator<Number> } - an iterator
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public values(): IterableIterator<Number> {
        return new Int8ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns { IterableIterator<Number> } - iterator over all elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override $_iterator(): IterableIterator<Number> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param { int } index - index to change
     * @param { byte } value - value to set
     * @returns { Int8Array } - an Int8Array with replaced value on index
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: byte): Int8Array {
        let res = new Int8Array(this)
        res.set(index, value)
        return res
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param { int } index - index to change
     * @param { number } value - value to set
     * @returns { Int8Array } - an Int8Array with replaced value on index
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: number): Int8Array {
        let res = new Int8Array(this)
        res.set(index, value.toByte())
        return res
    }

    /// === with element lambda functions ===

    /**
     * Finds the last element in the Int8Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { number } - the last element that satisfies fn
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Int8Array) => boolean =
            (val: number, index: int, array: Int8Array): boolean => { return fn(val) }
        return (this.findLast(newF)).toDouble()
    }

    /**
     * Sorts in-place by numeric value in ascending order.
     *
     * @returns { this } - sorted Int8Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native sort(): this;

    /**
     * Sorts in-place
     *
     * @param { function } [compareFn] - comparator _  used to determine the order of the elements.
     *     compareFn returns a negative value if first argument is less than second argument,
     *     zero if they're equal and a positive value otherwise.
     * @returns { this } - sorted Int8Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public sort(compareFn?: (a: number, b: number) => int): this {
        if (compareFn == undefined) {
            this.sort()
            return this
        }

        let cmp = (l: byte, r: byte): int => {
            const result = compareFn!((l).toDouble(), (r).toDouble())
            return result.toInt()
        }

        const MAX_SHORT_LENGTH = 24

        if (this.lengthInt > MAX_SHORT_LENGTH) {
            let arr: FixedArray<byte> = new FixedArray<byte>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                arr[i] = this.getUnsafe(i)
            }
            const arrLength = this.lengthInt

            arr = mergeSort(arr, cmp, 0, arrLength)

            for (let i = 0; i < arr.length; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let buffer: FixedArray<Byte> = new FixedArray<Byte>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                buffer[i] = this.getUnsafe(i)
            }
            const arrLength = this.lengthInt

            arr_sort_stable(buffer, 0, arrLength, cmp)
            for (let i = 0; i < buffer.length; ++i) {
                this.setUnsafe(i, buffer[i].toByte())
            }
        }
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The some method calls the predicate function for each element in the array
     *     until the predicate returns a true or until the end of the array.
     * @returns { boolean } - false unless predicate function returns true for an array element,
     *     in which case true is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public some(predicate: (element: number, index: int, array: Int8Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     *     The first call to the callbackfn function provides this value as an argument.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Int8Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array first element value as an argument
     * @returns { number } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the Int8Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Int8Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = (this.getUnsafe(0)).toDouble()
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Int8Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array last element value as an argument.
     * @returns { number } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the Int8Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Int8Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = (this.getUnsafe(this.lengthInt - 1)).toDouble()
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Creates a new Int8Array using fn(arr[i]) over all elements of current Int8Array.
     *
     * @param { function } fn - a function to apply for each element of current Int8Array
     * @returns { Int8Array } - a new Int8Array where for each element from current Int8Array fn was applied
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public map(fn: (val: number, index: int, array: Int8Array) => number): Int8Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Int8Array.BYTES_PER_ELEMENT)
        let res = new Int8Array(resBuf, 0, (resBuf.getByteLength() / Int8Array.BYTES_PER_ELEMENT).toInt())
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn((this.getUnsafe(i)).toDouble(), i, this).toByte())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The every method calls the predicate function for each element in the array until the predicate
     *     returns a false, or until the end of the array.
     * @returns { boolean } - true unless predicate function returns a false for an array element,
     *     in which case false is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public every(predicate: (element: number, index: int, array: Int8Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Creates a new Int8Array from current Int8Array based on a condition fn.
     *
     * @param { function } fn - the condition to apply for each element
     * @returns { Int8Array } - a new Int8Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public filter(fn: (val: number, index: int, array: Int8Array) => boolean): Int8Array {
        let markers : FixedArray<boolean> = new FixedArray<boolean>(this.lengthInt)
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn((this.getUnsafe(i)).toDouble(), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int8Array.BYTES_PER_ELEMENT)
        let res = new Int8Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found, find
     *     immediately returns that element value. Otherwise, find returns undefined
     * @returns { number | undefined }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public find(predicate: (value: number, index: int, obj: Int8Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate((val).toDouble(), i, this)) {
                return (val).toDouble()
            }
        }
        return undefined
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1 otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found,
     *     findIndex immediately returns that element index. Otherwise, findIndex returns -1
     * @returns { int } - Index of the first matched element
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findIndex(predicate: (value: number, index: int, obj: Int8Array) => boolean): int {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds the last element in the Int8Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { byte } - the last element that satisfies fn
     * @throws { Error } - If the element cannot be found, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: number, index: int, array: Int8Array) => boolean): byte {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn((val).toDouble(), i, this)) {
                return val
            }
        }
        throw new Error("Int8Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds an index of the last element in the Int8Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { int } - the index of the last element that satisfies fn, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLastIndex(fn: (val: number, index: int, array: Int8Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn((val).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Performs the specified action for each element in Int8Array
     *
     * @param { function } callbackfn - A function that accepts up to three arguments. forEach calls the
     *     callbackfn function one time for each element in the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public forEach(callbackfn: (value: number, index: int, array: Int8Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn((this.getUnsafe(i)).toDouble(), i, this)
        }
    }

    /**
     * Returns the object itself
     *
     * @returns { Int8Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public valueOf(): Int8Array {
        return this
    }

    private static native reverseCopyBuffer(dstBuf: ArrayBuffer, srcBuf: ArrayBuffer, startPos: int, length: int): void

    private final native getUnsafe(index: int): byte

    private setUnsafe(insertPos: int, val: byte): void {
        const BPE = Int8Array.BYTES_PER_ELEMENT.toInt()
        let byteIndex = insertPos * BPE + this.byteOffset
        let buf = this.buffer
        buf.set(byteIndex, val)
    }

    /**
     * Underlying ArrayBuffer
     *
     * @type { ArrayBuffer }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly buffer: ArrayBuffer

    /**
     * Byte offset within the underlying ArrayBuffer
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteOffset: int

    /**
     * Number of bytes used
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteLength: int

    /**
     * String \"Int8Array\"
     *
     * @type { string }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly name = "Int8Array"
}

class Int16ArrayIteratorKeys implements IterableIterator<int> {
    private length: int
    private idx: int = 0

    constructor(parent: Int16Array) {
        this.length = parent.length
    }

    public override $_iterator(): IterableIterator<int> {
        return this
    }

    override next(): IteratorResult<int> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(false, this.idx++)
    }
}

class Int16ArrayIterator implements IterableIterator<Number> {
    private parent: Int16Array
    private idx: int = 0

    constructor(parent: Int16Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Int16ArrayIteratorEntries implements IterableIterator<[int, Number]> {
    private parent: Int16Array
    private idx: int = 0

    constructor(parent: Int16Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[int, Number]> {
        return this
    }

    override next(): IteratorResult<[int, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<[int, Number]>()
        }
        return new IteratorResult<[int, Number]>(
            false, [this.idx, new Number(this.parent[this.idx++])]
        )
    }
}


/**
 * Defines Int16Array
 *
 * @implements { Iterable<Number>, ArrayLike<Number> }
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export final class Int16Array implements Iterable<Number>, ArrayLike<Number> {
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static readonly BYTES_PER_ELEMENT: int = 2
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly BYTES_PER_ELEMENT: int = Int16Array.BYTES_PER_ELEMENT
    protected readonly lengthInt: int

    /**
     * Creates an empty Int16Array.
     *
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor() {
        this(0)
    }

    /**
     * Creates an Int16Array with respect to length.
     *
     * @param { int } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: int) {
        this(length.toDouble())
    }

    /**
     * Creates an Int16Array with respect to length.
     *
     * @param { number } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: number) {
        if (length < 0 || length > (Int.MAX_VALUE / Int16Array.BYTES_PER_ELEMENT).toInt()) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length.toInt()
        this.byteLength = this.lengthInt * Int16Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates a copy of Int16Array.
     *
     * @param { Int16Array } other - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(other: Int16Array) {
        this.buffer = other.buffer.slice(other.byteOffset, other.byteOffset + other.byteLength) as ArrayBuffer
        this.byteLength = other.byteLength
        this.lengthInt = other.length
        this.byteOffset = 0
    }

    /**
     * Creates an Int16Array from FixedArray<int>
     *
     * @param { FixedArray<int> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].toShort())
        }
    }

    /**
     * Creates an Int16Array from FixedArray<number>
     *
     * @param { FixedArray<number> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<number>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, Int16Array.doubleToInt(numbers[i]))
        }
    }

    /**
     * Creates an Int16Array from Array<int>
     *
     * @param { Array<int> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: Array<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].toShort())
        }
    }

    /**
     * Creates an Int16Array with respect to data accessed via Iterable<Number> interface
     *
     * @param { Iterable<Number> } elements - an iterable object
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(elements: Iterable<Number>) {
        const items: Object = elements as Object
        if (items instanceof ArrayLike) {
            const arr = reflect.internals.Types.identity_cast<Number>(items as ArrayLike<Number>)
            this.byteLength = arr.length * Int16Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, Int16Array.doubleToInt(arr[i]))
            }
        } else {
            let x = Int16Array.from(elements)
            this.byteLength = x.byteLength
            this.lengthInt = x.lengthInt
            this.buffer = x.buffer
            this.byteOffset = x.byteOffset
        }
    }
    private static native doubleToInt(d: double): short;

    /**
     * Creates an Int16Array with respect to buf and byteOffset.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int16Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { number } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int16Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @param { int } length - size of elements of type short in newly created Int16Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Int16Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { Number | undefined } byteOffset - byte offset from begin of the buf
     * @param { Number | undefined } length - size of elements of type short in newly created Int16Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.toInt()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int = buf.getByteLength() - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteOffset % Int16Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 2 as Int16Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.toInt()
            if (intLength > (intByteLength / Int16Array.BYTES_PER_ELEMENT).toInt()) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = (intByteLength / Int16Array.BYTES_PER_ELEMENT).toInt()
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < (intByteLength / Int16Array.BYTES_PER_ELEMENT).toInt()) {
            intByteLength = intLength * Int16Array.BYTES_PER_ELEMENT
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Int16Array with respect to buf.
     *
     * @param { ArrayLike<Number> | ArrayBuffer } buf - data initializer
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayLike<Number> | ArrayBuffer) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % Int16Array.BYTES_PER_ELEMENT.toInt() != 0) {
               throw new RangeError("ArrayBuffer.byteLength should be multiple of 2 as Int16Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = (this.byteLength / Int16Array.BYTES_PER_ELEMENT).toInt()
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length * Int16Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, Int16Array.doubleToInt(arr[i]))
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { short } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_set(index: int, val: short): void

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { int } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_set(index: int, val: int): void

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { number } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public $_set(index: int, val: number): void {
        this.$_set(index, Int16Array.doubleToInt(val))
    }

    /**
     * Number of short stored in Int16Array
     *
     * @returns { int } - the number of elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public get length(): int {
        return this.lengthInt
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param { int } index - index to look at
     * @returns { number } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_get(index: int): number

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param { int } index - index to look at
     * @returns { Number | undefined } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } [end] - last index to end copy from, excluded
     * @returns { Int16Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int, start: int, end?: int): Int16Array {
        let arrayLength: int = this.lengthInt;
        target = normalizeIndex(target, arrayLength);
        start = normalizeIndex(start, arrayLength);
        end = normalizeIndex(asIntOrDefault(end, arrayLength), arrayLength);
        let count: int = end - start;
        if (count > (arrayLength - target)) {
            count = arrayLength - target;
        }
        if (count <= 0) {
            return this;
        }

        this.copyWithinImpl(target, start, count)
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } end - last index to end copy from, excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private native copyWithinImpl(target: int, start: int, end: int): void

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Int16Array.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @returns { Int16Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int): Int16Array {
        this.copyWithinImpl(target, 0, this.lengthInt)
        return this
    }

    /**
     * Returns an array of key, value pairs for every entry in the Int16Array
     *
     * @returns { IterableIterator<[int, Number]> } - key, value pairs for every entry in the array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public entries(): IterableIterator<[int, Number]> {
        return new Int16ArrayIteratorEntries(this)
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param { short } value - new value
     * @param { int } [start] - start index to begin fill from
     * @param { int } [end] - last index to end fill from, excluded
     * @returns { this } - modified Int16Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: short, start?: int, end?: int): this {
        const k = normalizeIndex(start ?? 0, this.lengthInt)
        const finalPos = normalizeIndex(end ?? this.lengthInt, this.lengthInt)
        this.fillInternal(value, k, finalPos)
        return this
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param { number } value - new value
     * @param { int } [start] - start index to begin fill from
     * @param { int } [end] - last index to end fill from, excluded
     * @returns { this } - modified Int16Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: number, start?: int, end?: int): this {
        this.fill(Int16Array.doubleToInt(value), start, end)
        return this
    }

    private final native fillInternal(value: short, start: int, end: int): void

    /**
     * Assigns val as element on insertPos.
     *
     * @param { int } insertPos - index to change
     * @param { short } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(insertPos: int, val: short): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on insertPos.
     *
     * @param { int } insertPos - index to change
     * @param { number } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(insertPos: int, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Int16Array.
     *
     * @param { FixedArray<short> } arr - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<short>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Int16Array starting from insertPos.
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     *
     * @param { FixedArray<short> } arr - array to copy data from
     * @param { int } insertPos - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<short>, insertPos: int): void {
        const offset = insertPos
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.setUnsafe(offset + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Int16Array.
     *
     * @param { FixedArray<number> } arr - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<number>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Int16Array starting from insertPos.
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     *
     * @param { FixedArray<number> } arr - array to copy data from
     * @param { int } insertPos - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<number>, insertPos: int): void {
        const offset = insertPos
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.setUnsafe(offset + i, Int16Array.doubleToInt(arr[i]))
        }
    }

    private native final set(array: Array<int>): void;

    /**
     * Copies all elements of array to the current Int16Array.
     *
     * @param { Int16Array } array - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: Int16Array): void
    private native final set(array: Uint16Array): void

    /**
     * Copies all elements of arr to the current Int16Array starting from offset.
     *
     * @param { Int16Array } array - array to copy data from
     * @param { int } offset - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: Int16Array, offset: int): void

    /**
     * Copies elements from an ArrayLike object to the Int16Array.
     *
     * @param { ArrayLike<number> } array - An ArrayLike object containing the elements to copy.
     * @param { int } [offset] - Optional. The offset into the target array at which to begin
     *     writing values from the source array. The default value is 0.
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(array: ArrayLike<number>, offset: int = 0): void {
        const insertPos = offset
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; ++i) {
            this.setUnsafe(insertPos + i, Int16Array.doubleToInt(array[i]))
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<short> } items - a set of elements to include in the new array object.
     * @returns { Int16Array } - a new Int16Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<short>): Int16Array {
        let res = new Int16Array(items.length.toInt())
        res.ofShort(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<int> } items - a set of elements to include in the new array object.
     * @returns { Int16Array } - a new Int16Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<int>): Int16Array {
        let res = new Int16Array(items.length.toInt())
        res.ofInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<number> } items - a set of elements to include in the new array object.
     * @returns { Int16Array } - a new Int16Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<number>): Int16Array {
        let res = new Int16Array(items.length.toInt())
        res.ofNumber(items)
        return res
    }

    private final native ofInt(items: FixedArray<int>): void
    private final native ofNumber(items: FixedArray<number>): void
    private final native ofShort(items: FixedArray<short>): void

    /**
     * Returns a new array from a set of elements.
     *
     * @returns { Int16Array } - a new Int16Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(): Int16Array {
        return new Int16Array(0)
    }

    /**
     * Creates an array from an object of FixedArray<int>.
     *
     * @param { FixedArray<int> } arr - An instance of the FixedArray type to convert to an array.
     * @returns { Int16Array } - A new Int16Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: FixedArray<int>): Int16Array {
        let result = new Int16Array(arr.length)
        result.ofInt(arr)
        return result
    }

    /**
     * Creates an array from a set of type std.core.Set<int>.
     *
     * @param { Set<int> } set - A set object to convert to an array.
     * @returns { Int16Array } - A new Int16Array
     * @throws { AssertionError } - Input parameter error.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(set: Set<int>): Int16Array {
        const length = set.size;
        const result = new Int16Array(length)
        let iter = set.$_iterator()
        for (let i:int = 0; i < length; ++i) {
            const x = iter.next()
            if (x.done) {
                throw new AssertionError('Wrong Length')
            }
            result.setUnsafe(i, x.value!.toShort())
        }
        return result
    }

    /**
     * Creates an array from an array of the same type.
     *
     * @param { Int16Array } arr - An array to convert to a new array.
     * @returns { Int16Array } - A new Int16Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Int16Array): Int16Array {
        let result = new Int16Array(arr.length)
        result.set(arr)
        return result
    }
    /**
     * Creates an array from an array of the same up to the signess type.
     *
     * @param { Uint16Array } arr - An array to convert to a new array.
     * @returns { Int16Array } - A new Int16Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Uint16Array): Int16Array {
        let result = new Int16Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an object of std.core.Array<int>.
     *
     * @param { Array<int> } arr - An instance of the std.core.Array type to convert to an array.
     * @returns { Int16Array } - A new Int16Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Array<int>): Int16Array {
        let result = new Int16Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<number> } arrayLike - An array-like or iterable object to convert to an array.
     * @returns { Int16Array } - A new Int16Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: ArrayLike<number>): Int16Array {
        return Int16Array.from<number>(arrayLike, (x: number, k: number): number => x)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<T> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } mapfn - A mapping function to call on every element of the array.
     * @returns { Int16Array } - A new Int16Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number): Int16Array {
        let res = new Int16Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new FixedArray<int>(1)
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            const mapped = mapfn(x as T, idx[0])
            res.setUnsafe(idx[0], Int16Array.doubleToInt(mapped))
            idx[0]++
        })
        return res
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { Iterable<number> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } [mapfn] - A mapping function to call on every element of the array.
     * @returns { Int16Array } - A new Int16Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Int16Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE (templin.konstantin): This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Int16Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Int16Array(result.buffer, 0, i)
                }
                const mapped = (mapfn)!(x.value!, i)
                result.setUnsafe(i, Int16Array.doubleToInt(mapped))
            }
            return result
        }

        // NOTE (templin.konstantin): Create builtin array as buffer
        let temp = new Int16Array(6)
        let index : FixedArray<int> = new FixedArray<int>(1)
        index[0] = 0

        iteratorForEach<number>(iter, (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE (templin.konstantin): Progressive reallocation
                const curLength = temp.buffer.getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, temp.buffer.at(i))
                }
                temp = new Int16Array(tb)
            }
            const mapped = (mapfn)!(x, index[0])
            temp.setUnsafe(index[0], Int16Array.doubleToInt(mapped))
            index[0]++
        })
        return new Int16Array(temp.buffer, 0, index[0])
    }

    /**
     * Determines whether Int16Array includes a certain element, returning true or false as appropriate
     *
     * @param { short } searchElement - The element to search for
     * @param { int } fromIndex - The position in this array at which to begin searching for searchElement
     * @returns { boolean } - true if searchElement is in Int16Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: short, fromIndex: int): boolean {
        return this.indexOf(searchElement.toInt(), fromIndex) != -1
    }

    /**
     * Determines whether Int16Array includes a certain element, returning true or false as appropriate
     *
     * @param { short } searchElement - The element to search for. The search starts at index 0.
     * @returns { boolean } - true if searchElement is in Int16Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: short): boolean {
        return this.includes(searchElement, 0)
    }

    /**
     * Determines whether Int16Array includes a certain element, returning true or false as appropriate
     *
     * @param { number } searchElement - The element to search for
     * @param { int } [fromIndex] - The position in this array at which to begin searching for searchElement.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { boolean } - true if searchElement is in Int16Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: number, fromIndex?: int): boolean {
        if (isNaN(searchElement)) {
            return false
        }
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in Int16Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int): int {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Int16Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int, fromIndex: int): int {
        return this.indexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the first occurrence of a value in Int16Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } [fromIndex] - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: number, fromIndex?: int): int {
            return this.indexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Int16Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns {int} - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Int16Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Converts all elements of an array to strings and joins them using the specified separator.
     *
     * @param { String } separator - separates one element of an array from the next in the resulting String.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native joinInternal(separator: String): string;

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param { String } [separator] - A string used to separate one element of an array from the next in the
     *     resulting String. If omitted, the array elements are separated with a comma.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.joinInternal(",")
        }
        return this.joinInternal(separator)
    }

    /**
     * Returns an list of keys in Int16Array
     *
     * @returns { IterableIterator<int> } - iterator over keys
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public keys(): IterableIterator<int> {
        return new Int16ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Int16Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Int16Array.
     *
     * @param { number } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: number): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Int16Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int, fromIndex: int): int {
        return this.lastIndexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the last occurrence of a value in Int16Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int | undefined } fromIndex - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: number, fromIndex: int | undefined): int {
            return this.lastIndexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the last occurrence of a value in Int16Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the last occurrence of a value in Int16Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Creates a new Int16Array using initializer
     *
     * @param { FixedArray<Object> } data - initializer
     * @returns { Int16Array } - a new Int16Array
     * @throws { Error } - function not implemented
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public of(data: FixedArray<Object>): Int16Array {
        throw new Error("Int16Array.of: not implemented")
    }

    /**
     * Creates a new Int16Array using reversed data from the current one
     *
     * @returns { Int16Array } - a new Int16Array using reversed data from the current one
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native reverse(): Int16Array

    /**
     * Creates a slice of current Int16Array using range [begin, this.length).
     *
     * @param { int } begin - start index to be taken into slice
     * @returns { Int16Array } - a new Int16Array with elements of current Int16Array[begin, this.length)
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin: int): Int16Array {
        return this.sliceFromTo(begin, this.lengthInt)
    }

    /**
     * Creates a slice of current Int16Array using range [begin, end)
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sliceFromTo}
     *
     * @param { int } [begin] - start index to be taken into slice
     * @param { int } [end] - last index to be taken into slice
     * @returns { Int16Array } - a new Int16Array with elements of current Int16Array[begin;end),
     *     where end index is excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin?: int, end?: int): Int16Array {
        return this.sliceFromTo(begin ?? 0, end ?? this.lengthInt)
    }

    private sliceFromTo(begin: int, end: int): Int16Array {
        const relStart: int = normalizeIndex(begin, this.lengthInt)
        const relEnd: int = normalizeIndex(end, this.lengthInt)
        let buf: ArrayBuffer = this.buffer.slice(relStart * this.BYTES_PER_ELEMENT + this.byteOffset, relEnd * this.BYTES_PER_ELEMENT + this.byteOffset)
        return new Int16Array(buf)
    }


    /**
     * Creates a Int16Array with the same underlying ArrayBuffer
     *
     * @param { int } [begin] - start index, inclusive
     * @param { int } [end] - last index, exclusive
     * @returns { Int16Array } - a new Int16Array with the same underlying ArrayBuffer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public subarray(begin?: int, end?: int): Int16Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin ?? 0, len)
        const relEnd = normalizeIndex(end ?? this.lengthInt, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Int16Array(this.buffer, relStart * Int16Array.BYTES_PER_ELEMENT + this.byteOffset, count)
    }

    /**
     * Converts Int16Array to a string with respect to locale
     *
     * @returns { string } - string representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(new Number(this.getUnsafe(i)).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append(new Number(this.getUnsafe(this.lengthInt - 1))).toLocaleString()
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns { Int16Array } - a reversed copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toReversed(): Int16Array {
        let newArray = new Int16Array(this.lengthInt);
        if (this.lengthInt > 0) {
            Int16Array.reverseCopyBuffer(newArray.buffer, this.buffer, this.byteOffset, this.lengthInt);
        }
        return newArray
    }

    /**
     * Creates a sorted copy
     *
     * @returns { Int16Array } - a sorted copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toSorted(): Int16Array {
        return new Int16Array(this).sort()
    }

    /**
     * Returns a string representation of the Int16Array
     *
     * @returns { string } - a string representation of the Int16Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns { IterableIterator<Number> } - an iterator
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public values(): IterableIterator<Number> {
        return new Int16ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns { IterableIterator<Number> } - iterator over all elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override $_iterator(): IterableIterator<Number> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param { int } index - index to change
     * @param { short } value - value to set
     * @returns { Int16Array } - an Int16Array with replaced value on index
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: short): Int16Array {
        let res = new Int16Array(this)
        res.set(index, value)
        return res
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param { int } index - index to change
     * @param { number } value - value to set
     * @returns { Int16Array } - an Int16Array with replaced value on index
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: number): Int16Array {
        let res = new Int16Array(this)
        res.set(index, value.toShort())
        return res
    }

    /// === with element lambda functions ===

    /**
     * Finds the last element in the Int16Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { number } - the last element that satisfies fn
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Int16Array) => boolean =
            (val: number, index: int, array: Int16Array): boolean => { return fn(val) }
        return (this.findLast(newF)).toDouble()
    }

    /**
     * Sorts in-place by numeric value in ascending order.
     *
     * @returns { this } - sorted Int16Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native sort(): this;

    /**
     * Sorts in-place
     *
     * @param { function } [compareFn] - comparator _  used to determine the order of the elements.
     *     compareFn returns a negative value if first argument is less than second argument,
     *     zero if they're equal and a positive value otherwise.
     * @returns { this } - sorted Int16Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public sort(compareFn?: (a: number, b: number) => int): this {
        if (compareFn == undefined) {
            this.sort()
            return this
        }

        let cmp = (l: short, r: short): int => {
            const result = compareFn!((l).toDouble(), (r).toDouble())
            return result.toInt()
        }

        const MAX_SHORT_LENGTH = 24

        if (this.lengthInt > MAX_SHORT_LENGTH) {
            let arr: FixedArray<short> = new FixedArray<short>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                arr[i] = this.getUnsafe(i)
            }
            const arrLength = this.lengthInt

            arr = mergeSort(arr, cmp, 0, arrLength)

            for (let i = 0; i < arr.length; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let buffer: FixedArray<Short> = new FixedArray<Short>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                buffer[i] = this.getUnsafe(i)
            }
            const arrLength = this.lengthInt

            arr_sort_stable(buffer, 0, arrLength, cmp)
            for (let i = 0; i < buffer.length; ++i) {
                this.setUnsafe(i, buffer[i].toShort())
            }
        }
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The some method calls the predicate function for each element in the array
     *     until the predicate returns a true or until the end of the array.
     * @returns { boolean } - false unless predicate function returns true for an array element,
     *     in which case true is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public some(predicate: (element: number, index: int, array: Int16Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     *     The first call to the callbackfn function provides this value as an argument.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Int16Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array first element value as an argument
     * @returns { number } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the Int16Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Int16Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = (this.getUnsafe(0)).toDouble()
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Int16Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array last element value as an argument.
     * @returns { number } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the Int16Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Int16Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = (this.getUnsafe(this.lengthInt - 1)).toDouble()
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Creates a new Int16Array using fn(arr[i]) over all elements of current Int16Array.
     *
     * @param { function } fn - a function to apply for each element of current Int16Array
     * @returns { Int16Array } - a new Int16Array where for each element from current Int16Array fn was applied
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public map(fn: (val: number, index: int, array: Int16Array) => number): Int16Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Int16Array.BYTES_PER_ELEMENT)
        let res = new Int16Array(resBuf, 0, (resBuf.getByteLength() / Int16Array.BYTES_PER_ELEMENT).toInt())
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn((this.getUnsafe(i)).toDouble(), i, this).toShort())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The every method calls the predicate function for each element in the array until the predicate
     *     returns a false, or until the end of the array.
     * @returns { boolean } - true unless predicate function returns a false for an array element,
     *     in which case false is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public every(predicate: (element: number, index: int, array: Int16Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Creates a new Int16Array from current Int16Array based on a condition fn.
     *
     * @param { function } fn - the condition to apply for each element
     * @returns { Int16Array } - a new Int16Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public filter(fn: (val: number, index: int, array: Int16Array) => boolean): Int16Array {
        let markers : FixedArray<boolean> = new FixedArray<boolean>(this.lengthInt)
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn((this.getUnsafe(i)).toDouble(), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int16Array.BYTES_PER_ELEMENT)
        let res = new Int16Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found, find
     *     immediately returns that element value. Otherwise, find returns undefined
     * @returns { number | undefined }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public find(predicate: (value: number, index: int, obj: Int16Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate((val).toDouble(), i, this)) {
                return (val).toDouble()
            }
        }
        return undefined
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1 otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found,
     *     findIndex immediately returns that element index. Otherwise, findIndex returns -1
     * @returns { int } - Index of the first matched element
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findIndex(predicate: (value: number, index: int, obj: Int16Array) => boolean): int {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds the last element in the Int16Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { short } - the last element that satisfies fn
     * @throws { Error } - If the element cannot be found, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: number, index: int, array: Int16Array) => boolean): short {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn((val).toDouble(), i, this)) {
                return val
            }
        }
        throw new Error("Int16Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds an index of the last element in the Int16Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { int } - the index of the last element that satisfies fn, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLastIndex(fn: (val: number, index: int, array: Int16Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn((val).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Performs the specified action for each element in Int16Array
     *
     * @param { function } callbackfn - A function that accepts up to three arguments. forEach calls the
     *     callbackfn function one time for each element in the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public forEach(callbackfn: (value: number, index: int, array: Int16Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn((this.getUnsafe(i)).toDouble(), i, this)
        }
    }

    /**
     * Returns the object itself
     *
     * @returns { Int16Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public valueOf(): Int16Array {
        return this
    }

    private static native reverseCopyBuffer(dstBuf: ArrayBuffer, srcBuf: ArrayBuffer, startPos: int, length: int): void

    private final native getUnsafe(index: int): short

    private setUnsafe(insertPos: int, val: short): void {
        const BPE = Int16Array.BYTES_PER_ELEMENT.toInt()
        let byteIndex = insertPos * BPE + this.byteOffset
        let buf = this.buffer
        let bits = val
        if (IS_LITTLE_ENDIAN) {
            for (let i = 0; i < BPE; ++i) {
                let byteVal = ((bits >>> (i * 8)) & 0xff).toByte()
                buf.set(byteIndex++, byteVal)
            }
        } else {
            byteIndex = byteIndex + BPE - 1
            for (let i = 0; i < BPE; ++i) {
                let byteVal = ((bits >>> (i * 8)) & 0xff).toByte()
                buf.set(byteIndex--, byteVal)
            }
        }
        
    }

    /**
     * Underlying ArrayBuffer
     *
     * @type { ArrayBuffer }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly buffer: ArrayBuffer

    /**
     * Byte offset within the underlying ArrayBuffer
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteOffset: int

    /**
     * Number of bytes used
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteLength: int

    /**
     * String \"Int16Array\"
     *
     * @type { string }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly name = "Int16Array"
}

class Int32ArrayIteratorKeys implements IterableIterator<int> {
    private length: int
    private idx: int = 0

    constructor(parent: Int32Array) {
        this.length = parent.length
    }

    public override $_iterator(): IterableIterator<int> {
        return this
    }

    override next(): IteratorResult<int> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(false, this.idx++)
    }
}

class Int32ArrayIterator implements IterableIterator<Number> {
    private parent: Int32Array
    private idx: int = 0

    constructor(parent: Int32Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Int32ArrayIteratorEntries implements IterableIterator<[int, Number]> {
    private parent: Int32Array
    private idx: int = 0

    constructor(parent: Int32Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[int, Number]> {
        return this
    }

    override next(): IteratorResult<[int, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<[int, Number]>()
        }
        return new IteratorResult<[int, Number]>(
            false, [this.idx, new Number(this.parent[this.idx++])]
        )
    }
}


/**
 * Defines Int32Array
 *
 * @implements { Iterable<Number>, ArrayLike<Number> }
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export final class Int32Array implements Iterable<Number>, ArrayLike<Number> {
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static readonly BYTES_PER_ELEMENT: int = 4
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly BYTES_PER_ELEMENT: int = Int32Array.BYTES_PER_ELEMENT
    protected readonly lengthInt: int

    /**
     * Creates an empty Int32Array.
     *
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor() {
        this(0)
    }

    /**
     * Creates an Int32Array with respect to length.
     *
     * @param { int } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: int) {
        this(length.toDouble())
    }

    /**
     * Creates an Int32Array with respect to length.
     *
     * @param { number } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: number) {
        if (length < 0 || length > (Int.MAX_VALUE / Int32Array.BYTES_PER_ELEMENT).toInt()) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length.toInt()
        this.byteLength = this.lengthInt * Int32Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates a copy of Int32Array.
     *
     * @param { Int32Array } other - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(other: Int32Array) {
        this.buffer = other.buffer.slice(other.byteOffset, other.byteOffset + other.byteLength) as ArrayBuffer
        this.byteLength = other.byteLength
        this.lengthInt = other.length
        this.byteOffset = 0
    }

    /**
     * Creates an Int32Array from FixedArray<int>
     *
     * @param { FixedArray<int> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].toInt())
        }
    }

    /**
     * Creates an Int32Array from FixedArray<number>
     *
     * @param { FixedArray<number> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<number>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, Int32Array.doubleToInt(numbers[i]))
        }
    }

    /**
     * Creates an Int32Array from Array<int>
     *
     * @param { Array<int> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: Array<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i])
        }
    }

    /**
     * Creates an Int32Array with respect to data accessed via Iterable<Number> interface
     *
     * @param { Iterable<Number> } elements - an iterable object
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(elements: Iterable<Number>) {
        const items: Object = elements as Object
        if (items instanceof ArrayLike) {
            const arr = reflect.internals.Types.identity_cast<Number>(items as ArrayLike<Number>)
            this.byteLength = arr.length * Int32Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, Int32Array.doubleToInt(arr[i]))
            }
        } else {
            let x = Int32Array.from(elements)
            this.byteLength = x.byteLength
            this.lengthInt = x.lengthInt
            this.buffer = x.buffer
            this.byteOffset = x.byteOffset
        }
    }
    private static native doubleToInt(d: double): int;

    /**
     * Creates an Int32Array with respect to buf and byteOffset.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int32Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { number } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int32Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @param { int } length - size of elements of type int in newly created Int32Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Int32Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { Number | undefined } byteOffset - byte offset from begin of the buf
     * @param { Number | undefined } length - size of elements of type int in newly created Int32Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.toInt()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int = buf.getByteLength() - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteOffset % Int32Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 4 as Int32Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.toInt()
            if (intLength > (intByteLength / Int32Array.BYTES_PER_ELEMENT).toInt()) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = (intByteLength / Int32Array.BYTES_PER_ELEMENT).toInt()
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < (intByteLength / Int32Array.BYTES_PER_ELEMENT).toInt()) {
            intByteLength = intLength * Int32Array.BYTES_PER_ELEMENT
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Int32Array with respect to buf.
     *
     * @param { ArrayLike<Number> | ArrayBuffer } buf - data initializer
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayLike<Number> | ArrayBuffer) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % Int32Array.BYTES_PER_ELEMENT.toInt() != 0) {
               throw new RangeError("ArrayBuffer.byteLength should be multiple of 4 as Int32Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = (this.byteLength / Int32Array.BYTES_PER_ELEMENT).toInt()
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length * Int32Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, Int32Array.doubleToInt(arr[i]))
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { int } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_set(index: int, val: int): void

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { number } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public $_set(index: int, val: number): void {
        this.$_set(index, Int32Array.doubleToInt(val))
    }

    /**
     * Number of int stored in Int32Array
     *
     * @returns { int } - the number of elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public get length(): int {
        return this.lengthInt
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param { int } index - index to look at
     * @returns { number } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_get(index: int): number

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param { int } index - index to look at
     * @returns { Number | undefined } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } [end] - last index to end copy from, excluded
     * @returns { Int32Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int, start: int, end?: int): Int32Array {
        let arrayLength: int = this.lengthInt;
        target = normalizeIndex(target, arrayLength);
        start = normalizeIndex(start, arrayLength);
        end = normalizeIndex(asIntOrDefault(end, arrayLength), arrayLength);
        let count: int = end - start;
        if (count > (arrayLength - target)) {
            count = arrayLength - target;
        }
        if (count <= 0) {
            return this;
        }

        this.copyWithinImpl(target, start, count)
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } end - last index to end copy from, excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private native copyWithinImpl(target: int, start: int, end: int): void

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Int32Array.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @returns { Int32Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int): Int32Array {
        this.copyWithinImpl(target, 0, this.lengthInt)
        return this
    }

    /**
     * Returns an array of key, value pairs for every entry in the Int32Array
     *
     * @returns { IterableIterator<[int, Number]> } - key, value pairs for every entry in the array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public entries(): IterableIterator<[int, Number]> {
        return new Int32ArrayIteratorEntries(this)
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param { int } value - new value
     * @param { int } [start] - start index to begin fill from
     * @param { int } [end] - last index to end fill from, excluded
     * @returns { this } - modified Int32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: int, start?: int, end?: int): this {
        const k = normalizeIndex(start ?? 0, this.lengthInt)
        const finalPos = normalizeIndex(end ?? this.lengthInt, this.lengthInt)
        this.fillInternal(value, k, finalPos)
        return this
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param { number } value - new value
     * @param { int } [start] - start index to begin fill from
     * @param { int } [end] - last index to end fill from, excluded
     * @returns { this } - modified Int32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: number, start?: int, end?: int): this {
        this.fill(Int32Array.doubleToInt(value), start, end)
        return this
    }

    private final native fillInternal(value: int, start: int, end: int): void

    /**
     * Assigns val as element on insertPos.
     *
     * @param { int } insertPos - index to change
     * @param { int } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(insertPos: int, val: int): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on insertPos.
     *
     * @param { int } insertPos - index to change
     * @param { number } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(insertPos: int, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Int32Array.
     *
     * @param { FixedArray<int> } arr - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<int>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Int32Array starting from insertPos.
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     *
     * @param { FixedArray<int> } arr - array to copy data from
     * @param { int } insertPos - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<int>, insertPos: int): void {
        const offset = insertPos
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.setUnsafe(offset + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Int32Array.
     *
     * @param { FixedArray<number> } arr - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<number>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Int32Array starting from insertPos.
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     *
     * @param { FixedArray<number> } arr - array to copy data from
     * @param { int } insertPos - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<number>, insertPos: int): void {
        const offset = insertPos
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.setUnsafe(offset + i, Int32Array.doubleToInt(arr[i]))
        }
    }

    private native final set(array: Array<int>): void;

    /**
     * Copies all elements of array to the current Int32Array.
     *
     * @param { Int32Array } array - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: Int32Array): void

    /**
     * Copies all elements of arr to the current Int32Array starting from offset.
     *
     * @param { Int32Array } array - array to copy data from
     * @param { int } offset - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: Int32Array, offset: int): void

    /**
     * Copies elements from an ArrayLike object to the Int32Array.
     *
     * @param { ArrayLike<number> } array - An ArrayLike object containing the elements to copy.
     * @param { int } [offset] - Optional. The offset into the target array at which to begin
     *     writing values from the source array. The default value is 0.
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(array: ArrayLike<number>, offset: int = 0): void {
        const insertPos = offset
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; ++i) {
            this.setUnsafe(insertPos + i, Int32Array.doubleToInt(array[i]))
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<int> } items - a set of elements to include in the new array object.
     * @returns { Int32Array } - a new Int32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<int>): Int32Array {
        let res = new Int32Array(items.length.toInt())
        res.ofInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<number> } items - a set of elements to include in the new array object.
     * @returns { Int32Array } - a new Int32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<number>): Int32Array {
        let res = new Int32Array(items.length.toInt())
        res.ofNumber(items)
        return res
    }

    private final native ofInt(items: FixedArray<int>): void
    private final native ofNumber(items: FixedArray<number>): void

    /**
     * Returns a new array from a set of elements.
     *
     * @returns { Int32Array } - a new Int32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(): Int32Array {
        return new Int32Array(0)
    }

    /**
     * Creates an array from an object of FixedArray<int>.
     *
     * @param { FixedArray<int> } arr - An instance of the FixedArray type to convert to an array.
     * @returns { Int32Array } - A new Int32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: FixedArray<int>): Int32Array {
        let result = new Int32Array(arr.length)
        result.ofInt(arr)
        return result
    }

    /**
     * Creates an array from a set of type std.core.Set<int>.
     *
     * @param { Set<int> } set - A set object to convert to an array.
     * @returns { Int32Array } - A new Int32Array
     * @throws { AssertionError } - Input parameter error.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(set: Set<int>): Int32Array {
        const length = set.size;
        const result = new Int32Array(length)
        let iter = set.$_iterator()
        for (let i:int = 0; i < length; ++i) {
            const x = iter.next()
            if (x.done) {
                throw new AssertionError('Wrong Length')
            }
            result.setUnsafe(i, x.value!.toInt())
        }
        return result
    }

    /**
     * Creates an array from an array of the same type.
     *
     * @param { Int32Array } arr - An array to convert to a new array.
     * @returns { Int32Array } - A new Int32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Int32Array): Int32Array {
        let result = new Int32Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an object of std.core.Array<int>.
     *
     * @param { Array<int> } arr - An instance of the std.core.Array type to convert to an array.
     * @returns { Int32Array } - A new Int32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Array<int>): Int32Array {
        let result = new Int32Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<number> } arrayLike - An array-like or iterable object to convert to an array.
     * @returns { Int32Array } - A new Int32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: ArrayLike<number>): Int32Array {
        return Int32Array.from<number>(arrayLike, (x: number, k: number): number => x)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<T> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } mapfn - A mapping function to call on every element of the array.
     * @returns { Int32Array } - A new Int32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number): Int32Array {
        let res = new Int32Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new FixedArray<int>(1)
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            const mapped = mapfn(x as T, idx[0])
            res.setUnsafe(idx[0], Int32Array.doubleToInt(mapped))
            idx[0]++
        })
        return res
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { Iterable<number> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } [mapfn] - A mapping function to call on every element of the array.
     * @returns { Int32Array } - A new Int32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Int32Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE (templin.konstantin): This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Int32Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Int32Array(result.buffer, 0, i)
                }
                const mapped = (mapfn)!(x.value!, i)
                result.setUnsafe(i, Int32Array.doubleToInt(mapped))
            }
            return result
        }

        // NOTE (templin.konstantin): Create builtin array as buffer
        let temp = new Int32Array(6)
        let index : FixedArray<int> = new FixedArray<int>(1)
        index[0] = 0

        iteratorForEach<number>(iter, (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE (templin.konstantin): Progressive reallocation
                const curLength = temp.buffer.getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, temp.buffer.at(i))
                }
                temp = new Int32Array(tb)
            }
            const mapped = (mapfn)!(x, index[0])
            temp.setUnsafe(index[0], Int32Array.doubleToInt(mapped))
            index[0]++
        })
        return new Int32Array(temp.buffer, 0, index[0])
    }

    /**
     * Determines whether Int32Array includes a certain element, returning true or false as appropriate
     *
     * @param { int } searchElement - The element to search for
     * @param { int } fromIndex - The position in this array at which to begin searching for searchElement
     * @returns { boolean } - true if searchElement is in Int32Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: int, fromIndex: int): boolean {
        return this.indexOf(searchElement.toInt(), fromIndex) != -1
    }

    /**
     * Determines whether Int32Array includes a certain element, returning true or false as appropriate
     *
     * @param { int } searchElement - The element to search for. The search starts at index 0.
     * @returns { boolean } - true if searchElement is in Int32Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: int): boolean {
        return this.includes(searchElement, 0)
    }

    /**
     * Determines whether Int32Array includes a certain element, returning true or false as appropriate
     *
     * @param { number } searchElement - The element to search for
     * @param { int } [fromIndex] - The position in this array at which to begin searching for searchElement.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { boolean } - true if searchElement is in Int32Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: number, fromIndex?: int): boolean {
        if (isNaN(searchElement)) {
            return false
        }
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in Int32Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int): int {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Int32Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int, fromIndex: int): int {
        return this.indexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the first occurrence of a value in Int32Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } [fromIndex] - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: number, fromIndex?: int): int {
            return this.indexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Int32Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns {int} - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Int32Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Converts all elements of an array to strings and joins them using the specified separator.
     *
     * @param { String } separator - separates one element of an array from the next in the resulting String.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native joinInternal(separator: String): string;

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param { String } [separator] - A string used to separate one element of an array from the next in the
     *     resulting String. If omitted, the array elements are separated with a comma.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.joinInternal(",")
        }
        return this.joinInternal(separator)
    }

    /**
     * Returns an list of keys in Int32Array
     *
     * @returns { IterableIterator<int> } - iterator over keys
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public keys(): IterableIterator<int> {
        return new Int32ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Int32Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Int32Array.
     *
     * @param { number } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: number): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Int32Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int, fromIndex: int): int {
        return this.lastIndexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the last occurrence of a value in Int32Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int | undefined } fromIndex - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: number, fromIndex: int | undefined): int {
            return this.lastIndexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the last occurrence of a value in Int32Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the last occurrence of a value in Int32Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Creates a new Int32Array using initializer
     *
     * @param { FixedArray<Object> } data - initializer
     * @returns { Int32Array } - a new Int32Array
     * @throws { Error } - function not implemented
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public of(data: FixedArray<Object>): Int32Array {
        throw new Error("Int32Array.of: not implemented")
    }

    /**
     * Creates a new Int32Array using reversed data from the current one
     *
     * @returns { Int32Array } - a new Int32Array using reversed data from the current one
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native reverse(): Int32Array

    /**
     * Creates a slice of current Int32Array using range [begin, this.length).
     *
     * @param { int } begin - start index to be taken into slice
     * @returns { Int32Array } - a new Int32Array with elements of current Int32Array[begin, this.length)
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin: int): Int32Array {
        return this.sliceFromTo(begin, this.lengthInt)
    }

    /**
     * Creates a slice of current Int32Array using range [begin, end)
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sliceFromTo}
     *
     * @param { int } [begin] - start index to be taken into slice
     * @param { int } [end] - last index to be taken into slice
     * @returns { Int32Array } - a new Int32Array with elements of current Int32Array[begin;end),
     *     where end index is excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin?: int, end?: int): Int32Array {
        return this.sliceFromTo(begin ?? 0, end ?? this.lengthInt)
    }

    private sliceFromTo(begin: int, end: int): Int32Array {
        const relStart: int = normalizeIndex(begin, this.lengthInt)
        const relEnd: int = normalizeIndex(end, this.lengthInt)
        let buf: ArrayBuffer = this.buffer.slice(relStart * this.BYTES_PER_ELEMENT + this.byteOffset, relEnd * this.BYTES_PER_ELEMENT + this.byteOffset)
        return new Int32Array(buf)
    }


    /**
     * Creates a Int32Array with the same underlying ArrayBuffer
     *
     * @param { int } [begin] - start index, inclusive
     * @param { int } [end] - last index, exclusive
     * @returns { Int32Array } - a new Int32Array with the same underlying ArrayBuffer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public subarray(begin?: int, end?: int): Int32Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin ?? 0, len)
        const relEnd = normalizeIndex(end ?? this.lengthInt, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Int32Array(this.buffer, relStart * Int32Array.BYTES_PER_ELEMENT + this.byteOffset, count)
    }

    /**
     * Converts Int32Array to a string with respect to locale
     *
     * @returns { string } - string representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(new Number(this.getUnsafe(i)).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append(new Number(this.getUnsafe(this.lengthInt - 1))).toLocaleString()
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns { Int32Array } - a reversed copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toReversed(): Int32Array {
        let newArray = new Int32Array(this.lengthInt);
        if (this.lengthInt > 0) {
            Int32Array.reverseCopyBuffer(newArray.buffer, this.buffer, this.byteOffset, this.lengthInt);
        }
        return newArray
    }

    /**
     * Creates a sorted copy
     *
     * @returns { Int32Array } - a sorted copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toSorted(): Int32Array {
        return new Int32Array(this).sort()
    }

    /**
     * Returns a string representation of the Int32Array
     *
     * @returns { string } - a string representation of the Int32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns { IterableIterator<Number> } - an iterator
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public values(): IterableIterator<Number> {
        return new Int32ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns { IterableIterator<Number> } - iterator over all elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override $_iterator(): IterableIterator<Number> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param { int } index - index to change
     * @param { int } value - value to set
     * @returns { Int32Array } - an Int32Array with replaced value on index
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: int): Int32Array {
        let res = new Int32Array(this)
        res.set(index, value)
        return res
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param { int } index - index to change
     * @param { number } value - value to set
     * @returns { Int32Array } - an Int32Array with replaced value on index
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: number): Int32Array {
        let res = new Int32Array(this)
        res.set(index, value.toInt())
        return res
    }

    /// === with element lambda functions ===

    /**
     * Finds the last element in the Int32Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { number } - the last element that satisfies fn
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Int32Array) => boolean =
            (val: number, index: int, array: Int32Array): boolean => { return fn(val) }
        return (this.findLast(newF)).toDouble()
    }

    /**
     * Sorts in-place by numeric value in ascending order.
     *
     * @returns { this } - sorted Int32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native sort(): this;

    /**
     * Sorts in-place
     *
     * @param { function } [compareFn] - comparator _  used to determine the order of the elements.
     *     compareFn returns a negative value if first argument is less than second argument,
     *     zero if they're equal and a positive value otherwise.
     * @returns { this } - sorted Int32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public sort(compareFn?: (a: number, b: number) => int): this {
        if (compareFn == undefined) {
            this.sort()
            return this
        }

        let cmp = (l: int, r: int): int => {
            const result = compareFn!((l).toDouble(), (r).toDouble())
            return result.toInt()
        }

        const MAX_SHORT_LENGTH = 24

        if (this.lengthInt > MAX_SHORT_LENGTH) {
            let arr: FixedArray<int> = new FixedArray<int>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                arr[i] = this.getUnsafe(i)
            }
            const arrLength = this.lengthInt

            arr = mergeSort(arr, cmp, 0, arrLength)

            for (let i = 0; i < arr.length; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let buffer: FixedArray<Int> = new FixedArray<Int>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                buffer[i] = this.getUnsafe(i)
            }
            const arrLength = this.lengthInt

            arr_sort_stable(buffer, 0, arrLength, cmp)
            for (let i = 0; i < buffer.length; ++i) {
                this.setUnsafe(i, buffer[i].toInt())
            }
        }
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The some method calls the predicate function for each element in the array
     *     until the predicate returns a true or until the end of the array.
     * @returns { boolean } - false unless predicate function returns true for an array element,
     *     in which case true is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public some(predicate: (element: number, index: int, array: Int32Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     *     The first call to the callbackfn function provides this value as an argument.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Int32Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array first element value as an argument
     * @returns { number } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the Int32Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Int32Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = (this.getUnsafe(0)).toDouble()
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Int32Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array last element value as an argument.
     * @returns { number } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the Int32Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Int32Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = (this.getUnsafe(this.lengthInt - 1)).toDouble()
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Creates a new Int32Array using fn(arr[i]) over all elements of current Int32Array.
     *
     * @param { function } fn - a function to apply for each element of current Int32Array
     * @returns { Int32Array } - a new Int32Array where for each element from current Int32Array fn was applied
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public map(fn: (val: number, index: int, array: Int32Array) => number): Int32Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Int32Array.BYTES_PER_ELEMENT)
        let res = new Int32Array(resBuf, 0, (resBuf.getByteLength() / Int32Array.BYTES_PER_ELEMENT).toInt())
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn((this.getUnsafe(i)).toDouble(), i, this).toInt())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The every method calls the predicate function for each element in the array until the predicate
     *     returns a false, or until the end of the array.
     * @returns { boolean } - true unless predicate function returns a false for an array element,
     *     in which case false is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public every(predicate: (element: number, index: int, array: Int32Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Creates a new Int32Array from current Int32Array based on a condition fn.
     *
     * @param { function } fn - the condition to apply for each element
     * @returns { Int32Array } - a new Int32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public filter(fn: (val: number, index: int, array: Int32Array) => boolean): Int32Array {
        let markers : FixedArray<boolean> = new FixedArray<boolean>(this.lengthInt)
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn((this.getUnsafe(i)).toDouble(), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int32Array.BYTES_PER_ELEMENT)
        let res = new Int32Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found, find
     *     immediately returns that element value. Otherwise, find returns undefined
     * @returns { number | undefined }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public find(predicate: (value: number, index: int, obj: Int32Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate((val).toDouble(), i, this)) {
                return (val).toDouble()
            }
        }
        return undefined
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1 otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found,
     *     findIndex immediately returns that element index. Otherwise, findIndex returns -1
     * @returns { int } - Index of the first matched element
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findIndex(predicate: (value: number, index: int, obj: Int32Array) => boolean): int {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds the last element in the Int32Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { int } - the last element that satisfies fn
     * @throws { Error } - If the element cannot be found, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: number, index: int, array: Int32Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn((val).toDouble(), i, this)) {
                return val
            }
        }
        throw new Error("Int32Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds an index of the last element in the Int32Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { int } - the index of the last element that satisfies fn, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLastIndex(fn: (val: number, index: int, array: Int32Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn((val).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Performs the specified action for each element in Int32Array
     *
     * @param { function } callbackfn - A function that accepts up to three arguments. forEach calls the
     *     callbackfn function one time for each element in the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public forEach(callbackfn: (value: number, index: int, array: Int32Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn((this.getUnsafe(i)).toDouble(), i, this)
        }
    }

    /**
     * Returns the object itself
     *
     * @returns { Int32Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public valueOf(): Int32Array {
        return this
    }

    private static native reverseCopyBuffer(dstBuf: ArrayBuffer, srcBuf: ArrayBuffer, startPos: int, length: int): void

    private final native getUnsafe(index: int): int

    private setUnsafe(insertPos: int, val: int): void {
        const BPE = Int32Array.BYTES_PER_ELEMENT.toInt()
        let byteIndex = insertPos * BPE + this.byteOffset
        let buf = this.buffer
        let bits = val
        if (IS_LITTLE_ENDIAN) {
            for (let i = 0; i < BPE; ++i) {
                let byteVal = ((bits >>> (i * 8)) & 0xff).toByte()
                buf.set(byteIndex++, byteVal)
            }
        } else {
            byteIndex = byteIndex + BPE - 1
            for (let i = 0; i < BPE; ++i) {
                let byteVal = ((bits >>> (i * 8)) & 0xff).toByte()
                buf.set(byteIndex--, byteVal)
            }
        }
        
    }

    /**
     * Underlying ArrayBuffer
     *
     * @type { ArrayBuffer }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly buffer: ArrayBuffer

    /**
     * Byte offset within the underlying ArrayBuffer
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteOffset: int

    /**
     * Number of bytes used
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteLength: int

    /**
     * String \"Int32Array\"
     *
     * @type { string }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly name = "Int32Array"
}

class BigInt64ArrayIteratorKeys implements IterableIterator<int> {
    private length: int
    private idx: int = 0

    constructor(parent: BigInt64Array) {
        this.length = parent.length
    }

    public override $_iterator(): IterableIterator<int> {
        return this
    }

    override next(): IteratorResult<int> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(false, this.idx++)
    }
}

class BigInt64ArrayIterator implements IterableIterator<BigInt> {
    private parent: BigInt64Array
    private idx: int = 0

    constructor(parent: BigInt64Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<BigInt> {
        return this
    }

    override next(): IteratorResult<BigInt> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<BigInt>()
        }
        return new IteratorResult<BigInt>(false, new BigInt(this.parent[this.idx++]))
    }
}

class BigInt64ArrayIteratorEntries implements IterableIterator<[int, BigInt]> {
    private parent: BigInt64Array
    private idx: int = 0

    constructor(parent: BigInt64Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[int, BigInt]> {
        return this
    }

    override next(): IteratorResult<[int, BigInt]> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<[int, BigInt]>()
        }
        return new IteratorResult<[int, BigInt]>(
            false, [this.idx, new BigInt(this.parent[this.idx++])] as [int, BigInt]
        )
    }
}


/**
 * Defines BigInt64Array
 *
 * @implements { Iterable<BigInt>, ArrayLike<BigInt> }
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export final class BigInt64Array implements Iterable<BigInt>, ArrayLike<BigInt> {
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static readonly BYTES_PER_ELEMENT: int = 8
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly BYTES_PER_ELEMENT: int = BigInt64Array.BYTES_PER_ELEMENT
    protected readonly lengthInt: int

    /**
     * Creates an empty BigInt64Array.
     *
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor() {
        this(0)
    }

    /**
     * Creates an BigInt64Array with respect to length.
     *
     * @param { int } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: int) {
        this(length.toDouble())
    }

    /**
     * Creates an BigInt64Array with respect to length.
     *
     * @param { number } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: number) {
        if (length < 0 || length > (Int.MAX_VALUE / BigInt64Array.BYTES_PER_ELEMENT).toInt()) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length.toInt()
        this.byteLength = this.lengthInt * BigInt64Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates a copy of BigInt64Array.
     *
     * @param { BigInt64Array } other - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(other: BigInt64Array) {
        this.buffer = other.buffer.slice(other.byteOffset, other.byteOffset + other.byteLength) as ArrayBuffer
        this.byteLength = other.byteLength
        this.lengthInt = other.length
        this.byteOffset = 0
    }

    /**
     * Creates an BigInt64Array from FixedArray<int>
     *
     * @param { FixedArray<int> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].toLong())
        }
    }

    /**
     * Creates an BigInt64Array from FixedArray<number>
     *
     * @param { FixedArray<number> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<number>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].toLong())
        }
    }

    /**
     * Creates an BigInt64Array from FixedArray<bigint>
     *
     * @param { FixedArray<bigint> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<bigint>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].getLong())
        }
    }

    /**
     * Creates an BigInt64Array with respect to data accessed via Iterable<Number> interface
     *
     * @param { Iterable<BigInt> } elements - an iterable object
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(elements: Iterable<BigInt>) {
        const items: Object = elements as Object
        if (items instanceof ArrayLike) {
            const arr = reflect.internals.Types.identity_cast<BigInt>(items as ArrayLike<BigInt>)
            this.byteLength = arr.length * BigInt64Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr[i].getLong())
            }
        } else {
            let x = BigInt64Array.from(elements)
            this.byteLength = x.byteLength
            this.lengthInt = x.lengthInt
            this.buffer = x.buffer
            this.byteOffset = x.byteOffset
        }
    }

    /**
     * Creates an BigInt64Array with respect to buf and byteOffset.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an BigInt64Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { number } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an BigInt64Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @param { int } length - size of elements of type long in newly created BigInt64Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an BigInt64Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { Number | undefined } byteOffset - byte offset from begin of the buf
     * @param { Number | undefined } length - size of elements of type long in newly created BigInt64Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.toInt()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int = buf.getByteLength() - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteOffset % BigInt64Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 8 as BigInt64Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.toInt()
            if (intLength > (intByteLength / BigInt64Array.BYTES_PER_ELEMENT).toInt()) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = (intByteLength / BigInt64Array.BYTES_PER_ELEMENT).toInt()
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < (intByteLength / BigInt64Array.BYTES_PER_ELEMENT).toInt()) {
            intByteLength = intLength * BigInt64Array.BYTES_PER_ELEMENT
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an BigInt64Array with respect to buf.
     *
     * @param { ArrayLike<Number> | ArrayBuffer } buf - data initializer
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayLike<Number> | ArrayBuffer) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % BigInt64Array.BYTES_PER_ELEMENT.toInt() != 0) {
               throw new RangeError("ArrayBuffer.byteLength should be multiple of 8 as BigInt64Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = (this.byteLength / BigInt64Array.BYTES_PER_ELEMENT).toInt()
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length * BigInt64Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr[i].toLong())
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { long } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_set(index: int, val: long): void

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { BigInt } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public $_set(index: int, val: BigInt): void {
        this.$_set(index, val.getLong())
    }

    /**
     * Number of long stored in BigInt64Array
     *
     * @returns { int } - the number of elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public get length(): int {
        return this.lengthInt
    }

    /**
     * Returns an instance of BigInt at passed index.
     *
     * @param { int } index - index to look at
     * @returns { BigInt } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public $_get(index: int): BigInt {
        return new BigInt(this.getLong(index))
    }

    private native getLong(index: int): long

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param { int } index - index to look at
     * @returns { BigInt | undefined } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public at(index: int): BigInt | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new BigInt(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } [end] - last index to end copy from, excluded
     * @returns { BigInt64Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int, start: int, end?: int): BigInt64Array {
        let arrayLength: int = this.lengthInt;
        target = normalizeIndex(target, arrayLength);
        start = normalizeIndex(start, arrayLength);
        end = normalizeIndex(asIntOrDefault(end, arrayLength), arrayLength);
        let count: int = end - start;
        if (count > (arrayLength - target)) {
            count = arrayLength - target;
        }
        if (count <= 0) {
            return this;
        }

        this.copyWithinImpl(target, start, count)
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } end - last index to end copy from, excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private native copyWithinImpl(target: int, start: int, end: int): void

    /**
     * Makes a copy of internal elements to targetPos from begin to end of BigInt64Array.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @returns { BigInt64Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int): BigInt64Array {
        this.copyWithinImpl(target, 0, this.lengthInt)
        return this
    }

    /**
     * Returns an array of key, value pairs for every entry in the BigInt64Array
     *
     * @returns { IterableIterator<[int, BigInt]> } - key, value pairs for every entry in the array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public entries(): IterableIterator<[int, BigInt]> {
        return new BigInt64ArrayIteratorEntries(this)
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param { long } value - new value
     * @param { int } [start] - start index to begin fill from
     * @param { int } [end] - last index to end fill from, excluded
     * @returns { this } - modified BigInt64Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: long, start?: int, end?: int): this {
        const k = normalizeIndex(start ?? 0, this.lengthInt)
        const finalPos = normalizeIndex(end ?? this.lengthInt, this.lengthInt)
        this.fillInternal(value, k, finalPos)
        return this
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param { BigInt } value - new value
     * @param { int } [start] - start index to begin fill from
     * @param { int } [end] - last index to end fill from, excluded
     * @returns { this } - modified BigInt64Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: BigInt, start?: int, end?: int): this {
        this.fill(value.getLong(), start, end)
        return this
    }

    private final native fillInternal(value: long, start: int, end: int): void

    /**
     * Assigns val as element on insertPos.
     *
     * @param { int } insertPos - index to change
     * @param { long } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(insertPos: int, val: long): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on insertPos.
     *
     * @param { int } insertPos - index to change
     * @param { BigInt } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(insertPos: int, val: BigInt): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current BigInt64Array.
     *
     * @param { FixedArray<long> } arr - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<long>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current BigInt64Array starting from insertPos.
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     *
     * @param { FixedArray<long> } arr - array to copy data from
     * @param { int } insertPos - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<long>, insertPos: int): void {
        const offset = insertPos
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.setUnsafe(offset + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current BigInt64Array.
     *
     * @param { FixedArray<BigInt> } arr - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<BigInt>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current BigInt64Array starting from insertPos.
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     *
     * @param { FixedArray<BigInt> } arr - array to copy data from
     * @param { int } insertPos - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<BigInt>, insertPos: int): void {
        const offset = insertPos
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.setUnsafe(offset + i, arr[i].getLong())
        }
    }

    private native final set(array: Array<BigInt>): void;

    /**
     * Copies all elements of array to the current BigInt64Array.
     *
     * @param { BigInt64Array } array - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: BigInt64Array): void

    /**
     * Copies all elements of arr to the current BigInt64Array starting from offset.
     *
     * @param { BigInt64Array } array - array to copy data from
     * @param { int } offset - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: BigInt64Array, offset: int): void

    /**
     * Copies elements from an ArrayLike object to the BigInt64Array.
     *
     * @param { ArrayLike<BigInt> } array - An ArrayLike object containing the elements to copy.
     * @param { int } [offset] - Optional. The offset into the target array at which to begin
     *     writing values from the source array. The default value is 0.
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(array: ArrayLike<BigInt>, offset: int = 0): void {
        const insertPos = offset
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; ++i) {
            this.setUnsafe(insertPos + i, array[i].getLong())
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<int> } items - a set of elements to include in the new array object.
     * @returns { BigInt64Array } - a new BigInt64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<int>): BigInt64Array {
        let res = new BigInt64Array(items.length.toInt())
        res.ofInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<long> } items - a set of elements to include in the new array object.
     * @returns { BigInt64Array } - a new BigInt64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<long>): BigInt64Array {
        let res = new BigInt64Array(items.length.toInt())
        res.ofLong(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<bigint> } items - a set of elements to include in the new array object.
     * @returns { BigInt64Array } - a new BigInt64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<bigint>): BigInt64Array {
        let res = new BigInt64Array(items.length.toInt())
        res.ofBigInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<number> } items - a set of elements to include in the new array object.
     * @returns { BigInt64Array } - a new BigInt64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<number>): BigInt64Array {
        let res = new BigInt64Array(items.length.toInt())
        res.ofNumber(items)
        return res
    }

    private final native ofInt(items: FixedArray<int>): void
    private final native ofNumber(items: FixedArray<number>): void
    private final native ofLong(items: FixedArray<long>): void
    private final native ofBigInt(items: FixedArray<Object>): void

    /**
     * Returns a new array from a set of elements.
     *
     * @returns { BigInt64Array } - a new BigInt64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(): BigInt64Array {
        return new BigInt64Array(0)
    }

    /**
     * Creates an array from an object of FixedArray<BigInt>.
     *
     * @param { FixedArray<BigInt> } arr - An instance of the FixedArray type to convert to an array.
     * @returns { BigInt64Array } - A new BigInt64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: FixedArray<BigInt>): BigInt64Array {
        let result = new BigInt64Array(arr.length)
        result.ofBigInt(arr)
        return result
    }

    /**
     * Creates an array from a set of type std.core.Set<BigInt>.
     *
     * @param { Set<BigInt> } set - A set object to convert to an array.
     * @returns { BigInt64Array } - A new BigInt64Array
     * @throws { AssertionError } - Input parameter error.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(set: Set<BigInt>): BigInt64Array {
        const length = set.size;
        const result = new BigInt64Array(length)
        let iter = set.$_iterator()
        for (let i:int = 0; i < length; ++i) {
            const x = iter.next()
            if (x.done) {
                throw new AssertionError('Wrong Length')
            }
            result.setUnsafe(i, x.value!.getLong())
        }
        return result
    }

    /**
     * Creates an array from an array of the same type.
     *
     * @param { BigInt64Array } arr - An array to convert to a new array.
     * @returns { BigInt64Array } - A new BigInt64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: BigInt64Array): BigInt64Array {
        let result = new BigInt64Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an object of std.core.Array<BigInt>.
     *
     * @param { Array<BigInt> } arr - An instance of the std.core.Array type to convert to an array.
     * @returns { BigInt64Array } - A new BigInt64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Array<BigInt>): BigInt64Array {
        let result = new BigInt64Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<number> } arrayLike - An array-like or iterable object to convert to an array.
     * @returns { BigInt64Array } - A new BigInt64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: ArrayLike<number>): BigInt64Array {
        throw new Error("BigInt64Array.from: not implemented")
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<T> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } mapfn - A mapping function to call on every element of the array.
     * @returns { BigInt64Array } - A new BigInt64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => BigInt): BigInt64Array {
        let res = new BigInt64Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new FixedArray<int>(1)
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            const mapped = mapfn(x as T, idx[0])
            res.setUnsafe(idx[0], mapped.getLong())
            idx[0]++
        })
        return res
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { Iterable<BigInt> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } [mapfn] - A mapping function to call on every element of the array.
     * @returns { BigInt64Array } - A new BigInt64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: Iterable<BigInt>, mapfn?: (v: BigInt, k: number) => BigInt): BigInt64Array {
        if (mapfn == undefined) {
            mapfn = (v: BigInt, k: number): BigInt => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE (templin.konstantin): This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new BigInt64Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new BigInt64Array(result.buffer, 0, i)
                }
                const mapped = (mapfn)!(x.value!, i)
                result.setUnsafe(i, mapped.getLong())
            }
            return result
        }

        // NOTE (templin.konstantin): Create builtin array as buffer
        let temp = new BigInt64Array(6)
        let index : FixedArray<int> = new FixedArray<int>(1)
        index[0] = 0

        iteratorForEach<BigInt>(iter, (x: BigInt): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE (templin.konstantin): Progressive reallocation
                const curLength = temp.buffer.getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, temp.buffer.at(i))
                }
                temp = new BigInt64Array(tb)
            }
            const mapped = (mapfn)!(x, index[0])
            temp.setUnsafe(index[0], mapped.getLong())
            index[0]++
        })
        return new BigInt64Array(temp.buffer, 0, index[0])
    }

    /**
     * Determines whether BigInt64Array includes a certain element, returning true or false as appropriate
     *
     * @param { long } searchElement - The element to search for
     * @param { int } fromIndex - The position in this array at which to begin searching for searchElement
     * @returns { boolean } - true if searchElement is in BigInt64Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: long, fromIndex: int): boolean {
        return this.indexOf(searchElement.toInt(), fromIndex) != -1
    }

    /**
     * Determines whether BigInt64Array includes a certain element, returning true or false as appropriate
     *
     * @param { long } searchElement - The element to search for. The search starts at index 0.
     * @returns { boolean } - true if searchElement is in BigInt64Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: long): boolean {
        return this.includes(searchElement, 0)
    }

    /**
     * Determines whether BigInt64Array includes a certain element, returning true or false as appropriate
     *
     * @param { BigInt } searchElement - The element to search for
     * @param { int } [fromIndex] - The position in this array at which to begin searching for searchElement.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { boolean } - true if searchElement is in BigInt64Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: BigInt, fromIndex?: int): boolean {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in BigInt64Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int): int {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in BigInt64Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int, fromIndex: int): int {
        return this.indexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the first occurrence of a value in BigInt64Array.
     *
     * @param { BigInt } searchElement - The value to locate in the array.
     * @param { int } [fromIndex] - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: BigInt, fromIndex?: int): int {
            return this.indexOfImpl(searchElement.getLong(), fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in BigInt64Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns {int} - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in BigInt64Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Converts all elements of an array to strings and joins them using the specified separator.
     *
     * @param { String } separator - separates one element of an array from the next in the resulting String.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native joinInternal(separator: String): string;

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param { String } [separator] - A string used to separate one element of an array from the next in the
     *     resulting String. If omitted, the array elements are separated with a comma.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.joinInternal(",")
        }
        return this.joinInternal(separator)
    }

    /**
     * Returns an list of keys in BigInt64Array
     *
     * @returns { IterableIterator<int> } - iterator over keys
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public keys(): IterableIterator<int> {
        return new BigInt64ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in BigInt64Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in BigInt64Array.
     *
     * @param { BigInt } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: BigInt): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in BigInt64Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int, fromIndex: int): int {
        return this.lastIndexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the last occurrence of a value in BigInt64Array.
     *
     * @param { BigInt } searchElement - The value to locate in the array.
     * @param { int | undefined } fromIndex - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: BigInt, fromIndex: int | undefined): int {
            return this.lastIndexOfImpl(searchElement.getLong(), fromIndex ?? 0)
    }

    /**
     * Returns the index of the last occurrence of a value in BigInt64Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the last occurrence of a value in BigInt64Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Creates a new BigInt64Array using initializer
     *
     * @param { FixedArray<Object> } data - initializer
     * @returns { BigInt64Array } - a new BigInt64Array
     * @throws { Error } - function not implemented
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public of(data: FixedArray<Object>): BigInt64Array {
        throw new Error("BigInt64Array.of: not implemented")
    }

    /**
     * Creates a new BigInt64Array using reversed data from the current one
     *
     * @returns { BigInt64Array } - a new BigInt64Array using reversed data from the current one
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native reverse(): BigInt64Array

    /**
     * Creates a slice of current BigInt64Array using range [begin, this.length).
     *
     * @param { int } begin - start index to be taken into slice
     * @returns { BigInt64Array } - a new BigInt64Array with elements of current BigInt64Array[begin, this.length)
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin: int): BigInt64Array {
        return this.sliceFromTo(begin, this.lengthInt)
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, end)
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sliceFromTo}
     *
     * @param { int } [begin] - start index to be taken into slice
     * @param { int } [end] - last index to be taken into slice
     * @returns { BigInt64Array } - a new BigInt64Array with elements of current BigInt64Array[begin;end),
     *     where end index is excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin?: int, end?: int): BigInt64Array {
        return this.sliceFromTo(begin ?? 0, end ?? this.lengthInt)
    }

    private sliceFromTo(begin: int, end: int): BigInt64Array {
        const relStart: int = normalizeIndex(begin, this.lengthInt)
        const relEnd: int = normalizeIndex(end, this.lengthInt)
        let buf: ArrayBuffer = this.buffer.slice(relStart * this.BYTES_PER_ELEMENT + this.byteOffset, relEnd * this.BYTES_PER_ELEMENT + this.byteOffset)
        return new BigInt64Array(buf)
    }


    /**
     * Creates a BigInt64Array with the same underlying ArrayBuffer
     *
     * @param { int } [begin] - start index, inclusive
     * @param { int } [end] - last index, exclusive
     * @returns { BigInt64Array } - a new BigInt64Array with the same underlying ArrayBuffer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public subarray(begin?: int, end?: int): BigInt64Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin ?? 0, len)
        const relEnd = normalizeIndex(end ?? this.lengthInt, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new BigInt64Array(this.buffer, relStart * BigInt64Array.BYTES_PER_ELEMENT + this.byteOffset, count)
    }

    /**
     * Converts BigInt64Array to a string with respect to locale
     *
     * @returns { string } - string representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(new BigInt(this.getUnsafe(i)).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append(new BigInt(this.getUnsafe(this.lengthInt - 1)).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns { BigInt64Array } - a reversed copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toReversed(): BigInt64Array {
        let newArray = new BigInt64Array(this.lengthInt);
        if (this.lengthInt > 0) {
            BigInt64Array.reverseCopyBuffer(newArray.buffer, this.buffer, this.byteOffset, this.lengthInt);
        }
        return newArray
    }

    /**
     * Creates a sorted copy
     *
     * @returns { BigInt64Array } - a sorted copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toSorted(): BigInt64Array {
        return new BigInt64Array(this).sort()
    }

    /**
     * Returns a string representation of the BigInt64Array
     *
     * @returns { string } - a string representation of the BigInt64Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns { IterableIterator<BigInt> } - an iterator
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public values(): IterableIterator<BigInt> {
        return new BigInt64ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns { IterableIterator<BigInt> } - iterator over all elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override $_iterator(): IterableIterator<BigInt> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param { int } index - index to change
     * @param { long } value - value to set
     * @returns { BigInt64Array } - an BigInt64Array with replaced value on index
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: long): BigInt64Array {
        let res = new BigInt64Array(this)
        res.set(index, value)
        return res
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param { int } index - index to change
     * @param { BigInt } value - value to set
     * @returns { BigInt64Array } - an BigInt64Array with replaced value on index
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: BigInt): BigInt64Array {
        let res = new BigInt64Array(this)
        res.set(index, value.getLong())
        return res
    }

    /// === with element lambda functions ===

    /**
     * Finds the last element in the BigInt64Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { BigInt } - the last element that satisfies fn
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: BigInt) => boolean): BigInt {
        let newF: (val: BigInt, index: int, array: BigInt64Array) => boolean =
            (val: BigInt, index: int, array: BigInt64Array): boolean => { return fn(val) }
        return new BigInt(this.findLast(newF))
    }

    /**
     * Sorts in-place by numeric value in ascending order.
     *
     * @returns { this } - sorted BigInt64Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native sort(): this;

    /**
     * Sorts in-place
     *
     * @param { function } [compareFn] - comparator _  used to determine the order of the elements.
     *     compareFn returns a negative value if first argument is less than second argument,
     *     zero if they're equal and a positive value otherwise.
     * @returns { this } - sorted BigInt64Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public sort(compareFn?: (a: BigInt, b: BigInt) => int | BigInt): this {
        if (compareFn == undefined) {
            this.sort()
            return this
        }

        let cmp = (l: long, r: long): int => {
            const result = compareFn!(new BigInt(l), new BigInt(r))
            if (result instanceof BigInt) {
                return result.getLong().toInt()
            } else {
                return result.toInt()
            }
        }

        const MAX_SHORT_LENGTH = 24

        if (this.lengthInt > MAX_SHORT_LENGTH) {
            let arr: FixedArray<long> = new FixedArray<long>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                arr[i] = this.getUnsafe(i)
            }
            const arrLength = this.lengthInt

            arr = mergeSort(arr, cmp, 0, arrLength)

            for (let i = 0; i < arr.length; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let buffer: FixedArray<Long> = new FixedArray<Long>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                buffer[i] = this.getUnsafe(i)
            }
            const arrLength = this.lengthInt

            arr_sort_stable(buffer, 0, arrLength, cmp)
            for (let i = 0; i < buffer.length; ++i) {
                this.setUnsafe(i, buffer[i].toLong())
            }
        }
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The some method calls the predicate function for each element in the array
     *     until the predicate returns a true or until the end of the array.
     * @returns { boolean } - false unless predicate function returns true for an array element,
     *     in which case true is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public some(predicate: (element: BigInt, index: int, array: BigInt64Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(new BigInt(this.getUnsafe(i)), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     *     The first call to the callbackfn function provides this value as an argument.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce<U = BigInt>(
                callbackfn: (previousValue: U, currentValue: BigInt, currentIndex: int, array: BigInt64Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array first element value as an argument
     * @returns { BigInt } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the BigInt64Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce(callbackfn: (previousValue: BigInt, currentValue: BigInt, currentIndex: int, array: BigInt64Array) => BigInt): BigInt {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = new BigInt(this.getUnsafe(0))
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight<U = BigInt>(
                callbackfn: (previousValue: U, currentValue: BigInt, currentIndex: int, array: BigInt64Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i, this)
        }
        return accumulatedValue
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array last element value as an argument.
     * @returns { BigInt } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the BigInt64Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight(callbackfn: (previousValue: BigInt, currentValue: BigInt, currentIndex: int, array: BigInt64Array) => BigInt): BigInt {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: BigInt = new BigInt(this.getUnsafe(this.lengthInt - 1))
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i, this)
        }
        return accumulatedValue
    }

    /**
     * Creates a new BigInt64Array using fn(arr[i]) over all elements of current BigInt64Array.
     *
     * @param { function } fn - a function to apply for each element of current BigInt64Array
     * @returns { BigInt64Array } - a new BigInt64Array where for each element from current BigInt64Array fn was applied
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public map(fn: (val: BigInt, index: int, array: BigInt64Array) => BigInt): BigInt64Array {
        let resBuf = new ArrayBuffer(this.lengthInt * BigInt64Array.BYTES_PER_ELEMENT)
        let res = new BigInt64Array(resBuf, 0, (resBuf.getByteLength() / BigInt64Array.BYTES_PER_ELEMENT).toInt())
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn(new BigInt(this.getUnsafe(i)), i, this).getLong())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The every method calls the predicate function for each element in the array until the predicate
     *     returns a false, or until the end of the array.
     * @returns { boolean } - true unless predicate function returns a false for an array element,
     *     in which case false is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public every(predicate: (element: BigInt, index: int, array: BigInt64Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate(new BigInt(this.getUnsafe(i)), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Creates a new BigInt64Array from current BigInt64Array based on a condition fn.
     *
     * @param { function } fn - the condition to apply for each element
     * @returns { BigInt64Array } - a new BigInt64Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public filter(fn: (val: BigInt, index: int, array: BigInt64Array) => boolean): BigInt64Array {
        let markers : FixedArray<boolean> = new FixedArray<boolean>(this.lengthInt)
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn(new BigInt(this.getUnsafe(i)), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * BigInt64Array.BYTES_PER_ELEMENT)
        let res = new BigInt64Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found, find
     *     immediately returns that element value. Otherwise, find returns undefined
     * @returns { BigInt | undefined }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public find(predicate: (value: BigInt, index: int, obj: BigInt64Array) => boolean): BigInt | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate(new BigInt(val), i, this)) {
                return new BigInt(val)
            }
        }
        return undefined
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1 otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found,
     *     findIndex immediately returns that element index. Otherwise, findIndex returns -1
     * @returns { int } - Index of the first matched element
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findIndex(predicate: (value: BigInt, index: int, obj: BigInt64Array) => boolean): int {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(new BigInt(this.getUnsafe(i)), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds the last element in the BigInt64Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { long } - the last element that satisfies fn
     * @throws { Error } - If the element cannot be found, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: BigInt, index: int, array: BigInt64Array) => boolean): long {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(new BigInt(val), i, this)) {
                return val
            }
        }
        throw new Error("BigInt64Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds an index of the last element in the BigInt64Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { int } - the index of the last element that satisfies fn, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLastIndex(fn: (val: BigInt, index: int, array: BigInt64Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(new BigInt(val), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Performs the specified action for each element in BigInt64Array
     *
     * @param { function } callbackfn - A function that accepts up to three arguments. forEach calls the
     *     callbackfn function one time for each element in the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public forEach(callbackfn: (value: BigInt, index: int, array: BigInt64Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn(new BigInt(this.getUnsafe(i)), i, this)
        }
    }

    /**
     * Returns the object itself
     *
     * @returns { BigInt64Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public valueOf(): BigInt64Array {
        return this
    }

    private static native reverseCopyBuffer(dstBuf: ArrayBuffer, srcBuf: ArrayBuffer, startPos: int, length: int): void

    private final native getUnsafe(index: int): long

    private setUnsafe(insertPos: int, val: long): void {
        const BPE = BigInt64Array.BYTES_PER_ELEMENT.toInt()
        let byteIndex = insertPos * BPE + this.byteOffset
        let buf = this.buffer
        let bits = val
        if (IS_LITTLE_ENDIAN) {
            for (let i = 0; i < BPE; ++i) {
                let byteVal = ((bits >>> (i * 8)) & 0xff).toByte()
                buf.set(byteIndex++, byteVal)
            }
        } else {
            byteIndex = byteIndex + BPE - 1
            for (let i = 0; i < BPE; ++i) {
                let byteVal = ((bits >>> (i * 8)) & 0xff).toByte()
                buf.set(byteIndex--, byteVal)
            }
        }
        
    }

    /**
     * Underlying ArrayBuffer
     *
     * @type { ArrayBuffer }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly buffer: ArrayBuffer

    /**
     * Byte offset within the underlying ArrayBuffer
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteOffset: int

    /**
     * Number of bytes used
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteLength: int

    /**
     * String \"BigInt64Array\"
     *
     * @type { string }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly name = "BigInt64Array"
}

class Float32ArrayIteratorKeys implements IterableIterator<int> {
    private length: int
    private idx: int = 0

    constructor(parent: Float32Array) {
        this.length = parent.length
    }

    public override $_iterator(): IterableIterator<int> {
        return this
    }

    override next(): IteratorResult<int> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(false, this.idx++)
    }
}

class Float32ArrayIterator implements IterableIterator<Number> {
    private parent: Float32Array
    private idx: int = 0

    constructor(parent: Float32Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Float32ArrayIteratorEntries implements IterableIterator<[int, Number]> {
    private parent: Float32Array
    private idx: int = 0

    constructor(parent: Float32Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[int, Number]> {
        return this
    }

    override next(): IteratorResult<[int, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<[int, Number]>()
        }
        return new IteratorResult<[int, Number]>(
            false, [this.idx, new Number(this.parent[this.idx++])]
        )
    }
}


/**
 * Defines Float32Array
 *
 * @implements { Iterable<Number>, ArrayLike<Number> }
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export final class Float32Array implements Iterable<Number>, ArrayLike<Number> {
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static readonly BYTES_PER_ELEMENT: int = 4
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly BYTES_PER_ELEMENT: int = Float32Array.BYTES_PER_ELEMENT
    protected readonly lengthInt: int

    /**
     * Creates an empty Float32Array.
     *
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor() {
        this(0)
    }

    /**
     * Creates an Float32Array with respect to length.
     *
     * @param { int } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: int) {
        this(length.toDouble())
    }

    /**
     * Creates an Float32Array with respect to length.
     *
     * @param { number } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: number) {
        if (length < 0 || length > (Int.MAX_VALUE / Float32Array.BYTES_PER_ELEMENT).toInt()) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length.toInt()
        this.byteLength = this.lengthInt * Float32Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates a copy of Float32Array.
     *
     * @param { Float32Array } other - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(other: Float32Array) {
        this.buffer = other.buffer.slice(other.byteOffset, other.byteOffset + other.byteLength) as ArrayBuffer
        this.byteLength = other.byteLength
        this.lengthInt = other.length
        this.byteOffset = 0
    }

    /**
     * Creates an Float32Array from FixedArray<int>
     *
     * @param { FixedArray<int> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].toFloat())
        }
    }

    /**
     * Creates an Float32Array from FixedArray<number>
     *
     * @param { FixedArray<number> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<number>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].toFloat())
        }
    }

    /**
     * Creates an Float32Array with respect to data accessed via Iterable<Number> interface
     *
     * @param { Iterable<Number> } elements - an iterable object
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(elements: Iterable<Number>) {
        const items: Object = elements as Object
        if (items instanceof ArrayLike) {
            const arr = reflect.internals.Types.identity_cast<Number>(items as ArrayLike<Number>)
            this.byteLength = arr.length * Float32Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr[i].toFloat())
            }
        } else {
            let x = Float32Array.from(elements)
            this.byteLength = x.byteLength
            this.lengthInt = x.lengthInt
            this.buffer = x.buffer
            this.byteOffset = x.byteOffset
        }
    }

    /**
     * Creates an Float32Array with respect to buf and byteOffset.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Float32Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { number } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Float32Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @param { int } length - size of elements of type float in newly created Float32Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Float32Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { Number | undefined } byteOffset - byte offset from begin of the buf
     * @param { Number | undefined } length - size of elements of type float in newly created Float32Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.toInt()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int = buf.getByteLength() - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteOffset % Float32Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 4 as Float32Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.toInt()
            if (intLength > (intByteLength / Float32Array.BYTES_PER_ELEMENT).toInt()) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = (intByteLength / Float32Array.BYTES_PER_ELEMENT).toInt()
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < (intByteLength / Float32Array.BYTES_PER_ELEMENT).toInt()) {
            intByteLength = intLength * Float32Array.BYTES_PER_ELEMENT
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Float32Array with respect to buf.
     *
     * @param { ArrayLike<Number> | ArrayBuffer } buf - data initializer
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayLike<Number> | ArrayBuffer) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % Float32Array.BYTES_PER_ELEMENT.toInt() != 0) {
               throw new RangeError("ArrayBuffer.byteLength should be multiple of 4 as Float32Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = (this.byteLength / Float32Array.BYTES_PER_ELEMENT).toInt()
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length * Float32Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr[i].toFloat())
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { float } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_set(index: int, val: float): void

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { number } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public $_set(index: int, val: number): void {
        this.$_set(index, val.toFloat())
    }

    /**
     * Number of float stored in Float32Array
     *
     * @returns { int } - the number of elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public get length(): int {
        return this.lengthInt
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param { int } index - index to look at
     * @returns { number } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_get(index: int): number

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param { int } index - index to look at
     * @returns { Number | undefined } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } [end] - last index to end copy from, excluded
     * @returns { Float32Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int, start: int, end?: int): Float32Array {
        let arrayLength: int = this.lengthInt;
        target = normalizeIndex(target, arrayLength);
        start = normalizeIndex(start, arrayLength);
        end = normalizeIndex(asIntOrDefault(end, arrayLength), arrayLength);
        let count: int = end - start;
        if (count > (arrayLength - target)) {
            count = arrayLength - target;
        }
        if (count <= 0) {
            return this;
        }

        this.copyWithinImpl(target, start, count)
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } end - last index to end copy from, excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private native copyWithinImpl(target: int, start: int, end: int): void

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Float32Array.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @returns { Float32Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int): Float32Array {
        this.copyWithinImpl(target, 0, this.lengthInt)
        return this
    }

    /**
     * Returns an array of key, value pairs for every entry in the Float32Array
     *
     * @returns { IterableIterator<[int, Number]> } - key, value pairs for every entry in the array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public entries(): IterableIterator<[int, Number]> {
        return new Float32ArrayIteratorEntries(this)
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param { float } value - new value
     * @param { int } [start] - start index to begin fill from
     * @param { int } [end] - last index to end fill from, excluded
     * @returns { this } - modified Float32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: float, start?: int, end?: int): this {
        const k = normalizeIndex(start ?? 0, this.lengthInt)
        const finalPos = normalizeIndex(end ?? this.lengthInt, this.lengthInt)
        this.fillInternal(value, k, finalPos)
        return this
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param { number } value - new value
     * @param { int } [start] - start index to begin fill from
     * @param { int } [end] - last index to end fill from, excluded
     * @returns { this } - modified Float32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: number, start?: int, end?: int): this {
        this.fill(value.toFloat(), start, end)
        return this
    }

    private final native fillInternal(value: float, start: int, end: int): void

    /**
     * Assigns val as element on insertPos.
     *
     * @param { int } insertPos - index to change
     * @param { float } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(insertPos: int, val: float): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on insertPos.
     *
     * @param { int } insertPos - index to change
     * @param { number } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(insertPos: int, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Float32Array.
     *
     * @param { FixedArray<float> } arr - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<float>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Float32Array starting from insertPos.
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     *
     * @param { FixedArray<float> } arr - array to copy data from
     * @param { int } insertPos - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<float>, insertPos: int): void {
        const offset = insertPos
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.setUnsafe(offset + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Float32Array.
     *
     * @param { FixedArray<number> } arr - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<number>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Float32Array starting from insertPos.
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     *
     * @param { FixedArray<number> } arr - array to copy data from
     * @param { int } insertPos - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<number>, insertPos: int): void {
        const offset = insertPos
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.setUnsafe(offset + i, arr[i].toFloat())
        }
    }

    private native final set(array: Array<number>): void;

    /**
     * Copies all elements of array to the current Float32Array.
     *
     * @param { Float32Array } array - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: Float32Array): void

    /**
     * Copies all elements of arr to the current Float32Array starting from offset.
     *
     * @param { Float32Array } array - array to copy data from
     * @param { int } offset - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: Float32Array, offset: int): void

    /**
     * Copies elements from an ArrayLike object to the Float32Array.
     *
     * @param { ArrayLike<number> } array - An ArrayLike object containing the elements to copy.
     * @param { int } [offset] - Optional. The offset into the target array at which to begin
     *     writing values from the source array. The default value is 0.
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(array: ArrayLike<number>, offset: int = 0): void {
        const insertPos = offset
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; ++i) {
            this.setUnsafe(insertPos + i, array[i].toFloat())
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<int> } items - a set of elements to include in the new array object.
     * @returns { Float32Array } - a new Float32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<int>): Float32Array {
        let res = new Float32Array(items.length.toInt())
        res.ofInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<float> } items - a set of elements to include in the new array object.
     * @returns { Float32Array } - a new Float32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<float>): Float32Array {
        let res = new Float32Array(items.length.toInt())
        res.ofFloat(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<number> } items - a set of elements to include in the new array object.
     * @returns { Float32Array } - a new Float32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<number>): Float32Array {
        let res = new Float32Array(items.length.toInt())
        res.ofNumber(items)
        return res
    }

    private final native ofInt(items: FixedArray<int>): void
    private final native ofNumber(items: FixedArray<number>): void
    private final native ofFloat(items: FixedArray<float>): void

    /**
     * Returns a new array from a set of elements.
     *
     * @returns { Float32Array } - a new Float32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(): Float32Array {
        return new Float32Array(0)
    }

    /**
     * Creates an array from an object of FixedArray<number>.
     *
     * @param { FixedArray<number> } arr - An instance of the FixedArray type to convert to an array.
     * @returns { Float32Array } - A new Float32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: FixedArray<number>): Float32Array {
        let result = new Float32Array(arr.length)
        result.ofNumber(arr)
        return result
    }

    /**
     * Creates an array from a set of type std.core.Set<number>.
     *
     * @param { Set<number> } set - A set object to convert to an array.
     * @returns { Float32Array } - A new Float32Array
     * @throws { AssertionError } - Input parameter error.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(set: Set<number>): Float32Array {
        const length = set.size;
        const result = new Float32Array(length)
        let iter = set.$_iterator()
        for (let i:int = 0; i < length; ++i) {
            const x = iter.next()
            if (x.done) {
                throw new AssertionError('Wrong Length')
            }
            result.setUnsafe(i, x.value!.toFloat())
        }
        return result
    }

    /**
     * Creates an array from an array of the same type.
     *
     * @param { Float32Array } arr - An array to convert to a new array.
     * @returns { Float32Array } - A new Float32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Float32Array): Float32Array {
        let result = new Float32Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an object of std.core.Array<number>.
     *
     * @param { Array<number> } arr - An instance of the std.core.Array type to convert to an array.
     * @returns { Float32Array } - A new Float32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Array<number>): Float32Array {
        let result = new Float32Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<number> } arrayLike - An array-like or iterable object to convert to an array.
     * @returns { Float32Array } - A new Float32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: ArrayLike<number>): Float32Array {
        return Float32Array.from<number>(arrayLike, (x: number, k: number): number => x)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<T> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } mapfn - A mapping function to call on every element of the array.
     * @returns { Float32Array } - A new Float32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number): Float32Array {
        let res = new Float32Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new FixedArray<int>(1)
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            const mapped = mapfn(x as T, idx[0])
            res.setUnsafe(idx[0], mapped.toFloat())
            idx[0]++
        })
        return res
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { Iterable<number> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } [mapfn] - A mapping function to call on every element of the array.
     * @returns { Float32Array } - A new Float32Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Float32Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE (templin.konstantin): This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Float32Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Float32Array(result.buffer, 0, i)
                }
                const mapped = (mapfn)!(x.value!, i)
                result.setUnsafe(i, mapped.toFloat())
            }
            return result
        }

        // NOTE (templin.konstantin): Create builtin array as buffer
        let temp = new Float32Array(6)
        let index : FixedArray<int> = new FixedArray<int>(1)
        index[0] = 0

        iteratorForEach<number>(iter, (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE (templin.konstantin): Progressive reallocation
                const curLength = temp.buffer.getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, temp.buffer.at(i))
                }
                temp = new Float32Array(tb)
            }
            const mapped = (mapfn)!(x, index[0])
            temp.setUnsafe(index[0], mapped.toFloat())
            index[0]++
        })
        return new Float32Array(temp.buffer, 0, index[0])
    }
    private final native containsNaN(fromIndex: int): boolean;

    /**
     * Determines whether Float32Array includes a certain element, returning true or false as appropriate
     *
     * @param { float } searchElement - The element to search for
     * @param { int } fromIndex - The position in this array at which to begin searching for searchElement
     * @returns { boolean } - true if searchElement is in Float32Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: float, fromIndex: int): boolean {
        return this.indexOf(searchElement.toInt(), fromIndex) != -1
    }

    /**
     * Determines whether Float32Array includes a certain element, returning true or false as appropriate
     *
     * @param { float } searchElement - The element to search for. The search starts at index 0.
     * @returns { boolean } - true if searchElement is in Float32Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: float): boolean {
        return this.includes(searchElement, 0)
    }

    /**
     * Determines whether Float32Array includes a certain element, returning true or false as appropriate
     *
     * @param { number } searchElement - The element to search for
     * @param { int } [fromIndex] - The position in this array at which to begin searching for searchElement.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { boolean } - true if searchElement is in Float32Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: number, fromIndex?: int): boolean {
        if (isNaN(searchElement)) {
            return this.containsNaN(asIntOrDefault(fromIndex, 0))
        }
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in Float32Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int): int {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Float32Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int, fromIndex: int): int {
        return this.indexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the first occurrence of a value in Float32Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } [fromIndex] - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: number, fromIndex?: int): int {
            return this.indexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Float32Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns {int} - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Float32Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Converts all elements of an array to strings and joins them using the specified separator.
     *
     * @param { String } separator - separates one element of an array from the next in the resulting String.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native joinInternal(separator: String): string;

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param { String } [separator] - A string used to separate one element of an array from the next in the
     *     resulting String. If omitted, the array elements are separated with a comma.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.joinInternal(",")
        }
        return this.joinInternal(separator)
    }

    /**
     * Returns an list of keys in Float32Array
     *
     * @returns { IterableIterator<int> } - iterator over keys
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public keys(): IterableIterator<int> {
        return new Float32ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Float32Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Float32Array.
     *
     * @param { number } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: number): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Float32Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int, fromIndex: int): int {
        return this.lastIndexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the last occurrence of a value in Float32Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int | undefined } fromIndex - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: number, fromIndex: int | undefined): int {
            return this.lastIndexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the last occurrence of a value in Float32Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the last occurrence of a value in Float32Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Creates a new Float32Array using initializer
     *
     * @param { FixedArray<Object> } data - initializer
     * @returns { Float32Array } - a new Float32Array
     * @throws { Error } - function not implemented
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public of(data: FixedArray<Object>): Float32Array {
        throw new Error("Float32Array.of: not implemented")
    }

    /**
     * Creates a new Float32Array using reversed data from the current one
     *
     * @returns { Float32Array } - a new Float32Array using reversed data from the current one
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native reverse(): Float32Array

    /**
     * Creates a slice of current Float32Array using range [begin, this.length).
     *
     * @param { int } begin - start index to be taken into slice
     * @returns { Float32Array } - a new Float32Array with elements of current Float32Array[begin, this.length)
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin: int): Float32Array {
        return this.sliceFromTo(begin, this.lengthInt)
    }

    /**
     * Creates a slice of current Float32Array using range [begin, end)
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sliceFromTo}
     *
     * @param { int } [begin] - start index to be taken into slice
     * @param { int } [end] - last index to be taken into slice
     * @returns { Float32Array } - a new Float32Array with elements of current Float32Array[begin;end),
     *     where end index is excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin?: int, end?: int): Float32Array {
        return this.sliceFromTo(begin ?? 0, end ?? this.lengthInt)
    }

    private sliceFromTo(begin: int, end: int): Float32Array {
        const relStart: int = normalizeIndex(begin, this.lengthInt)
        const relEnd: int = normalizeIndex(end, this.lengthInt)
        let buf: ArrayBuffer = this.buffer.slice(relStart * this.BYTES_PER_ELEMENT + this.byteOffset, relEnd * this.BYTES_PER_ELEMENT + this.byteOffset)
        return new Float32Array(buf)
    }


    /**
     * Creates a Float32Array with the same underlying ArrayBuffer
     *
     * @param { int } [begin] - start index, inclusive
     * @param { int } [end] - last index, exclusive
     * @returns { Float32Array } - a new Float32Array with the same underlying ArrayBuffer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public subarray(begin?: int, end?: int): Float32Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin ?? 0, len)
        const relEnd = normalizeIndex(end ?? this.lengthInt, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Float32Array(this.buffer, relStart * Float32Array.BYTES_PER_ELEMENT + this.byteOffset, count)
    }

    /**
     * Converts Float32Array to a string with respect to locale
     *
     * @returns { string } - string representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(new Number(this.getUnsafe(i)).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append(new Number(this.getUnsafe(this.lengthInt - 1))).toLocaleString()
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns { Float32Array } - a reversed copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toReversed(): Float32Array {
        let newArray = new Float32Array(this.lengthInt);
        if (this.lengthInt > 0) {
            Float32Array.reverseCopyBuffer(newArray.buffer, this.buffer, this.byteOffset, this.lengthInt);
        }
        return newArray
    }

    /**
     * Creates a sorted copy
     *
     * @returns { Float32Array } - a sorted copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toSorted(): Float32Array {
        return new Float32Array(this).sort()
    }

    /**
     * Returns a string representation of the Float32Array
     *
     * @returns { string } - a string representation of the Float32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns { IterableIterator<Number> } - an iterator
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public values(): IterableIterator<Number> {
        return new Float32ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns { IterableIterator<Number> } - iterator over all elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override $_iterator(): IterableIterator<Number> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param { int } index - index to change
     * @param { float } value - value to set
     * @returns { Float32Array } - an Float32Array with replaced value on index
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: float): Float32Array {
        let res = new Float32Array(this)
        res.set(index, value)
        return res
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param { int } index - index to change
     * @param { number } value - value to set
     * @returns { Float32Array } - an Float32Array with replaced value on index
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: number): Float32Array {
        let res = new Float32Array(this)
        res.set(index, value.toFloat())
        return res
    }

    /// === with element lambda functions ===

    /**
     * Finds the last element in the Float32Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { number } - the last element that satisfies fn
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Float32Array) => boolean =
            (val: number, index: int, array: Float32Array): boolean => { return fn(val) }
        return (this.findLast(newF)).toDouble()
    }

    /**
     * Sorts in-place by numeric value in ascending order.
     *
     * @returns { this } - sorted Float32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native sort(): this;

    /**
     * Sorts in-place
     *
     * @param { function } [compareFn] - comparator _  used to determine the order of the elements.
     *     compareFn returns a negative value if first argument is less than second argument,
     *     zero if they're equal and a positive value otherwise.
     * @returns { this } - sorted Float32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public sort(compareFn?: (a: number, b: number) => int): this {
        if (compareFn == undefined) {
            this.sort()
            return this
        }

        let cmp = (l: float, r: float): int => {
            const result = compareFn!((l).toDouble(), (r).toDouble())
            return result.toInt()
        }

        const MAX_SHORT_LENGTH = 24
        let naNCounter = 0

        if (this.lengthInt > MAX_SHORT_LENGTH) {
            let arr: FixedArray<float> = new FixedArray<float>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                let val = this.getUnsafe(i)
                if (isNaN(val)) {
                    naNCounter++
                } else {
                    arr[i - naNCounter] = val
                }
            }
            for (let i = 0; i < naNCounter; ++i) {
                arr[this.lengthInt - 1 - i] = NaN.toFloat()
            }
            const arrLength = this.lengthInt - naNCounter

            arr = mergeSort(arr, cmp, 0, arrLength)

            for (let i = 0; i < arr.length; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let buffer: FixedArray<Float> = new FixedArray<Float>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                let val = this.getUnsafe(i)
                if (isNaN(val)) {
                    naNCounter++
                } else {
                    buffer[i - naNCounter] = val
                }
            }
            for (let i = 0; i < naNCounter; ++i) {
                buffer[this.lengthInt - 1 - i] = NaN.toFloat()
            }
            const arrLength = this.lengthInt - naNCounter

            arr_sort_stable(buffer, 0, arrLength, cmp)
            for (let i = 0; i < buffer.length; ++i) {
                this.setUnsafe(i, buffer[i].toFloat())
            }
        }
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The some method calls the predicate function for each element in the array
     *     until the predicate returns a true or until the end of the array.
     * @returns { boolean } - false unless predicate function returns true for an array element,
     *     in which case true is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public some(predicate: (element: number, index: int, array: Float32Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     *     The first call to the callbackfn function provides this value as an argument.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Float32Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array first element value as an argument
     * @returns { number } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the Float32Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Float32Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = (this.getUnsafe(0)).toDouble()
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Float32Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array last element value as an argument.
     * @returns { number } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the Float32Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Float32Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = (this.getUnsafe(this.lengthInt - 1)).toDouble()
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Creates a new Float32Array using fn(arr[i]) over all elements of current Float32Array.
     *
     * @param { function } fn - a function to apply for each element of current Float32Array
     * @returns { Float32Array } - a new Float32Array where for each element from current Float32Array fn was applied
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public map(fn: (val: number, index: int, array: Float32Array) => number): Float32Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Float32Array.BYTES_PER_ELEMENT)
        let res = new Float32Array(resBuf, 0, (resBuf.getByteLength() / Float32Array.BYTES_PER_ELEMENT).toInt())
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn((this.getUnsafe(i)).toDouble(), i, this).toFloat())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The every method calls the predicate function for each element in the array until the predicate
     *     returns a false, or until the end of the array.
     * @returns { boolean } - true unless predicate function returns a false for an array element,
     *     in which case false is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public every(predicate: (element: number, index: int, array: Float32Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Creates a new Float32Array from current Float32Array based on a condition fn.
     *
     * @param { function } fn - the condition to apply for each element
     * @returns { Float32Array } - a new Float32Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public filter(fn: (val: number, index: int, array: Float32Array) => boolean): Float32Array {
        let markers : FixedArray<boolean> = new FixedArray<boolean>(this.lengthInt)
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn((this.getUnsafe(i)).toDouble(), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Float32Array.BYTES_PER_ELEMENT)
        let res = new Float32Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found, find
     *     immediately returns that element value. Otherwise, find returns undefined
     * @returns { number | undefined }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public find(predicate: (value: number, index: int, obj: Float32Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate((val).toDouble(), i, this)) {
                return (val).toDouble()
            }
        }
        return undefined
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1 otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found,
     *     findIndex immediately returns that element index. Otherwise, findIndex returns -1
     * @returns { int } - Index of the first matched element
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findIndex(predicate: (value: number, index: int, obj: Float32Array) => boolean): int {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds the last element in the Float32Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { float } - the last element that satisfies fn
     * @throws { Error } - If the element cannot be found, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: number, index: int, array: Float32Array) => boolean): float {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn((val).toDouble(), i, this)) {
                return val
            }
        }
        throw new Error("Float32Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds an index of the last element in the Float32Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { int } - the index of the last element that satisfies fn, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLastIndex(fn: (val: number, index: int, array: Float32Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn((val).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Performs the specified action for each element in Float32Array
     *
     * @param { function } callbackfn - A function that accepts up to three arguments. forEach calls the
     *     callbackfn function one time for each element in the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public forEach(callbackfn: (value: number, index: int, array: Float32Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn((this.getUnsafe(i)).toDouble(), i, this)
        }
    }

    /**
     * Returns the object itself
     *
     * @returns { Float32Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public valueOf(): Float32Array {
        return this
    }

    private static native reverseCopyBuffer(dstBuf: ArrayBuffer, srcBuf: ArrayBuffer, startPos: int, length: int): void

    private final native getUnsafe(index: int): float

    private setUnsafe(insertPos: int, val: float): void {
        const BPE = Float32Array.BYTES_PER_ELEMENT.toInt()
        let byteIndex = insertPos * BPE + this.byteOffset
        let buf = this.buffer
        let bits = Float.bitCastToInt(val)
        if (IS_LITTLE_ENDIAN) {
            for (let i = 0; i < BPE; ++i) {
                let byteVal = ((bits >>> (i * 8)) & 0xff).toByte()
                buf.set(byteIndex++, byteVal)
            }
        } else {
            byteIndex = byteIndex + BPE - 1
            for (let i = 0; i < BPE; ++i) {
                let byteVal = ((bits >>> (i * 8)) & 0xff).toByte()
                buf.set(byteIndex--, byteVal)
            }
        }
        
    }

    /**
     * Underlying ArrayBuffer
     *
     * @type { ArrayBuffer }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly buffer: ArrayBuffer

    /**
     * Byte offset within the underlying ArrayBuffer
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteOffset: int

    /**
     * Number of bytes used
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteLength: int

    /**
     * String \"Float32Array\"
     *
     * @type { string }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly name = "Float32Array"
}

class Float64ArrayIteratorKeys implements IterableIterator<int> {
    private length: int
    private idx: int = 0

    constructor(parent: Float64Array) {
        this.length = parent.length
    }

    public override $_iterator(): IterableIterator<int> {
        return this
    }

    override next(): IteratorResult<int> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(false, this.idx++)
    }
}

class Float64ArrayIterator implements IterableIterator<Number> {
    private parent: Float64Array
    private idx: int = 0

    constructor(parent: Float64Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Float64ArrayIteratorEntries implements IterableIterator<[int, Number]> {
    private parent: Float64Array
    private idx: int = 0

    constructor(parent: Float64Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[int, Number]> {
        return this
    }

    override next(): IteratorResult<[int, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<[int, Number]>()
        }
        return new IteratorResult<[int, Number]>(
            false, [this.idx, new Number(this.parent[this.idx++])]
        )
    }
}


/**
 * Defines Float64Array
 *
 * @implements { Iterable<Number>, ArrayLike<Number> }
 * @syscap SystemCapability.Utils.Lang
 * @FaAndStageModel
 * @since 24
 */
export final class Float64Array implements Iterable<Number>, ArrayLike<Number> {
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static readonly BYTES_PER_ELEMENT: int = 8
    /**
     * Number of bytes occupied by each element
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly BYTES_PER_ELEMENT: int = Float64Array.BYTES_PER_ELEMENT
    protected readonly lengthInt: int

    /**
     * Creates an empty Float64Array.
     *
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor() {
        this(0)
    }

    /**
     * Creates an Float64Array with respect to length.
     *
     * @param { int } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: int) {
        this(length.toDouble())
    }

    /**
     * Creates an Float64Array with respect to length.
     *
     * @param { number } length - Number of elements
     * @throws { RangeError } - If the length is outside the bounds of the buffer, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(length: number) {
        if (length < 0 || length > (Int.MAX_VALUE / Float64Array.BYTES_PER_ELEMENT).toInt()) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length.toInt()
        this.byteLength = this.lengthInt * Float64Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates a copy of Float64Array.
     *
     * @param { Float64Array } other - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(other: Float64Array) {
        this.buffer = other.buffer.slice(other.byteOffset, other.byteOffset + other.byteLength) as ArrayBuffer
        this.byteLength = other.byteLength
        this.lengthInt = other.length
        this.byteOffset = 0
    }

    /**
     * Creates an Float64Array from FixedArray<int>
     *
     * @param { FixedArray<int> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].toDouble())
        }
    }

    /**
     * Creates an Float64Array from FixedArray<number>
     *
     * @param { FixedArray<number> } numbers - data initializer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(numbers: FixedArray<number>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i])
        }
    }

    /**
     * Creates an Float64Array with respect to data accessed via Iterable<Number> interface
     *
     * @param { Iterable<Number> } elements - an iterable object
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(elements: Iterable<Number>) {
        const items: Object = elements as Object
        if (items instanceof ArrayLike) {
            const arr = reflect.internals.Types.identity_cast<Number>(items as ArrayLike<Number>)
            this.byteLength = arr.length * Float64Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let x = Float64Array.from(elements)
            this.byteLength = x.byteLength
            this.lengthInt = x.lengthInt
            this.buffer = x.buffer
            this.byteOffset = x.byteOffset
        }
    }

    /**
     * Creates an Float64Array with respect to buf and byteOffset.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Float64Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { number } byteOffset - byte offset from begin of the buf
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Float64Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { int } byteOffset - byte offset from begin of the buf
     * @param { int } length - size of elements of type double in newly created Float64Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Float64Array with respect to data, byteOffset and length.
     *
     * @param { ArrayBuffer } buf - data initializer
     * @param { Number | undefined } byteOffset - byte offset from begin of the buf
     * @param { Number | undefined } length - size of elements of type double in newly created Float64Array
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayBuffer, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.toInt()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int = buf.getByteLength() - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteOffset % Float64Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 8 as Float64Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.toInt()
            if (intLength > (intByteLength / Float64Array.BYTES_PER_ELEMENT).toInt()) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = (intByteLength / Float64Array.BYTES_PER_ELEMENT).toInt()
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < (intByteLength / Float64Array.BYTES_PER_ELEMENT).toInt()) {
            intByteLength = intLength * Float64Array.BYTES_PER_ELEMENT
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Float64Array with respect to buf.
     *
     * @param { ArrayLike<Number> | ArrayBuffer } buf - data initializer
     * @throws { RangeError } - Input parameter error.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public constructor(buf: ArrayLike<Number> | ArrayBuffer) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % Float64Array.BYTES_PER_ELEMENT.toInt() != 0) {
               throw new RangeError("ArrayBuffer.byteLength should be multiple of 8 as Float64Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = (this.byteLength / Float64Array.BYTES_PER_ELEMENT).toInt()
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length * Float64Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLength)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Assigns val as element on index.
     *
     * @param { int } index - index to change
     * @param { double } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_set(index: int, val: double): void

    /**
     * Number of double stored in Float64Array
     *
     * @returns { int } - the number of elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public get length(): int {
        return this.lengthInt
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param { int } index - index to look at
     * @returns { number } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native $_get(index: int): number

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param { int } index - index to look at
     * @returns { Number | undefined } - a primitive at index
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } [end] - last index to end copy from, excluded
     * @returns { Float64Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int, start: int, end?: int): Float64Array {
        let arrayLength: int = this.lengthInt;
        target = normalizeIndex(target, arrayLength);
        start = normalizeIndex(start, arrayLength);
        end = normalizeIndex(asIntOrDefault(end, arrayLength), arrayLength);
        let count: int = end - start;
        if (count > (arrayLength - target)) {
            count = arrayLength - target;
        }
        if (count <= 0) {
            return this;
        }

        this.copyWithinImpl(target, start, count)
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @param { int } start - start index to begin copy from
     * @param { int } end - last index to end copy from, excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private native copyWithinImpl(target: int, start: int, end: int): void

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Float64Array.
     * See rules of parameters normalization on
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     *
     * @param { int } target - insert index to place copied elements
     * @returns { Float64Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public copyWithin(target: int): Float64Array {
        this.copyWithinImpl(target, 0, this.lengthInt)
        return this
    }

    /**
     * Returns an array of key, value pairs for every entry in the Float64Array
     *
     * @returns { IterableIterator<[int, Number]> } - key, value pairs for every entry in the array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public entries(): IterableIterator<[int, Number]> {
        return new Float64ArrayIteratorEntries(this)
    }

    /**
     * Fills the Float64Array with specified value
     *
     * @param { number } value - new value
     * @param { int } [start] - start index to begin fill from
     * @param { int } [end] - last index to end fill from, excluded
     * @returns { this } - modified Float64Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public fill(value: number, start?: int, end?: int): this {
        const k = normalizeIndex(start ?? 0, this.lengthInt)
        const finalPos = normalizeIndex(end ?? this.lengthInt, this.lengthInt)
        this.fillInternal(value.toDouble(), k, finalPos)
        return this
    }

    private final native fillInternal(value: double, start: int, end: int): void

    /**
     * Assigns val as element on insertPos.
     *
     * @param { int } insertPos - index to change
     * @param { number } val - value to set
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(insertPos: int, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Float64Array.
     *
     * @param { FixedArray<double> } arr - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<double>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Float64Array starting from insertPos.
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     *
     * @param { FixedArray<number> } arr - array to copy data from
     * @param { int } insertPos - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(arr: FixedArray<number>, insertPos: int): void {
        const offset = insertPos
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.setUnsafe(offset + i, arr[i])
        }
    }

    private native final set(array: Array<number>): void;

    /**
     * Copies all elements of array to the current Float64Array.
     *
     * @param { Float64Array } array - array to copy data from
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: Float64Array): void

    /**
     * Copies all elements of arr to the current Float64Array starting from offset.
     *
     * @param { Float64Array } array - array to copy data from
     * @param { int } offset - start index where data from arr will be inserted
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native set(array: Float64Array, offset: int): void

    /**
     * Copies elements from an ArrayLike object to the Float64Array.
     *
     * @param { ArrayLike<number> } array - An ArrayLike object containing the elements to copy.
     * @param { int } [offset] - Optional. The offset into the target array at which to begin
     *     writing values from the source array. The default value is 0.
     * @throws { RangeError } - If the number of assigned elements exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public set(array: ArrayLike<number>, offset: int = 0): void {
        const insertPos = offset
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; ++i) {
            this.setUnsafe(insertPos + i, array[i])
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<int> } items - a set of elements to include in the new array object.
     * @returns { Float64Array } - a new Float64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<int>): Float64Array {
        let res = new Float64Array(items.length.toInt())
        res.ofInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param { FixedArray<number> } items - a set of elements to include in the new array object.
     * @returns { Float64Array } - a new Float64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(...items: FixedArray<number>): Float64Array {
        let res = new Float64Array(items.length.toInt())
        res.ofNumber(items)
        return res
    }

    private final native ofInt(items: FixedArray<int>): void
    private final native ofNumber(items: FixedArray<number>): void

    /**
     * Returns a new array from a set of elements.
     *
     * @returns { Float64Array } - a new Float64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static of(): Float64Array {
        return new Float64Array(0)
    }

    /**
     * Creates an array from an object of FixedArray<number>.
     *
     * @param { FixedArray<number> } arr - An instance of the FixedArray type to convert to an array.
     * @returns { Float64Array } - A new Float64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: FixedArray<number>): Float64Array {
        let result = new Float64Array(arr.length)
        result.ofNumber(arr)
        return result
    }

    /**
     * Creates an array from a set of type std.core.Set<number>.
     *
     * @param { Set<number> } set - A set object to convert to an array.
     * @returns { Float64Array } - A new Float64Array
     * @throws { AssertionError } - Input parameter error.
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(set: Set<number>): Float64Array {
        const length = set.size;
        const result = new Float64Array(length)
        let iter = set.$_iterator()
        for (let i:int = 0; i < length; ++i) {
            const x = iter.next()
            if (x.done) {
                throw new AssertionError('Wrong Length')
            }
            result.setUnsafe(i, x.value!.toDouble())
        }
        return result
    }

    /**
     * Creates an array from an array of the same type.
     *
     * @param { Float64Array } arr - An array to convert to a new array.
     * @returns { Float64Array } - A new Float64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Float64Array): Float64Array {
        let result = new Float64Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an object of std.core.Array<number>.
     *
     * @param { Array<number> } arr - An instance of the std.core.Array type to convert to an array.
     * @returns { Float64Array } - A new Float64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arr: Array<number>): Float64Array {
        let result = new Float64Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<number> } arrayLike - An array-like or iterable object to convert to an array.
     * @returns { Float64Array } - A new Float64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: ArrayLike<number>): Float64Array {
        return Float64Array.from<number>(arrayLike, (x: number, k: number): number => x)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { ArrayLike<T> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } mapfn - A mapping function to call on every element of the array.
     * @returns { Float64Array } - A new Float64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number): Float64Array {
        let res = new Float64Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new FixedArray<int>(1)
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            const mapped = mapfn(x as T, idx[0])
            res.setUnsafe(idx[0], mapped)
            idx[0]++
        })
        return res
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param { Iterable<number> } arrayLike - An array-like or iterable object to convert to an array.
     * @param { function } [mapfn] - A mapping function to call on every element of the array.
     * @returns { Float64Array } - A new Float64Array
     * @static
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Float64Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE (templin.konstantin): This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Float64Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Float64Array(result.buffer, 0, i)
                }
                const mapped = (mapfn)!(x.value!, i)
                result.setUnsafe(i, mapped)
            }
            return result
        }

        // NOTE (templin.konstantin): Create builtin array as buffer
        let temp = new Float64Array(6)
        let index : FixedArray<int> = new FixedArray<int>(1)
        index[0] = 0

        iteratorForEach<number>(iter, (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE (templin.konstantin): Progressive reallocation
                const curLength = temp.buffer.getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, temp.buffer.at(i))
                }
                temp = new Float64Array(tb)
            }
            const mapped = (mapfn)!(x, index[0])
            temp.setUnsafe(index[0], mapped)
            index[0]++
        })
        return new Float64Array(temp.buffer, 0, index[0])
    }
    private final native containsNaN(fromIndex: int): boolean;

    /**
     * Determines whether Float64Array includes a certain element, returning true or false as appropriate
     *
     * @param { number } searchElement - The element to search for
     * @param { int } [fromIndex] - The position in this array at which to begin searching for searchElement.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { boolean } - true if searchElement is in Float64Array, false otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public includes(searchElement: number, fromIndex?: int): boolean {
        if (isNaN(searchElement)) {
            return this.containsNaN(asIntOrDefault(fromIndex, 0))
        }
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in Float64Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int): int {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Float64Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: int, fromIndex: int): int {
        return this.indexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the first occurrence of a value in Float64Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } [fromIndex] - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public indexOf(searchElement: number, fromIndex?: int): int {
            return this.indexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Float64Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns {int} - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Float64Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - index of element if it presents, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native indexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Converts all elements of an array to strings and joins them using the specified separator.
     *
     * @param { String } separator - separates one element of an array from the next in the resulting String.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native joinInternal(separator: String): string;

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param { String } [separator] - A string used to separate one element of an array from the next in the
     *     resulting String. If omitted, the array elements are separated with a comma.
     * @returns { string } - joined representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.joinInternal(",")
        }
        return this.joinInternal(separator)
    }

    /**
     * Returns an list of keys in Float64Array
     *
     * @returns { IterableIterator<int> } - iterator over keys
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public keys(): IterableIterator<int> {
        return new Float64ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Float64Array.
     *
     * @param { int } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Float64Array.
     *
     * @param { number } searchElement - The value to locate in the array. The search begins at index length - 1.
     * @returns { int } - right-most index of searchElement. It must be less than length. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: number): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Float64Array.
     *
     * @param { int } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: int, fromIndex: int): int {
        return this.lastIndexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the last occurrence of a value in Float64Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int | undefined } fromIndex - The array index at which to begin the search.
     *     If fromIndex is undefined, the search starts at index 0.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public lastIndexOf(searchElement: number, fromIndex: int | undefined): int {
            return this.lastIndexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the last occurrence of a value in Float64Array.
     *
     * @param { long } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the last occurrence of a value in Float64Array.
     *
     * @param { number } searchElement - The value to locate in the array.
     * @param { int } fromIndex - The array index at which to begin the search.
     * @returns { int } - right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    private final native lastIndexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Creates a new Float64Array using initializer
     *
     * @param { FixedArray<Object> } data - initializer
     * @returns { Float64Array } - a new Float64Array
     * @throws { Error } - function not implemented
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public of(data: FixedArray<Object>): Float64Array {
        throw new Error("Float64Array.of: not implemented")
    }

    /**
     * Creates a new Float64Array using reversed data from the current one
     *
     * @returns { Float64Array } - a new Float64Array using reversed data from the current one
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native reverse(): Float64Array

    /**
     * Creates a slice of current Float64Array using range [begin, this.length).
     *
     * @param { int } begin - start index to be taken into slice
     * @returns { Float64Array } - a new Float64Array with elements of current Float64Array[begin, this.length)
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin: int): Float64Array {
        return this.sliceFromTo(begin, this.lengthInt)
    }

    /**
     * Creates a slice of current Float64Array using range [begin, end)
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sliceFromTo}
     *
     * @param { int } [begin] - start index to be taken into slice
     * @param { int } [end] - last index to be taken into slice
     * @returns { Float64Array } - a new Float64Array with elements of current Float64Array[begin;end),
     *     where end index is excluded
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public slice(begin?: int, end?: int): Float64Array {
        return this.sliceFromTo(begin ?? 0, end ?? this.lengthInt)
    }

    private sliceFromTo(begin: int, end: int): Float64Array {
        const relStart: int = normalizeIndex(begin, this.lengthInt)
        const relEnd: int = normalizeIndex(end, this.lengthInt)
        let buf: ArrayBuffer = this.buffer.slice(relStart * this.BYTES_PER_ELEMENT + this.byteOffset, relEnd * this.BYTES_PER_ELEMENT + this.byteOffset)
        return new Float64Array(buf)
    }


    /**
     * Creates a Float64Array with the same underlying ArrayBuffer
     *
     * @param { int } [begin] - start index, inclusive
     * @param { int } [end] - last index, exclusive
     * @returns { Float64Array } - a new Float64Array with the same underlying ArrayBuffer
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public subarray(begin?: int, end?: int): Float64Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin ?? 0, len)
        const relEnd = normalizeIndex(end ?? this.lengthInt, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Float64Array(this.buffer, relStart * Float64Array.BYTES_PER_ELEMENT + this.byteOffset, count)
    }

    /**
     * Converts Float64Array to a string with respect to locale
     *
     * @returns { string } - string representation
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(new Number(this.getUnsafe(i)).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append(new Number(this.getUnsafe(this.lengthInt - 1))).toLocaleString()
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns { Float64Array } - a reversed copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toReversed(): Float64Array {
        let newArray = new Float64Array(this.lengthInt);
        if (this.lengthInt > 0) {
            Float64Array.reverseCopyBuffer(newArray.buffer, this.buffer, this.byteOffset, this.lengthInt);
        }
        return newArray
    }

    /**
     * Creates a sorted copy
     *
     * @returns { Float64Array } - a sorted copy
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public toSorted(): Float64Array {
        return new Float64Array(this).sort()
    }

    /**
     * Returns a string representation of the Float64Array
     *
     * @returns { string } - a string representation of the Float64Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns { IterableIterator<Number> } - an iterator
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public values(): IterableIterator<Number> {
        return new Float64ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns { IterableIterator<Number> } - iterator over all elements
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public override $_iterator(): IterableIterator<Number> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param { int } index - index to change
     * @param { number } value - value to set
     * @returns { Float64Array } - an Float64Array with replaced value on index
     * @throws { RangeError } - If the index exceeds the array range, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public with(index: int, value: number): Float64Array {
        let res = new Float64Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===

    /**
     * Finds the last element in the Float64Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { number } - the last element that satisfies fn
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Float64Array) => boolean =
            (val: number, index: int, array: Float64Array): boolean => { return fn(val) }
        return (this.findLast(newF)).toDouble()
    }

    /**
     * Sorts in-place by numeric value in ascending order.
     *
     * @returns { this } - sorted Float64Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public native sort(): this;

    /**
     * Sorts in-place
     *
     * @param { function } [compareFn] - comparator _  used to determine the order of the elements.
     *     compareFn returns a negative value if first argument is less than second argument,
     *     zero if they're equal and a positive value otherwise.
     * @returns { this } - sorted Float64Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public sort(compareFn?: (a: number, b: number) => int): this {
        if (compareFn == undefined) {
            this.sort()
            return this
        }

        let cmp = (l: double, r: double): int => {
            const result = compareFn!((l).toDouble(), (r).toDouble())
            return result.toInt()
        }

        const MAX_SHORT_LENGTH = 24
        let naNCounter = 0

        if (this.lengthInt > MAX_SHORT_LENGTH) {
            let arr: FixedArray<double> = new FixedArray<double>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                let val = this.getUnsafe(i)
                if (isNaN(val)) {
                    naNCounter++
                } else {
                    arr[i - naNCounter] = val
                }
            }
            for (let i = 0; i < naNCounter; ++i) {
                arr[this.lengthInt - 1 - i] = NaN.toDouble()
            }
            const arrLength = this.lengthInt - naNCounter

            arr = mergeSort(arr, cmp, 0, arrLength)

            for (let i = 0; i < arr.length; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let buffer: FixedArray<Double> = new FixedArray<Double>(this.lengthInt)
            for (let i = 0; i < this.lengthInt; ++i) {
                let val = this.getUnsafe(i)
                if (isNaN(val)) {
                    naNCounter++
                } else {
                    buffer[i - naNCounter] = val
                }
            }
            for (let i = 0; i < naNCounter; ++i) {
                buffer[this.lengthInt - 1 - i] = NaN.toDouble()
            }
            const arrLength = this.lengthInt - naNCounter

            arr_sort_stable(buffer, 0, arrLength, cmp)
            for (let i = 0; i < buffer.length; ++i) {
                this.setUnsafe(i, buffer[i].toDouble())
            }
        }
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The some method calls the predicate function for each element in the array
     *     until the predicate returns a true or until the end of the array.
     * @returns { boolean } - false unless predicate function returns true for an array element,
     *     in which case true is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public some(predicate: (element: number, index: int, array: Float64Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     *     The first call to the callbackfn function provides this value as an argument.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Float64Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduce method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array first element value as an argument
     * @returns { number } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the Float64Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Float64Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = (this.getUnsafe(0)).toDouble()
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param { U } initialValue - The parameter which value is used as the initial value to start the accumulation.
     * @returns { U } - Run the callback function on the entire typed array until the obtained value is completed.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Float64Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param { function } callbackfn - A function that accepts four arguments.
     *     The reduceRight method calls the callbackfn function one time for each element in the array.
     *     The first call to the callbackfn function provides array last element value as an argument.
     * @returns { number } - Run the callback function on the entire typed array until the obtained value is completed.
     * @throws { TypeError } - If the Float64Array length is 0, throw a TypeError.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Float64Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = (this.getUnsafe(this.lengthInt - 1)).toDouble()
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, (this.getUnsafe(i)).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Creates a new Float64Array using fn(arr[i]) over all elements of current Float64Array.
     *
     * @param { function } fn - a function to apply for each element of current Float64Array
     * @returns { Float64Array } - a new Float64Array where for each element from current Float64Array fn was applied
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public map(fn: (val: number, index: int, array: Float64Array) => number): Float64Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Float64Array.BYTES_PER_ELEMENT)
        let res = new Float64Array(resBuf, 0, (resBuf.getByteLength() / Float64Array.BYTES_PER_ELEMENT).toInt())
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn((this.getUnsafe(i)).toDouble(), i, this).toDouble())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param { function } predicate - A function that accepts three arguments.
     *     The every method calls the predicate function for each element in the array until the predicate
     *     returns a false, or until the end of the array.
     * @returns { boolean } - true unless predicate function returns a false for an array element,
     *     in which case false is immediately returned.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public every(predicate: (element: number, index: int, array: Float64Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Creates a new Float64Array from current Float64Array based on a condition fn.
     *
     * @param { function } fn - the condition to apply for each element
     * @returns { Float64Array } - a new Float64Array
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public filter(fn: (val: number, index: int, array: Float64Array) => boolean): Float64Array {
        let markers : FixedArray<boolean> = new FixedArray<boolean>(this.lengthInt)
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn((this.getUnsafe(i)).toDouble(), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Float64Array.BYTES_PER_ELEMENT)
        let res = new Float64Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found, find
     *     immediately returns that element value. Otherwise, find returns undefined
     * @returns { number | undefined }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public find(predicate: (value: number, index: int, obj: Float64Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate((val).toDouble(), i, this)) {
                return (val).toDouble()
            }
        }
        return undefined
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1 otherwise
     *
     * @param { function } predicate - find calls predicate once for each element of the array, in ascending
     *     order, until it finds one where predicate returns true. If such an element is found,
     *     findIndex immediately returns that element index. Otherwise, findIndex returns -1
     * @returns { int } - Index of the first matched element
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findIndex(predicate: (value: number, index: int, obj: Float64Array) => boolean): int {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate((this.getUnsafe(i)).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds the last element in the Float64Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { double } - the last element that satisfies fn
     * @throws { Error } - If the element cannot be found, throw an exception
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLast(fn: (val: number, index: int, array: Float64Array) => boolean): double {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn((val).toDouble(), i, this)) {
                return val
            }
        }
        throw new Error("Float64Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds an index of the last element in the Float64Array that satisfies the condition
     *
     * @param { function } fn - condition
     * @returns { int } - the index of the last element that satisfies fn, -1 otherwise
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public findLastIndex(fn: (val: number, index: int, array: Float64Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn((val).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Performs the specified action for each element in Float64Array
     *
     * @param { function } callbackfn - A function that accepts up to three arguments. forEach calls the
     *     callbackfn function one time for each element in the array.
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public forEach(callbackfn: (value: number, index: int, array: Float64Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn((this.getUnsafe(i)).toDouble(), i, this)
        }
    }

    /**
     * Returns the object itself
     *
     * @returns { Float64Array }
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public valueOf(): Float64Array {
        return this
    }

    private static native reverseCopyBuffer(dstBuf: ArrayBuffer, srcBuf: ArrayBuffer, startPos: int, length: int): void

    private final native getUnsafe(index: int): double

    private setUnsafe(insertPos: int, val: double): void {
        const BPE = Float64Array.BYTES_PER_ELEMENT.toInt()
        let byteIndex = insertPos * BPE + this.byteOffset
        let buf = this.buffer
        let bits = Double.bitCastToLong(val)
        if (IS_LITTLE_ENDIAN) {
            for (let i = 0; i < BPE; ++i) {
                let byteVal = ((bits >>> (i * 8)) & 0xff).toByte()
                buf.set(byteIndex++, byteVal)
            }
        } else {
            byteIndex = byteIndex + BPE - 1
            for (let i = 0; i < BPE; ++i) {
                let byteVal = ((bits >>> (i * 8)) & 0xff).toByte()
                buf.set(byteIndex--, byteVal)
            }
        }
        
    }

    /**
     * Underlying ArrayBuffer
     *
     * @type { ArrayBuffer }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly buffer: ArrayBuffer

    /**
     * Byte offset within the underlying ArrayBuffer
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteOffset: int

    /**
     * Number of bytes used
     *
     * @type { int }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly byteLength: int

    /**
     * String \"Float64Array\"
     *
     * @type { string }
     * @readonly
     * @syscap SystemCapability.Utils.Lang
     * @FaAndStageModel
     * @since 24
     */
    public readonly name = "Float64Array"
}
