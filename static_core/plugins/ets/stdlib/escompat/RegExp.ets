/*
 * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package escompat

type RegExpGroupsContainer = Record<String, String | undefined>

/**
 * Regular expression result descriptor
 */
export class RegExpResultArray /*extends Array<String>*/ {
    /** true if match present */
    readonly isCorrect: boolean
    /** result itself */
    protected result_: Array<String> = []
    private resultRaw_: String = ""
    /** The 0-based index of the match in the string */
    protected index_: number = 0
    /** The original string that was matched against */
    protected input_: String = ""

    private endIndex: number = 0

    // NOTE(shumilov-petr): Make nullable when #14813 will be fixed
    protected indices_: Array<Array<number>> = []

    /** named groups names and indeces */
    protected groupsRaw_: String = ""

    /** named groups names and indeces */
    public groups: RegExpGroupsContainer | undefined = undefined

    protected isUndefined: Array<boolean> = []

    constructor(index: int, input: String, result: Array<String>, indices: Array<Array<number>>) {
        this.isCorrect = true
        this.index_ = index
        this.input_ = input
        this.result_ = result
        this.indices_ = indices
    }

    constructor(index : int, input : String, result : Array<String>, indices : Array<Array<number>>,
                isUndefined : Array<boolean>) {
        this.isCorrect = true
        this.index_ = index
        this.input_ = input
        this.result_ = result
        this.indices_ = indices
        this.isUndefined = isUndefined
    }

    protected constructor() {

    }

    private setNumberedField(index: number, value: String): void {
        if (index > 9 || index <= 0) {
            return
        }
        if (index == 1) RegExp.$1_ = value
        else if (index == 2) RegExp.$2_ = value
        else if (index == 3) RegExp.$3_ = value
        else if (index == 4) RegExp.$4_ = value
        else if (index == 5) RegExp.$5_ = value
        else if (index == 6) RegExp.$6_ = value
        else if (index == 7) RegExp.$7_ = value
        else if (index == 8) RegExp.$8_ = value
        else if (index == 9) RegExp.$9_ = value
    }

    // NOTE(ekaterinzaytseva): unable to replace internal - crash in analyzer
    internal postExecProcessing(res: RegExpResultArray, input: String, index: number, hasIndices: boolean): void {
        if (!res.isCorrect) {
            return
        }
        RegExp.$1_ = ""
        RegExp.$2_ = ""
        RegExp.$3_ = ""
        RegExp.$4_ = ""
        RegExp.$5_ = ""
        RegExp.$6_ = ""
        RegExp.$7_ = ""
        RegExp.$8_ = ""
        RegExp.$9_ = ""
        this.updateGroups()
        this.updateIndicesAndResult(hasIndices)
        RegExp.input_ = input
        RegExp.leftContext_ = input.substring(0, index)
        RegExp.rightContext_ = input.substring(index + res.result[0].length)
    }

    /**
     * Returns the first match if "0" is given and the first match exists
     *
     * @param index
     *
     * @returns the first match as string or null
     */
    public $_get(index: String): String {
        if (index == "0") {
            if (this.result_.length > 0) {
                return this.result_[0]
            }
            throw new Error("result is empty")
        }
        throw new Error("unsupported field name")
    }

    /**
     * Returns result string by index
     *
     * @param index
     *
     * @returns resulting string
     */
    public $_get(index: int): String | undefined {
        if (index < this.isUndefined.length && this.isUndefined[index]) {
            return undefined
        }
        return this.result_[index];
    }

    /**
     * Returns result string by index
     *
     * @param index
     *
     * @returns resulting string
     */
    public $_get(index: number): String | undefined {
        return this.$_get(index.toInt());
    }

    /**
     * Sets value by index
     *
     * @param index
     *
     * @param val
     */
    public $_set(index: int, val: String) {
        this.result_[index] = val
    }

    /**
     * Sets value by index
     *
     * @param index
     *
     * @param val
     */
    public $_set(index: number, val: String) {
        return this.$_set(index.toInt(), val);
    }

    get length(): int {
        return Double.toInt(this.result_.length)
    }

    public get result(): Array<String> {
        return this.result_
    }

    public get indices(): Array<Array<number>> {
        return this.indices_
    }

    /**
     * Returns a string representing the match result
     *
     * @returns a string representing the match result
     */
    public toString(): String {
        if (this.result_.length > 0) {
            return this.result_.toString();
        }
        throw new Error("result is empty")
    }

    /**
     * Parses groupsRaw_ to groups
     */
    protected updateGroups(): void {
        throw new Error("not overridden")
    }

    private processStaticFields(index: number, str: String): void {
        if (index == 0) {
            RegExp.lastMatch_ = str
        }
        if (index == this.result_.length - 1) {
            RegExp.lastParen_ = str
        }
        this.setNumberedField(index, str)
    }

    private updateIndicesAndResult(hasIndices: boolean): void {
        let data = this.resultRaw_.split(',')
        this.result_ = new Array<String>(data.length / 2)
        this.isUndefined = new Array<boolean>(data.length / 2)
        if (hasIndices) {
            this.indices_ = new Array<Array<number>>(data.length / 2)
            for (let i = 0; i < data.length; i+= 2) {
                const index = Number.parseInt(data[i])
                const endIndex = Number.parseInt(data[i + 1])
                if (index == -1 || endIndex == -1) {
                    this.indices_[i / 2] = [0, 0]
                    this.isUndefined[i / 2] = true
                } else {
                    this.indices_[i / 2] = [index, endIndex]
                    this.result_[i / 2] = this.input_.substring(index, endIndex)
                    this.processStaticFields(i / 2, this.result_[i / 2])
                    this.isUndefined[i / 2] = false
                }
            }
        } else {
            this.indices_ = []
            for (let i = 0; i < data.length; i+= 2) {
                const index = Number.parseInt(data[i])
                const endIndex = Number.parseInt(data[i + 1])
                if (index != -1 && endIndex != -1) {
                    this.result_[i / 2] = this.input_.substring(index, endIndex)
                    this.processStaticFields(i / 2, this.result_[i / 2])
                    this.isUndefined[i / 2] = false
                } else {
                    this.isUndefined[i / 2] = true
                }
            }
        }
    }

    /**
     * Removes and returns the last match result in the array.
     * Simulates the behavior of Array.prototype.pop().
     *
     * @returns The last matched string if present; otherwise, undefined.
     */
    public pop(): String | undefined {
        return this.result_.pop()
    }

    /**
     * Takes an integer value and returns the item at that index,
     * allowing for positive and negative integers.
     */
    public at(index: number): String | undefined {
        return this.result_.at(index)
    }

    /**
     * Takes an integer value and returns the item at that index,
     * allowing for positive and negative integers.
     */
    public at(index: int): String | undefined {
        return this.result_.at(index)
    }

    /**
     * Creates a new array with all elements concatenated.
     */
    public concat(...items: FixedArray<ConcatArray<String>>): Array<String> {
        return this.result_.concat(...items)
    }

    /**
     * Makes a shallow copy of part to another location in the same array.
     */
    public copyWithin(target: number, start: number, end?: Number): RegExpResultArray {
        this.result_.copyWithin(target, start, end)
        return this
    }

    /**
     * Makes a shallow copy of part to another location in the same array.
     */
    public copyWithin(target: int, start: int, end: int): RegExpResultArray {
        this.result_.copyWithin(target, start, end)
        return this
    }

    /**
     * Makes a shallow copy of part to another location in the same array.
     */
    public copyWithin(target: int, start: int): RegExpResultArray {
        this.result_.copyWithin(target, start)
        return this
    }

    /**
     * Makes a shallow copy of part to another location in the same array.
     */
    public copyWithin(target: int): RegExpResultArray {
        this.result_.copyWithin(target)
        return this
    }

    /**
     * Changes all elements to a static value.
     */
    public fill(value: String, start?: Number, end?: Number): RegExpResultArray {
        this.result_.fill(value, start, end)
        return this
    }

    /**
     * Changes all elements to a static value.
     */
    public fill(value: String, start: int, end: int): RegExpResultArray {
        this.result_.fill(value, start, end)
        return this
    }

    /**
     * Returns elements that meet the condition specified in a callback function.
     */
    public filter(predicate: (value: String, index: number, array: RegExpResultArray) => boolean): Array<String> {
        return this.result_.filter((value: String, index: number, array: Array<String>) => {
            return predicate(value, index, this)
        })
    }

    /**
     * Returns the value of the first element where predicate is true.
     */
    public find(predicate: (value: String, index: number, array: RegExpResultArray) => boolean): String | undefined {
        return this.result_.find((value: String, index: number, array: Array<String>) => {
            return predicate(value, index, this)
        })
    }

    /**
     * Returns the index of the first element where predicate is true.
     */
    public findIndex(predicate: (value: String, index: number, array: RegExpResultArray) => boolean): number {
        return this.result_.findIndex((value: String, index: number, array: Array<String>) => {
            return predicate(value, index, this)
        })
    }

    /**
     * Returns the value of the last element that satisfies the testing function.
     */
    public findLast(predicate: (elem: String, index: number, array: RegExpResultArray) => boolean): String | undefined {
        return this.result_.findLast((elem: String, index: number, array: Array<String>) => {
            return predicate(elem, index, this)
        })
    }

    /**
     * Returns the index of the last element that satisfies the testing function.
     */
    public findLastIndex(predicate: (element: String, index: number, array: RegExpResultArray) => boolean): number {
        return this.result_.findLastIndex((element: String, index: number, array: Array<String>) => {
            return predicate(element, index, this)
        })
    }

    /**
     * Creates a new array with all sub-array elements concatenated.
     */
    public flat<U>(depth: number): Array<U> {
        return this.result_.flat<U>(depth)
    }

    /**
     * Creates a new array with all sub-array elements concatenated.
     */
    public flat<U>(depth: int): Array<U> {
        return this.result_.flat<U>(depth)
    }

    /**
     * Creates a new array with all sub-array elements concatenated.
     */
    public flat<U>(): Array<U> {
        return this.result_.flat<U>()
    }

    /**
     * Applies flat and then map.
     */
    public flatMap<U>(fn: (v: String, k: number, arr: RegExpResultArray) => U): Array<U> {
        return this.result_.flatMap<U>((v: String, k: number, arr: Array<String>) => {
            return fn(v, k, this)
        })
    }

    /**
     * Determines whether all members satisfy the specified test.
     */
    public every(predicate: (value: String, index: number, array: RegExpResultArray) => boolean): boolean {
        return this.result_.every((value: String, index: number, array: Array<String>) => {
            return predicate(value, index, this)
        })
    }

    /**
     * Determines whether any element satisfies the specified test.
     */
    public some(predicate: (value: String, index: number, array: RegExpResultArray) => boolean): boolean {
        return this.result_.some((value: String, index: number, array: Array<String>) => {
            return predicate(value, index, this)
        })
    }

    /**
     * Calls the callback function for all elements and accumulates the result.
     */
    public reduce(callbackfn: (previousValue: String, currentValue: String, index: number, array: RegExpResultArray) => String): String {
        return this.result_.reduce((previousValue: String, currentValue: String, index: number, array: Array<String>) => {
            return callbackfn(previousValue, currentValue, index, this)
        })
    }

    /**
     * Calls the callback function for all elements and accumulates the result.
     */
    public reduce<U = String>(callbackfn: (previousValue: U, currentValue: String, index: number, array: RegExpResultArray) => U, initialValue: U): U {
        return this.result_.reduce<U>((previousValue: U, currentValue: String, index: number, array: Array<String>) => {
            return callbackfn(previousValue, currentValue, index, this)
        }, initialValue)
    }

    /**
     * Calls the callback function for all elements in descending order and accumulates the result.
     */
    public reduceRight<U>(callbackfn: (previousValue: U, currentValue: String, index: number, array: RegExpResultArray) => U, initialValue: U): U {
        return this.result_.reduceRight<U>((previousValue: U, currentValue: String, index: number, array: Array<String>) => {
            return callbackfn(previousValue, currentValue, index, this)
        }, initialValue)
    }

    /**
     * Calls the callback function for all elements in descending order and accumulates the result.
     */
    public reduceRight(callbackfn: (previousValue: String, currentValue: String, index: number, array: RegExpResultArray) => String): String {
        return this.result_.reduceRight((previousValue: String, currentValue: String, index: number, array: Array<String>) => {
            return callbackfn(previousValue, currentValue, index, this)
        })
    }

    /**
     * Performs the specified action for each element.
     */
    public forEach(callbackfn: (value: String, index: number, array: RegExpResultArray) => void): void {
        this.result_.forEach((value: String, index: number, array: Array<String>) => {
            callbackfn(value, index, this)
        })
    }

    /**
     * Creates a new array with elements selected from start to end.
     */
    public slice(start?: Number, end?: Number): Array<String> {
        return this.result_.slice(start, end)
    }

    /**
     * Creates a new array with elements selected from start to end.
     */
    public slice(start: int, end: int): Array<String> {
        return this.result_.slice(start, end)
    }

    /**
     * Creates a new array with elements selected from start to end.
     */
    public slice(start: int): Array<String> {
        return this.result_.slice(start)
    }

    /**
     * Returns the last index of the specified element.
     */
    public lastIndexOf(searchElement: String, fromIndex: int): int {
        return this.result_.lastIndexOf(searchElement, fromIndex)
    }

    /**
     * Returns the last index of the specified element.
     */
    public lastIndexOf(searchElement: String, fromIndex: number|undefined): number {
        // NOTE(cheezzario) workaround for #23963
        return this.result_.lastIndexOf(searchElement, fromIndex === undefined ? undefined : Int.valueOf(fromIndex.toInt()))
    }

    /**
     * Returns the last index of the specified element.
     */
    public lastIndexOf(searchElement: String): number {
        return this.result_.lastIndexOf(searchElement)
    }

    /**
     * Creates a string by concatenating all elements, separated by a separator.
     */
    public join(sep?: String): string {
        return this.result_.join(sep)
    }

    /**
     * Returns a locale string representing the array.
     */
    public toLocaleString(locales: Object, options: Object): string {
        return this.result_.toLocaleString(locales, options)
    }

    /**
     * Returns a locale string representing the array.
     */
    public toLocaleString(locales: Object): string {
        return this.result_.toLocaleString(locales)
    }

    /**
     * Returns a locale string representing the array.
     */
    public toLocaleString(): string {
        return this.result_.toLocaleString()
    }

    /**
     * Copying version of the splice method.
     */
    public toSpliced(start?: Number, delete?: Number): Array<String> {
        return this.result_.toSpliced(start, delete)
    }

    /**
     * Copying version of the splice method.
     */
    public toSpliced(start: number, delete: number, ...items: FixedArray<String>): Array<String> {
        return this.result_.toSpliced(start, delete, ...items)
    }

    /**
     * Copying version of the splice method.
     */
    public toSpliced(start: int, delete: int, ...items: FixedArray<String>): Array<String> {
        return this.result_.toSpliced(start, delete, ...items)
    }

    /**
     * Copying version of the splice method.
     */
    public toSpliced(start: int): Array<String> {
        return this.result_.toSpliced(start)
    }

    /**
     * Checks whether an array includes a certain value.
     */
    public includes(val: String, fromIndex?: Number): boolean {
        return this.result_.includes(val, fromIndex)
    }

    /**
     * Returns the first index of the specified element.
     */
    public indexOf(val: String, fromIndex: int): int {
        return this.result_.indexOf(val, fromIndex)
    }

    /**
     * Returns the first index of the specified element.
     */
    public indexOf(val: String, fromIndex?: Number): number {
        // NOTE(cheezzario) workaround for #23963
        return this.result_.indexOf(val, fromIndex === undefined ? undefined : Int.valueOf(fromIndex.toInt()))
    }

    /**
     * Returns the first index of the specified element.
     */
    public indexOf(val: String): number {
        return this.result_.indexOf(val)
    }

    /**
     * Copying version of the sort method using default comparator.
     */
    public toSorted(): Array<String> {
        return this.result_.toSorted()
    }

    /**
     * Copying version of the sort method.
     */
    public toSorted(comparator: (a: String, b: String) => number): Array<String> {
        return this.result_.toSorted(comparator)
    }

    /**
     * Reverses the elements in place.
     */
    public reverse(): RegExpResultArray {
        this.result_.reverse()
        return this
    }

    /**
     * Copying version of the reverse method.
     */
    public toReversed(): Array<String> {
        return this.result_.toReversed()
    }

    /**
     * Copying version of setting a value at an index.
     */
    public with(index: number, value: String): Array<String> {
        return this.result_.with(index, value)
    }

    /**
     * Copying version of setting a value at an index.
     */
    public with(index: int, value: String): Array<String> {
        return this.result_.with(index, value)
    }

    /**
     * Removes the first element and returns it.
     */
    public shift(): String | undefined {
        return this.result_.shift()
    }

    /**
     * Adds elements to the end and returns the new length.
     */
    public push(...val: String[]): number {
        return this.result_.push(...val)
    }

    /**
     * Adds elements to the end and returns the new length.
     */
    public pushECMA(...val: String[]): number {
        return this.result_.pushECMA(...val)
    }

    /**
     * Changes contents by removing/replacing existing elements and/or adding new elements.
     */
    public splice(start: number, delete: Number | undefined, ...items: String[]): Array<String> {
        return this.result_.splice(start, delete, ...items)
    }

    /**
     * Changes contents by removing/replacing existing elements and/or adding new elements.
     */
    public splice(start: int, delete: int, ...items: String[]): Array<String> {
        return this.result_.splice(start, delete, ...items)
    }

    /**
     * Changes contents by removing elements from start to end.
     */
    public splice(start: number): Array<String> {
        return this.result_.splice(start)
    }

    /**
     * Changes contents by removing elements from start to end.
     */
    public splice(start: int): Array<String> {
        return this.result_.splice(start)
    }

    /**
     * Adds elements to the beginning and returns the new length.
     */
    public unshift(...values: String[]): number {
        return this.result_.unshift(...values)
    }

    /**
     * Returns an iterator over all indices.
     */
    public keys(): IterableIterator<Number> {
        return this.result_.keys()
    }

    /**
     * Returns an iterator over all values.
     */
    public $_iterator(): IterableIterator<String> {
        return this.result_.$_iterator()
    }

    /**
     * Returns an iterator over all values.
     */
    public values(): IterableIterator<String> {
        return this.result_.values()
    }

    /**
     * Returns an iterable of key, value pairs.
     */
    public entries(): IterableIterator<[number, String]> {
        return this.result_.entries()
    }

    /**
     * Calls a callback function on each element and returns an array with the results.
     */
    public map<U>(callbackfn: (value: String, index: number, array: RegExpResultArray) => U): Array<U> {
        return this.result_.map<U>((value: String, index: number, array: Array<String>) => {
            return callbackfn(value, index, this)
        })
    }

    /**
     * Reorders elements using comparator function.
     */
    public sort(comparator?: (a: String, b: String) => number): RegExpResultArray {
        this.result_.sort(comparator)
        return this
    }
}

export class RegExpMatchArray extends RegExpResultArray {
    private hasIndex_: boolean = true
    private hasInput_: boolean = true

    constructor(index : int, input : String, result : Array<String>, indices : Array<Array<number>>,
                isUndefined : Array<boolean>) {
        super(Double.toInt(index), input, result, indices, isUndefined)
    };

    constructor(index: int, input: String, result: Array<String>, indices: Array<Array<number>>) {
        super(Double.toInt(index), input, result, indices)
    }

    constructor(index: int, input: String, result: Array<String>) {
        super(Double.toInt(index), input, result, [])
    }

    protected constructor() {
        super()
    }

    public get index(): int | undefined {
        if (this.hasIndex_) {
            return this.index_.toInt()
        }
        return undefined
    }

    public get input(): String | undefined {
        if (this.hasInput_) {
            return this.input_
        }
        return undefined
    }

    public set index(val: int | undefined) {
        if (val == undefined) {
            this.hasIndex_ = false
            return
        }
        this.hasIndex_ = true
        this.index_ = val
    }

    public set input(val: String | undefined) {
        if (val == undefined) {
            this.hasInput_ = false
            return
        }
        this.hasInput_ = true
        this.input_ = val
    }

    /**
     * Parses groupsRaw_ to groups
     */
    protected override updateGroups(): void {
        if (this.groupsRaw_ == "") {
            this.groups = undefined
            return
        }
        let result = new RegExpGroupsContainer()

        if (!this.hasInput_) {
            return
        }

        for (let groupData of this.groupsRaw_.split(";")) {
            if (groupData.length == 0) {
                continue
            }
            let unitData = groupData.split(",")
            if (unitData.length != 3) {
                throw new Error("internal error: invalid group data")
            }
            let index = Double.parseInt(unitData[1])
            let endIndex = Double.parseInt(unitData[2])
            if (index >= 0 && endIndex >= 0) {
                if (endIndex > this.input_.length || index >= endIndex) {
                    throw new Error("internal error: incorrect substring indexes")
                }
                result.set(unitData[0], this.input!.substring(index, endIndex))
            } else {
                result.set(unitData[0], undefined)
            }
        }
        if (result.size == 0) {
            this.groups = undefined
            return
        }
        this.groups = result
    }
}

export class RegExpExecArray extends RegExpResultArray {
    constructor(index: int, input: String, result: Array<String>, indices: Array<Array<number>>) {
        super(index, input, result, indices)
    }

    constructor(index: int, input: String, result: Array<String>) {
        super(index, input, result, [])
    }

    protected constructor() {
        super()
    }

    public get index(): int {
        return this.index_.toInt()
    }

    public get input(): String {
        return this.input_
    }

    public set index(val: int) {
        this.index_ = val
    }

    public set input(val: String) {
        this.input_ = val
    }

    /**
     * Parses groupsRaw_ to groups
     */
    protected override updateGroups(): void {
        if (this.groupsRaw_ == "") {
            this.groups = undefined
            return
        }
        let result = new RegExpGroupsContainer()

        for (let groupData of this.groupsRaw_.split(";")) {
            if (groupData.length == 0) {
                continue
            }
            let unitData = groupData.split(",")
            if (unitData.length != 3) {
                throw new Error("internal error: invalid group data")
            }
            let index = Double.parseInt(unitData[1])
            let endIndex = Double.parseInt(unitData[2])
            if (index >= 0 && endIndex >= 0) {
                if (endIndex > this.input_.length || index >= endIndex) {
                    throw new Error("internal error: incorrect substring indexes")
                }
                result.set(unitData[0], this.input.substring(index, endIndex))
            } else {
                result.set(unitData[0], undefined)
            }
        }
        if (result.size == 0) {
            this.groups = undefined
            return
        }
        this.groups = result
    }
}

class GlobalRegExpStringIterator implements IterableIterator<RegExpMatchArray> {
    private regexp: RegExp
    private string: String

    constructor(regexp: RegExp, string: String) {
        this.regexp = regexp
        this.string = string
    }

    override next(): IteratorResult<RegExpMatchArray> {
        let match = this.regexp.matchInternal(this.string)
        if (match == null) {
            return new IteratorResult<RegExpMatchArray>()
        }
        let matchStr = match.$_get(0)
        if (matchStr == "") {
            this.regexp.lastIndex = RegExp.advanceStringIndex(this.string, this.regexp.lastIndex, this.regexp.unicode)
        }
        return new IteratorResult<RegExpMatchArray>(match)
    }

    override $_iterator(): IterableIterator<RegExpMatchArray> {
        return this
    }
}

class RegExpStringIterator implements IterableIterator<RegExpMatchArray> {
    private regexp: RegExp
    private string: String
    private returned: boolean

    constructor(regexp: RegExp, string: String) {
        this.regexp = regexp
        this.string = string
        this.returned = false
    }

    override next(): IteratorResult<RegExpMatchArray> {
        let match = this.regexp.matchInternal(this.string)
        if (match == null || this.returned) {
            return new IteratorResult<RegExpMatchArray>()
        }
        this.returned = true
        return new IteratorResult<RegExpMatchArray>(match)
    }

    override $_iterator(): IterableIterator<RegExpMatchArray> {
        return this
    }
}

/**
 * Regular expression
 */
export class RegExp extends Object {
    private pattern_: String = ""
    public lastIndex: int = 0
    private source_: String = ""
    private flags_: String = ""

    private static input_: String = ""
    private static lastMatch_: String = ""
    private static lastParen_: String = ""
    private static leftContext_: String = ""
    private static rightContext_: String = ""
    private static $1_: String = ""
    private static $2_: String = ""
    private static $3_: String = ""
    private static $4_: String = ""
    private static $5_: String = ""
    private static $6_: String = ""
    private static $7_: String = ""
    private static $8_: String = ""
    private static $9_: String = ""

    /** Flags */
    get flags(): String {
        return this.flags_
    }

    /**
     * Has the value true if the regular expression should be tested against
     * all possible matches in a string
     */
    get global(): boolean {
        return this.flags_.contains("g", 0)
    }

    /**
     * Has the value true if the dot special character (.) should additionally match
     * the line terminator characters in a string
     */
    get dotAll(): boolean {
        return this.flags_.contains("s", 0)
    }

    /**
     * Has the value true if the result of a regular expression match should contain
     * the start and end indices of the substrings of each capture group
     */
    get hasIndices(): boolean {
        return this.flags_.contains("d", 0)
    }

    /**
     * Has the value true if case should be ignored while attempting a match in a string
     */
    get ignoreCase(): boolean {
        return this.flags_.contains("i", 0)
    }

    /**
     * Has the value true if a multiline input string should be treated as multiple lines
     */
    get multiline(): boolean {
        return this.flags_.contains("m", 0)
    }

    /**
     * Has the value true if the regex attempts to match the target string only
     * from the index indicated by the lastIndex property
     */
    get sticky(): boolean {
        return this.flags_.contains("y", 0)
    }

    /**
     * Has the value true if 'u' flag is used
     */
    get unicode(): boolean {
        return this.flags_.contains("u", 0)
    }

    /**
     * Has the value true if 'v' flag is used
     */
    get unicodeSets(): boolean {
        return this.flags_.contains("v", 0)
    }

    /**
     * Returns a string containing the source text of this regular expression
     */
    get source(): String {
        return this.source_
    }

    /**
     * Returns the string against which a regular expression is matched
     */
    static get input(): String {
        return RegExp.input_
    }

    /**
     * Returns the string against which a regular expression is matched
     */
    static get $_(): String {
        return RegExp.input_
    }

    /**
     * Returns the last matched substring
     */
    static get lastMatch(): String {
        return RegExp.lastMatch_
    }

    /**
     * Returns the last parenthesized substring match, if any
     */
    static get lastParen(): String {
        return RegExp.lastParen_
    }

    /**
     * Returns the substring preceding the most recent match
     */
    static get leftContext(): String {
        return RegExp.leftContext_
    }

    /**
     * Returns the substring following the most recent match
     */
    static get rightContext(): String {
        return RegExp.rightContext_
    }

    /**
     * Returns different aliased properties
     */
    static $_get(key: String): String {
        if (key == "$_") {
            return RegExp.input_
        }
        if (key == "$'") {
            return RegExp.rightContext_
        }
        if (key == "$`") {
            return RegExp.leftContext_
        }
        if (key == "$+") {
            return RegExp.lastParen_
        }
        if (key == "$&") {
            return RegExp.lastMatch_
        }
        throw new Error("unsupported field name")
    }

    /**
     * Static accessor properties return parenthesized substring matches
     */
    static get $1(): String {
        return RegExp.$1_
    }

    static get $2(): String {
        return RegExp.$2_
    }

    static get $3(): String {
        return RegExp.$3_
    }

    static get $4(): String {
        return RegExp.$4_
    }

    static get $5(): String {
        return RegExp.$5_
    }

    static get $6(): String {
        return RegExp.$6_
    }

    static get $7(): String {
        return RegExp.$7_
    }

    static get $8(): String {
        return RegExp.$8_
    }

    static get $9(): String {
        return RegExp.$9_
    }

    /**
     * Constructs a new RegExp using pattern and flags
     *
     * @param pattern description of a pattern
     *
     * @param flags description of flags to be used
     */
    public constructor(pattern: String, flags?: String) {
        this.init(pattern, flags)
    }

    /**
     * Constructs a new RegExp by other RegExp. It uses other RegExp's flags if flags aren't provided
     *
     * @param regexp other regexp
     *
     * @param flags description of flags to be used
     */
    public constructor(regexp: RegExp, flags?: String) {
        this.init(regexp.pattern_, flags === undefined ? regexp.flags : flags!)
    }

    /**
     * Constructs a new RegExp by RegExp or string
     *
     * @param regexp other regexp
     *
     * @param flags description of flags to be used
     */
    public constructor(regexp: RegExp | String, flags?: String) {
        if (regexp instanceof String) {
            this.init(regexp as String, flags)
        } else {
            this.init(regexp as RegExp, flags)
        }
    }

    /**
     * Compiles a regular expression
     */
    public native compile(): RegExp;

    /**
     * Parse a regular expression
     */
    public native static parse(pattern: String): String | undefined;

    /**
     * Recompiles a regular expression with new source and flags after the RegExp object has already been created
     *
     * @param pattern the text of the regular expression
     *
     * @param flags any combination of flag values
     */
    public compile(pattern: String, flags?: String): RegExp {
        this.pattern_ = pattern
        this.flags_ = flags === undefined ? "" : flags!
        this.source_ = RegExp.escapePattern(pattern)
        return this.compile()
    }

    private native execImpl(pattern: String, flags: String, str: String, patternLength: int, strLength: int, lastIndex: int, hasSlashU: boolean): RegExpExecArray;

    private native matchImpl(pattern: String, flags: String, str: String, patternLength: int, strLength: int, lastIndex: int, hasSlashU: boolean): RegExpMatchArray;

    // NOTE(ekaterinazaytseva): used as public
    internal exec(str: String, index: int): RegExpExecArray | null {
        const hasSlashU = str.contains("\\u", 0) || this.pattern_.contains("\\u", 0)
        const res = this.execImpl(this.pattern_, this.flags_, str, this.pattern_.length, str.length, index, hasSlashU)
        if (res.isCorrect) {
            res.input = str
            RegExp.lastMatch_ = ""
            RegExp.lastParen_ = ""
            res.postExecProcessing(res, str, res.index, this.hasIndices)
            return res
        } else {
            return null
        }
    }

    /**
     * Executes a search for a match in a specified string and returns a result array
     *
     * @param str the string against which to match the regular expression
     *
     * @returns RegExp result
     *
     * @see RegExpExecArray
     */
    public exec(str: String): RegExpExecArray | null {
        return this.exec(str, this.lastIndex)
    }

    // NOTE(ekaterinzaytseva): unable to replace internal - used as public
    internal matchInternal(str: String, index: int): RegExpMatchArray | null {
        const hasSlashU = str.contains("\\u", 0) || this.pattern_.contains("\\u", 0)
        const res = this.matchImpl(this.pattern_, this.flags_, str, this.pattern_.length, str.length, index, hasSlashU)
        if (res.isCorrect) {
            res.input = str
            res.postExecProcessing(res, str, res.index!, this.hasIndices)
            return res
        } else {
            return null
        }
    }

    // NOTE(ekaterinazaytseva): unable to replace internal - used in friend class
    internal matchInternal(str: String): RegExpMatchArray | null {
        return this.matchInternal(str, this.lastIndex)
    }

    public search(str: String): int {
        let previousLastIndex: int = this.lastIndex
        this.lastIndex = 0
        let result = this.exec(str)
        this.lastIndex = previousLastIndex
        if (result == null) {
            return -1
        } else {
            return result.index.toInt()
        }
    }

    public replace(str: String, replaceValue: String): String {
        if (this.global) {
            this.lastIndex = 0
        }
        let results = new Array<RegExpExecArray>()
        let done = false
        while (!done) {
            let result = this.exec(str)
            if (result == null) {
                break;
            }
            results.push(result)
            if (!this.global) {
                break;
            }
            let matchStr = result.$_get(0)
            if (matchStr == "") {
                this.lastIndex = RegExp.advanceStringIndex(str, this.lastIndex, this.unicode)
            }
        }
        let lengthS = str.getLength()
        let accumulatedResult = ""
        let nextSourcePosition = 0
        for (let i = 0; i < results.length; ++i) {
            let result = results.at(i)!;
            let nCaptures = result.length;
            let matched = result.$_get(0)!;
            let matchLength = matched.getLength();
            let position = max(min(result.index, lengthS), 0).toInt();
            let captures = new containers.UndefinableStringArray(nCaptures);
            for (let n = 1; n < nCaptures; n++) {
                let capN = result.$_get(n);
                captures.pushBack(capN)
            }
            let replacement = String.getSubstitution(matched, str, position as int, captures.toArray(), result.groups, replaceValue)
            if (position >= nextSourcePosition) {
                accumulatedResult += str.substring(nextSourcePosition, position) + replacement
                nextSourcePosition = position + matchLength
            }
        }
        if (nextSourcePosition >= lengthS) {
            return accumulatedResult
        }
        return accumulatedResult + str.substring(nextSourcePosition)
    }

    public replace(str: String, replacer: (substr: String, args: Object[]) => String): String {
        if (this.global) {
            this.lastIndex = 0
        }
        let results = new Array<RegExpExecArray>()
        let done = false
        while (!done) {
            let result = this.exec(str)
            if (result == null) {
                break;
            }
            results.push(result)
            if (!this.global) {
                break;
            }
            let matchStr = result.$_get(0)
            if (matchStr == "") {
                this.lastIndex = RegExp.advanceStringIndex(str, this.lastIndex, this.unicode)
            }
        }
        let lengthS = str.getLength()
        let accumulatedResult = ""
        let nextSourcePosition = 0
        for (let i = 0; i < results.length; ++i) {
            let result = results.at(i)!;
            let nCaptures = result.length;
            let matched = result.$_get(0)!;
            let matchLength = matched.getLength();
            let position = (max(min(result.index, lengthS), 0)).toInt();
            let args = new containers.UndefinableObjectArray(nCaptures);
            for (let n = 1; n < nCaptures; n++) {
                let capN = result.$_get(n);
                args.pushBack(capN)
            }
            let namedCaptures: Any = /*result.groups*/ undefined;
            args.pushBack(position.toDouble());
            args.pushBack(str)
            if (namedCaptures != undefined) {
                args.pushBack(namedCaptures)
            }
            let replacement = replacer(matched, args.toArray());
            if (position >= nextSourcePosition) {
                accumulatedResult += str.substring(nextSourcePosition, position) + replacement
                nextSourcePosition = position + matchLength
            }
        }
        if (nextSourcePosition >= lengthS) {
            return accumulatedResult
        }
        return accumulatedResult + str.substring(nextSourcePosition)
    }

    public split(str: String, limit: Int | undefined): String[] {
        let unicodeMatching = this.unicode
        let newFlags = this.sticky ? this.flags : this.flags + "y";
        let splitter = new RegExp(this.pattern_, newFlags)
        let lim: long;
        if (limit == undefined) {
            lim = (1 << 32) -1
        } else if (limit == 0) {
            return new String[0]
        } else {
            lim = limit!.toLong()
        }
        let size = str.getLength()
        if (size == 0) {
            let z = splitter.exec(str)
            if (z != null) {
                return new String[0]
            }
            return [str]
        }
        let splittedStrings = new containers.UndefinableStringArray()
        let lastStart = 0
        for (let lastEnd: int = 0; lastEnd < size;) {
            splitter.lastIndex = lastEnd
            let z = splitter.exec(str)
            if (z == null) {
                lastEnd = RegExp.advanceStringIndex(str, lastEnd, unicodeMatching)
            } else {
                let separatorRight = (splitter.lastIndex < size) ? splitter.lastIndex : size
                if (separatorRight == lastStart) {
                    lastEnd = RegExp.advanceStringIndex(str, lastEnd, unicodeMatching)
                } else {
                    let substr = str.substring(lastStart, lastEnd)
                    splittedStrings.pushBack(substr)
                    if (splittedStrings.size() == lim) {
                        return splittedStrings.toArray() as String[]
                    }
                    lastStart = separatorRight
                    let numberOfCaptures = z.length;
                    for (let i = 1; i < numberOfCaptures; ++i) {
                        let nextCapture = z.$_get(i)
                        splittedStrings.pushBack(nextCapture)
                        if (splittedStrings.size() == lim) {
                            return splittedStrings.toArray() as String[]
                        }
                    }
                    lastEnd = lastStart
                }
            }
        }
        let substr = str.substring(lastStart, size)
        splittedStrings.pushBack(substr)
        let res = splittedStrings.toArray() as String[]
        return res
    }

    public match(str: String): RegExpMatchArray | null {
        if (!this.global) {
            return this.matchInternal(str)
        }
        this.lastIndex = 0;
        let matches = new containers.UndefinableStringArray();
        let indices = new Array<Array<number>>();
        let isUndefined = new Array<boolean>();
        let n = 0
        while (true) {
            let result = this.matchInternal(str)
            if (result == null) {
                if (n == 0) {
                    return null
                }
                return new RegExpMatchArray(-1, "", matches.toArray(), indices, isUndefined)
            }
            else {
                let matchStr = result.$_get(0)
                matches.pushBack(matchStr)
                indices = indices.concat(result.indices)
                isUndefined = isUndefined.concat(result.isUndefined)
                if (matchStr == "") {
                    this.lastIndex = RegExp.advanceStringIndex(str, this.lastIndex, this.unicode)
                }
                n++
            }
        }
    }

    public matchAll(str: String): IterableIterator<RegExpMatchArray> {
        let matcher = new RegExp(this)
        matcher.lastIndex = this.lastIndex
        if (matcher.global) {
            return new GlobalRegExpStringIterator(matcher, str)
        } else {
            return new RegExpStringIterator(matcher, str)
        }
    }

    /**
     * Executes a search for a match between a regular expression and specified string
     *
     * @param str the string against which to match the regular expression
     *
     * @returns true if match was found
     */
    public test(str: String): boolean {
        let res = this.exec(str)
        if (!res) {
            return false
        }
        return res.isCorrect
    }

    /**
     * Returns a string representing the given object
     *
     * @returns a string representing the given object
     */
    public override toString(): String {
        return "/" + this.source + "/" + this.flags_
    }

    /**
     * Returns next index from a passed one
     *
     * @param s
     *
     * @param index start position
     *
     * @param unicode true if unicode is used
     *
     * @returns new index
     */
    public static advanceStringIndex(s: String, index: int, unicode: boolean): int {
        if (!unicode) {
            return index + 1
        }
        let length = s.getLength();
        if (index + 1 >= length) {
            return index + 1
        }
        return index + s.codePointCount(index, index + 1);
    }

    public static $_invoke(pattern: RegExp | String, flags?: String) : RegExp {
        return new RegExp(pattern, flags)
    }

    public static $_invoke(pattern: RegExp | String) : RegExp {
        return new RegExp(pattern)
    }

    public static $_invoke(pattern: String, flags?: String) : RegExp {
        return new RegExp(pattern, flags)
    }

    private static escapePattern(pattern: String): String {
        if (pattern == "") {
            return "(?:)"
        }
        let s = pattern.replaceAll("/", "\\/")
        return s.replaceAll("\\", "\\")
    }

    /**
     * Inits regexp from pattern and flags
     *
     * @param pattern description of a pattern
     *
     * @param flags description of flags to be used
     */
    private init(pattern: String, flags?: String) {
        this.regexp_parser(pattern)
        this.pattern_ = pattern
        this.flags_ = flags === undefined ? "" : flags!
        this.source_ = RegExp.escapePattern(pattern)
        this.flags_ = Array.from(this.flags_.split("")).sort().join("")
    }

    /**
     * Inits regexp from RegExp. It uses regexp's flags if flags aren't provided
     *
     * @param regexp other regexp
     *
     * @param flags description of flags to be used
     */
    private init(regexp: RegExp, flags?: String) {
        this.init(regexp.pattern_, flags === undefined ? regexp.flags : flags!)
    }

    private regexp_parser(pattern: String): void {
        let err: String | undefined = RegExp.parse(pattern)
        if (err != undefined) {
            throw new SyntaxError(err as String)
        }
    }
}
