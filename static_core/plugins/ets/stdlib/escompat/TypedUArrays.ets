/*
 * Copyright (c) 2021-2026 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file. DO NOT EDIT
package escompat

// initialized in _initializerBlock_.ets
const IS_LITTLE_ENDIAN: boolean;

class Uint8ClampedArrayIteratorKeys implements IterableIterator<int> {
    private length: int = 0
    private idx: int = 0

    constructor(parent: Uint8ClampedArray) {
        this.length = parent.length
    }

    public override $_iterator(): IterableIterator<int> {
        return this
    }

    override next(): IteratorResult<int> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(false, this.idx++)
    }
}

class Uint8ClampedArrayIterator implements IterableIterator<Number> {
    private parent: Uint8ClampedArray
    private idx: int = 0

    constructor(parent: Uint8ClampedArray) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Uint8ClampedArrayIteratorEntries implements IterableIterator<[int, Number]> {
    private parent: Uint8ClampedArray
    private idx: int = 0

    constructor(parent: Uint8ClampedArray) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[int, Number]> {
        return this
    }

    override next(): IteratorResult<[int, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<[int, Number]>()
        }
        return new IteratorResult<[int, Number]>(
            false,
            [this.idx, new Number(this.parent[this.idx++])]
        )
    }
}

/**
 * JS Uint8ClampedArray API-compatible class
 */
export final class Uint8ClampedArray implements Iterable<Number>, ArrayLike<Number> {
    public static readonly BYTES_PER_ELEMENT: int = 1
    public readonly BYTES_PER_ELEMENT: int = Uint8ClampedArray.BYTES_PER_ELEMENT

    /** Underlying Buffer */
    public readonly buffer: ArrayBuffer

    private readonly byteOffsetInt: int
    private readonly byteLengthInt: int
    protected readonly lengthInt: int

    /**
     * Creates an empty Uint8ClampedArray.
     */
    public constructor() {
        this(0)
    }
    public native static toUint8Clamped(val: double): int;

    /**
     * Creates an Uint8ClampedArray with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        this(length.toDouble())
    }

    /**
     * Creates an Uint8ClampedArray with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        if (length < 0 || length > (Int.MAX_VALUE / Uint8ClampedArray.BYTES_PER_ELEMENT)) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length.toInt()
        this.byteLengthInt = this.lengthInt * Uint8ClampedArray.BYTES_PER_ELEMENT
        this.byteOffsetInt = 0
        this.buffer = new ArrayBuffer(this.byteLengthInt)
    }

    /**
     * Creates an Uint8ClampedArray from FixedArray<int>
     */
    public constructor(numbers: FixedArray<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafeClamp(i, numbers[i].toInt())
        }
    }

    /**
     * Creates an Uint8ClampedArray from FixedArray<number>
     */
    public constructor(numbers: FixedArray<number>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafeClamp(i, Uint8ClampedArray.toUint8Clamped(numbers[i]))
        }
    }

    /**
     * Creates a copy of Uint8ClampedArray.
     *
     * @param other data initializer
     */
    public constructor(other: Uint8ClampedArray) {
        this.buffer = other.buffer.slice(other.byteOffset, other.byteOffset + other.byteLength) as ArrayBuffer
        this.byteLengthInt = other.byteLength
        this.lengthInt = other.length
        this.byteOffsetInt = 0
    }

    /**
     * Creates an Uint8ClampedArray with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<Number>) {
        const items: Object = elements as Object
        if (items instanceof ArrayLike) {
            const arr = reflect.internals.Types.identity_cast<Number>(items as ArrayLike<Number>)
            this.byteLengthInt = arr.length * Uint8ClampedArray.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLengthInt)
            this.byteOffsetInt = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafeClamp(i, Uint8ClampedArray.toUint8Clamped(arr.$_get(i)))
            }
        } else {
            let x = Uint8ClampedArray.from(elements)
            this.byteLengthInt = x.byteLengthInt
            this.lengthInt = x.lengthInt
            this.buffer = x.buffer
            this.byteOffsetInt = x.byteOffsetInt
        }
    }

    /**
     * Creates an Uint8ClampedArray with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Uint8ClampedArray
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Uint8ClampedArray with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Uint8ClampedArray with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Uint8ClampedArray
     */
    public constructor(buf: ArrayBuffer, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.toInt()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int = buf.getByteLength() - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.toInt()
            if (intLength > intByteLength / Uint8ClampedArray.BYTES_PER_ELEMENT) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / Uint8ClampedArray.BYTES_PER_ELEMENT
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / Uint8ClampedArray.BYTES_PER_ELEMENT) {
            intByteLength = intLength * Uint8ClampedArray.BYTES_PER_ELEMENT
        }
        this.byteLengthInt = intByteLength
        this.byteOffsetInt = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Uint8ClampedArray with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Uint8ClampedArray with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBuffer) {
        if (buf instanceof ArrayBuffer) {
            this.byteLengthInt = (buf as ArrayBuffer).getByteLength()
            if (this.byteLengthInt % Uint8ClampedArray.BYTES_PER_ELEMENT.toInt() != 0) {
               throw new RangeError("ArrayBuffer.byteLength should be multiple of int as Uint8ClampedArray.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLengthInt / Uint8ClampedArray.BYTES_PER_ELEMENT
            this.buffer = buf as ArrayBuffer
            this.byteOffsetInt = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLengthInt = arr.length * Uint8ClampedArray.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLengthInt)
            this.byteOffsetInt = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafeClamp(i, Uint8ClampedArray.toUint8Clamped(arr[i]))
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns iterator over all elements
     */
    public override $_iterator(): IterableIterator<Number> {
         return this.values()
    }

    /**
     * Returns an instance of primitive type at passed index if index is correct.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public native $_get(i: int): number

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public native $_set(index: int, val: int): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: number): void {
        this.$_set(index, Uint8ClampedArray.toUint8Clamped(val))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: int): Uint8ClampedArray {
        let arrayLength: int = this.lengthInt;
        target = normalizeIndex(target, arrayLength);
        start = normalizeIndex(start, arrayLength);
        end = normalizeIndex(asIntOrDefault(end, arrayLength), arrayLength);
        let count: int = end - start;
        if (count > (arrayLength - target)) {
            count = arrayLength - target;
        }
        if (count <= 0) {
            return this;
        }

        this.copyWithinImpl(target, start, count)
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param insert insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    private native copyWithinImpl(target: int, start: int, end: int): void

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Uint8ClampedArray.
     *
     * @param insert insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): Uint8ClampedArray {
        this.copyWithinImpl(target, 0, this.lengthInt)
        return this
    }

    /**
     * Returns an array of key, value pairs for every entry in the Uint8ClampedArray
     *
     * @returns key, value pairs for every entry in the array
     */
    public entries(): IterableIterator<[int, Number]> {
        return new Uint8ClampedArrayIteratorEntries(this)
    }

    /**
     * Fills the Uint8ClampedArray with specified value
     *
     * @param value new value
     *
     * @returns modified Uint8ClampedArray
     */
    public fill(value: int, start?: int, end?: int): Uint8ClampedArray {
        value = Uint8ClampedArray.clamp(value)
        const k = normalizeIndex(start ?? 0, this.lengthInt)
        const finalPos = normalizeIndex(end ?? this.lengthInt, this.lengthInt)
        this.fillInternal(value, k, finalPos)
        return this
    }

    /**
     * Fills the Uint8ClampedArray with specified value
     *
     * @param value new value
     *
     * @returns modified Uint8ClampedArray
     */
    public fill(value: number, start?: int, end?: int): Uint8ClampedArray {
        this.fill(Uint8ClampedArray.toUint8Clamped(value), start, end)
        return this
    }

    private final native fillInternal(value: int, start: int, end: int): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: int): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Uint8ClampedArray starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: FixedArray<int>, insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: FixedArray<int>): size of arr is greater than Uint8ClampedArray.length")
        }
        for (let i = 0; i < arr.length; i++) {
            this.setUnsafeClamp(insertPos + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Uint8ClampedArray starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: FixedArray<number>, insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: FixedArray<int>): size of arr is greater than Uint8ClampedArray.length")
        }
        for (let i = 0; i < arr.length; i++) {
            this.setUnsafeClamp(insertPos + i, Uint8ClampedArray.toUint8Clamped(arr[i]))
        }
    }

    /**
     * Copies all elements of arr to the current Uint8ClampedArray.
     *
     * @param arr array to copy data from
     */
    public set(arr: FixedArray<int>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Uint8ClampedArray.
     *
     * @param arr array to copy data from
     */
    public set(arr: FixedArray<number>): void {
        this.set(arr, 0)
    }

    private native final set(array: Array<int>): void;

    public native set(array: Uint8ClampedArray): void

    public native set(array: Uint8ClampedArray, offset: int): void

    /**
     * Copies elements from an ArrayLike object to the Uint8ClampedArray.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<number>, offset: int = 0): void {
        const insertPos = offset
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; ++i) {
            this.setUnsafeClamp(insertPos + i, Uint8ClampedArray.toUint8Clamped(array[i]))
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint8ClampedArray
     */
    public static of(...items: FixedArray<short>): Uint8ClampedArray {
        let res = new Uint8ClampedArray(items.length.toInt())
        res.ofShort(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint8ClampedArray
     */
    public static of(...items: FixedArray<int>): Uint8ClampedArray {
        let res = new Uint8ClampedArray(items.length.toInt())
        res.ofInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint8ClampedArray
     */
    public static of(...items: FixedArray<number>): Uint8ClampedArray {
        let res = new Uint8ClampedArray(items.length.toInt())
        res.ofNumber(items)
        return res
    }

    private final native ofInt(items: FixedArray<int>): void
    private final native ofNumber(items: FixedArray<number>): void
    private final native ofShort(items: FixedArray<short>): void

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint8ClampedArray
     */
    public static of(): Uint8ClampedArray {
        return new Uint8ClampedArray(0)
    }

    /**
     * Creates an array from an object of FixedArray<int>.
     *
     * @param arr An instance of the FixedArray type to convert to an array.
     *
     * @returns new Uint8ClampedArray
     */
    public static from(arr: FixedArray<int>): Uint8ClampedArray {
        let result = new Uint8ClampedArray(arr.length)
        result.ofInt(arr)
        return result
    }

    /**
     * Creates an array from a set of type std.core.Set<int>.
     *
     * @param set A set object to convert to an array.
     *
     * @returns new Uint8ClampedArray
     */
    public static from(set: Set<int>): Uint8ClampedArray {
        const length = set.size;
        const result = new Uint8ClampedArray(length)
        let iter = set.$_iterator()
        for (let i:int = 0; i < length; ++i) {
            const x = iter.next()
            if (x.done) {
                throw new AssertionError('Wrong Length')
            }
            result.setUnsafeClamp(i, x.value!.toInt())
        }
        return result
    }

    /**
     * Creates an array from an array of the same type.
     *
     * @param arr An array to convert to a new array.
     *
     * @returns new Uint8ClampedArray
     */
    public static from(arr: Uint8ClampedArray): Uint8ClampedArray {
        let result = new Uint8ClampedArray(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an object of std.core.Array<int>.
     *
     * @param arr An instance of the std.core.Array type to convert to an array.
     *
     * @returns new Uint8ClampedArray
     */
    public static from(arr: Array<int>): Uint8ClampedArray {
        let result = new Uint8ClampedArray(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @returns new Uint8ClampedArray
     */
    public static from(arr: ArrayLike<number>): Uint8ClampedArray {
        const len = arr.length;
        const result = new Uint8ClampedArray(len);
        for (let i: int = 0; i < len; ++i) {
            result.setUnsafeClamp(i, Uint8ClampedArray.toUint8Clamped(arr[i]))
        }
        return result;
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Uint8ClampedArray
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number): Uint8ClampedArray {
        let res = new Uint8ClampedArray(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new int[1]
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            const mapped = mapfn(x as T, idx[0].toDouble())
            res.setUnsafeClamp(idx[0], Uint8ClampedArray.toUint8Clamped(mapped))
            idx[0] += 1
        })
        return res
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Uint8ClampedArray
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Uint8ClampedArray {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE (templin.konstantin): This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Uint8ClampedArray(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Uint8ClampedArray(result.buffer, 0, i)
                }
                const mapped = (mapfn)!(x.value!, i)
                result.setUnsafeClamp(i, Uint8ClampedArray.toUint8Clamped(mapped))
            }
            return result
        }

        // NOTE (templin.konstantin): Create builtin array as buffer
        let temp = new Uint8ClampedArray(6)
        let index : FixedArray<int> = new int[1]
        index[0] = 0

        iteratorForEach<number>(arrayLike.$_iterator(), (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE (templin.konstantin): Progressive reallocation
                const curLength = temp.buffer.getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, temp.buffer.at(i))
                }
                temp = new Uint8ClampedArray(tb)
            }
            const mapped = (mapfn)!(x, index[0])
            temp.setUnsafeClamp(index[0], Uint8ClampedArray.toUint8Clamped(mapped))
            index[0]++
        })

        return new Uint8ClampedArray(temp.buffer, 0, index[0])
    }

    /**
     * Determines whether Uint8ClampedArray includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint8ClampedArray, false otherwise
     */
    public includes(searchElement: int, fromIndex: int): boolean {
        return this.indexOf(searchElement.toInt(), fromIndex) != -1
    }

    /**
     * Determines whether Uint8ClampedArray includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint8ClampedArray, false otherwise
     */
    public includes(searchElement: int): boolean {
        return this.indexOf(searchElement.toInt(), 0) != -1
    }

    /**
     * Determines whether Uint8ClampedArray includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint8ClampedArray, false otherwise
     */
    public includes(searchElement: number, fromIndex?: int): boolean {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in Uint8ClampedArray.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int): int {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Uint8ClampedArray.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int, fromIndex: int): int {
        return this.indexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the first occurrence of a value in Uint8ClampedArray.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex?: int): int {
            return this.indexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native indexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native indexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Converts all elements of an array to strings and joins them using the specified separator.
     *
     * @param separator - separates one element of an array from the next in the resulting String.
     *
     * @returns joined representation
     */
    private final native joinInternal(separator: String): string;

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param separator A string used to separate one element of an array from the next in the
     * resulting String. If omitted, the array elements are separated with a comma
     *
     * @returns joined representation
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.joinInternal(",")
        }
        return this.joinInternal(separator)
    }

    /**
     * Returns an list of keys in Uint8ClampedArray
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<int> {
        return new Uint8ClampedArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint8ClampedArray.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint8ClampedArray.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint8ClampedArray.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int, fromIndex: int): int {
        return this.lastIndexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint8ClampedArray.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: int | undefined): int {
            return this.lastIndexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native lastIndexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native lastIndexOfImpl(searchElement: number, fromIndex: int): int

   /**
    * Creates a new Uint8ClampedArray using initializer
    *
    * @param data initializer
    *
    * @returns a new Uint8ClampedArray from data
    */
    public of(...data: FixedArray<number>): Uint8ClampedArray {
        throw new Error("Uint8ClampedArray.of: not implemented")
    }

    /**
     * Creates a new Uint8ClampedArray using reversed data from the current one
     *
     * @returns a new Uint8ClampedArray using reversed data from the current one
     */
    public native reverse(): Uint8ClampedArray

    /**
     * Creates a slice of current Uint8ClampedArray using range [begin, end]
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint8ClampedArray with elements of current Uint8ClampedArray[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: int, end?: int): Uint8ClampedArray {
        return this.sliceFromTo(begin ?? 0, end ?? this.lengthInt)
    }

    private sliceFromTo(begin: int, end: int): Uint8ClampedArray {
        const relStart = normalizeIndex(begin, this.lengthInt)
        const relEnd = normalizeIndex(end, this.lengthInt)
        let buf: ArrayBuffer = this.buffer.slice(relStart * this.BYTES_PER_ELEMENT + this.byteOffsetInt, relEnd * this.BYTES_PER_ELEMENT + this.byteOffsetInt)
        return new Uint8ClampedArray(buf)
    }

    /**
     * Creates a slice of current Uint8ClampedArray using range [begin, this.lengthInt].
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint8ClampedArray with elements of current Uint8ClampedArray[begin, this.lengthInt]
     */
    public slice(begin: int): Uint8ClampedArray {
        return this.sliceFromTo(begin, this.lengthInt)
    }


    /**
     * Sorts in-place by numeric value in ascending order.
     *
     * @returns sorted Uint8ClampedArray
     */
    public native sort(): this;

    /**
     * Sorts in-place
     *
     * @param compareFn comparator _  used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Uint8ClampedArray
     */
    public sort(compareFn?: (a: number, b: number) => number): this {
        if (compareFn == undefined) {
            this.sort()
            return this
        }

        let cmp = (l: int, r: int): number => {
            return compareFn!(l, r)
        }
        const MAX_SHORT_LENGTH = 24
        if (this.lengthInt > MAX_SHORT_LENGTH) {
            let arr: FixedArray<int> = new int[this.lengthInt]
            for (let i = 0; i < this.lengthInt; ++i) {
                arr[i] = this.getUnsafe(i)
            }
            arr = mergeSort(arr, cmp)
            for (let i = 0; i < arr.length; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let buffer: FixedArray<Int> = new Int[this.lengthInt]
            for (let i = 0; i < this.lengthInt; ++i) {
                buffer[i] = this.getUnsafe(i)
            }
            arr_sort_stable(buffer, 0, buffer.length as int, cmp)
            for (let i = 0; i < buffer.length; ++i) {
                this.setUnsafe(i, buffer[i])
            }
        }
        return this
    }

    /**
     * Creates a Uint8ClampedArray with the same underlying Buffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint8ClampedArray with the same underlying Buffer
     */
    public subarray(begin?: int, end?: int): Uint8ClampedArray {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin ?? 0, len)
        const relEnd = normalizeIndex(end ?? this.lengthInt, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Uint8ClampedArray(this.buffer, relStart * Uint8ClampedArray.BYTES_PER_ELEMENT + this.byteOffsetInt, count)
    }

    /**
     * Converts Uint8ClampedArray to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Uint8ClampedArray.toLocaleString: not implemented")
    }

    /**
     * Converts Uint8ClampedArray to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Uint8ClampedArray to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append((this.getUnsafe(i).toDouble()).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append((this.getUnsafe(this.lengthInt - 1).toDouble()).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Uint8ClampedArray {
        let newArray = new Uint8ClampedArray(this.lengthInt)
        if (this.lengthInt > 0) {
            Uint8ClampedArray.reverseCopyBuffer(newArray.buffer, this.buffer, this.byteOffset, this.lengthInt);
        }
        return newArray
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Uint8ClampedArray {
        return new Uint8ClampedArray(this).sort()
    }

    /**
     * Returns a string representation of the Uint8ClampedArray
     *
     * @returns a string representation of the Uint8ClampedArray
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<Number> {
         return new Uint8ClampedArrayIterator(this)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint8ClampedArray with replaced value on index
     */
    public with(index: int, value: int): Uint8ClampedArray {
        let res = new Uint8ClampedArray(this)
        res.setUnsafeClamp(index, value)
        return res
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint8ClampedArray with replaced value on index
     */
    public with(index: int, value: number): Uint8ClampedArray {
        let res = new Uint8ClampedArray(this)
        res.setUnsafeClamp(index, value.toInt())
        return res
    }

    /// === with element lambda functions ===

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: int, array: Uint8ClampedArray) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Uint8ClampedArray) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Uint8ClampedArray) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = this.$_get(0).toDouble()
        for (let i = 1; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Uint8ClampedArray) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Uint8ClampedArray) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = this.$_get(this.lengthInt - 1).toDouble()
        for (let i = this.lengthInt - 2; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Creates a new Uint8ClampedArray using fn(arr[i]) over all elements of current Uint8ClampedArray.
     *
     * @param fn a function to apply for each element of current Uint8ClampedArray
     *
     * @returns a new Uint8ClampedArray where for each element from current Uint8ClampedArray fn was applied
     */
    public map(fn: (val: number, index: int, array: Uint8ClampedArray) => number): Uint8ClampedArray {
        let resBuf = new ArrayBuffer(this.lengthInt * Uint8ClampedArray.BYTES_PER_ELEMENT)
        let res = new Uint8ClampedArray(resBuf)
        for (let i = 0; i < this.lengthInt; i++) {
            const fnRes = fn(this.getUnsafe(i).toDouble(), i, this)
            res.setUnsafeClamp(i, round(fnRes).toInt())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: int, array: Uint8ClampedArray) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (!predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Creates a new Uint8ClampedArray from current Uint8ClampedArray based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8ClampedArray with elements from current Uint8ClampedArray that satisfy condition fn
     */
    public filter(fn: (val: number, index: int, array: Uint8ClampedArray) => boolean): Uint8ClampedArray {
        let markers : FixedArray<boolean> = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; i++) {
            markers[i] = fn(this.getUnsafe(i).toDouble(), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let res = new Uint8ClampedArray(resLen)
        for (let i = 0, j = 0; i < this.lengthInt; i++) {
            if (markers[i]) {
                res.setUnsafe(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: int, array: Uint8ClampedArray) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; i++) {
            let val = this.getUnsafe(i).toDouble()
            if (predicate(val, i, this)) {
                return val
            }
        }
        return undefined
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns int
     */
    public findIndex(predicate: (value: number, index: int, obj: Uint8ClampedArray) => boolean): int {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int, array: Uint8ClampedArray) => boolean): number {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            let val = this.getUnsafe(i).toDouble()
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint8ClampedArray.findLast: not implemented if an element was not found")
    }

    /**
     * Finds an index of the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int, array: Uint8ClampedArray) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            if (fn(this.getUnsafe(i).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Performs the specified action for each element in Uint8ClampedArray
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: int, array: Uint8ClampedArray) => void): void {
        for (let i = 0; i < this.lengthInt; i++) {
            callbackfn(this.getUnsafe(i).toDouble(), i, this)
        }
    }

    /**
     * Returns the object itself
     *
     * @returns Uint8ClampedArray
     */
    public valueOf(): Uint8ClampedArray {
        return this
    }

    /** Byte offset within the underlying Buffer */
    public get byteOffset(): int {
        return this.byteOffsetInt
    }

    /** Number of bytes used */
    public get byteLength(): int {
        return this.byteLengthInt
    }

    /** Number of int stored in Uint8ClampedArray */
    public get length(): int {
        return this.lengthInt
    }

    /** String \"Uint8ClampedArray\" */
    public readonly name = "Uint8ClampedArray"

    private static native reverseCopyBuffer(dstBuf: ArrayBuffer, srcBuf: ArrayBuffer, startPos: int, length: int): void

    private static clamp(val: int): int {
        if (val > 255) {
            val = 255
        } else if (val < 0) {
            val = 0
        }
        return val
    }

    private setUnsafeClamp(insertPos: int, val: int): void {
        val = Uint8ClampedArray.clamp(val)
        this.setUnsafe(insertPos, val)
    }

    private final native getUnsafe(index: int): int

    private setUnsafe(index: int, val: int): void {
        const BPE = Uint8ClampedArray.BYTES_PER_ELEMENT.toInt()
        let byteIndex = index * BPE + this.byteOffsetInt
        let buf = this.buffer
        buf.set(byteIndex, val.toByte())
    }
}


class Uint8ArrayIteratorKeys implements IterableIterator<int> {
    private length: int = 0
    private idx: int = 0

    constructor(parent: Uint8Array) {
        this.length = parent.length
    }

    public override $_iterator(): IterableIterator<int> {
        return this
    }

    override next(): IteratorResult<int> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(false, this.idx++)
    }
}

class Uint8ArrayIterator implements IterableIterator<Number> {
    private parent: Uint8Array
    private idx: int = 0

    constructor(parent: Uint8Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Uint8ArrayIteratorEntries implements IterableIterator<[int, Number]> {
    private parent: Uint8Array
    private idx: int = 0

    constructor(parent: Uint8Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[int, Number]> {
        return this
    }

    override next(): IteratorResult<[int, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<[int, Number]>()
        }
        return new IteratorResult<[int, Number]>(
            false,
            [this.idx, new Number(this.parent[this.idx++])]
        )
    }
}

/**
 * JS Uint8Array API-compatible class
 */
export final class Uint8Array implements Iterable<Number>, ArrayLike<Number> {
    public static readonly BYTES_PER_ELEMENT: int = 1
    public readonly BYTES_PER_ELEMENT: int = Uint8Array.BYTES_PER_ELEMENT

    /** Underlying Buffer */
    public readonly buffer: ArrayBuffer

    private readonly byteOffsetInt: int
    private readonly byteLengthInt: int
    protected readonly lengthInt: int

    /**
     * Creates an empty Uint8Array.
     */
    public constructor() {
        this(0)
    }

    /**
     * Creates an Uint8Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        this(length.toDouble())
    }

    /**
     * Creates an Uint8Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        if (length < 0 || length > (Int.MAX_VALUE / Uint8Array.BYTES_PER_ELEMENT)) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length.toInt()
        this.byteLengthInt = this.lengthInt * Uint8Array.BYTES_PER_ELEMENT
        this.byteOffsetInt = 0
        this.buffer = new ArrayBuffer(this.byteLengthInt)
    }

    /**
     * Creates an Uint8Array from FixedArray<int>
     */
    public constructor(numbers: FixedArray<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafeClamp(i, numbers[i].toInt())
        }
    }

    /**
     * Creates an Uint8Array from FixedArray<number>
     */
    public constructor(numbers: FixedArray<number>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, Uint8Array.doubleToInt(numbers[i]))
        }
    }

    /**
     * Creates a copy of Uint8Array.
     *
     * @param other data initializer
     */
    public constructor(other: Uint8Array) {
        this.buffer = other.buffer.slice(other.byteOffset, other.byteOffset + other.byteLength) as ArrayBuffer
        this.byteLengthInt = other.byteLength
        this.lengthInt = other.length
        this.byteOffsetInt = 0
    }

    /**
     * Creates an Uint8Array with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<Number>) {
        const items: Object = elements as Object
        if (items instanceof ArrayLike) {
            const arr = reflect.internals.Types.identity_cast<Number>(items as ArrayLike<Number>)
            this.byteLengthInt = arr.length * Uint8Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLengthInt)
            this.byteOffsetInt = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafeClamp(i, Uint8Array.doubleToInt(arr.$_get(i)));
            }
        } else {
            let x = Uint8Array.from(elements)
            this.byteLengthInt = x.byteLengthInt
            this.lengthInt = x.lengthInt
            this.buffer = x.buffer
            this.byteOffsetInt = x.byteOffsetInt
        }
    }
    private static native doubleToInt(d: double): Int;

    /**
     * Creates an Uint8Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Uint8Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Uint8Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Uint8Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Uint8Array
     */
    public constructor(buf: ArrayBuffer, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.toInt()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int = buf.getByteLength() - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.toInt()
            if (intLength > intByteLength / Uint8Array.BYTES_PER_ELEMENT) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / Uint8Array.BYTES_PER_ELEMENT
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / Uint8Array.BYTES_PER_ELEMENT) {
            intByteLength = intLength * Uint8Array.BYTES_PER_ELEMENT
        }
        this.byteLengthInt = intByteLength
        this.byteOffsetInt = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Uint8Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Uint8Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBuffer) {
        if (buf instanceof ArrayBuffer) {
            this.byteLengthInt = (buf as ArrayBuffer).getByteLength()
            if (this.byteLengthInt % Uint8Array.BYTES_PER_ELEMENT.toInt() != 0) {
               throw new RangeError("ArrayBuffer.byteLength should be multiple of int as Uint8Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLengthInt / Uint8Array.BYTES_PER_ELEMENT
            this.buffer = buf as ArrayBuffer
            this.byteOffsetInt = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLengthInt = arr.length * Uint8Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLengthInt)
            this.byteOffsetInt = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, Uint8Array.doubleToInt(arr[i]))
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns iterator over all elements
     */
    public override $_iterator(): IterableIterator<Number> {
         return this.values()
    }

    /**
     * Returns an instance of primitive type at passed index if index is correct.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public native $_get(i: int): number

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public native $_set(index: int, val: int): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: number): void {
        this.$_set(index, Uint8Array.doubleToInt(val))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: int): Uint8Array {
        let arrayLength: int = this.lengthInt;
        target = normalizeIndex(target, arrayLength);
        start = normalizeIndex(start, arrayLength);
        end = normalizeIndex(asIntOrDefault(end, arrayLength), arrayLength);
        let count: int = end - start;
        if (count > (arrayLength - target)) {
            count = arrayLength - target;
        }
        if (count <= 0) {
            return this;
        }

        this.copyWithinImpl(target, start, count)
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param insert insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    private native copyWithinImpl(target: int, start: int, end: int): void

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Uint8Array.
     *
     * @param insert insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): Uint8Array {
        this.copyWithinImpl(target, 0, this.lengthInt)
        return this
    }

    /**
     * Returns an array of key, value pairs for every entry in the Uint8Array
     *
     * @returns key, value pairs for every entry in the array
     */
    public entries(): IterableIterator<[int, Number]> {
        return new Uint8ArrayIteratorEntries(this)
    }

    /**
     * Fills the Uint8Array with specified value
     *
     * @param value new value
     *
     * @returns modified Uint8Array
     */
    public fill(value: int, start?: int, end?: int): Uint8Array {
        const k = normalizeIndex(start ?? 0, this.lengthInt)
        const finalPos = normalizeIndex(end ?? this.lengthInt, this.lengthInt)
        this.fillInternal(value, k, finalPos)
        return this
    }

    /**
     * Fills the Uint8Array with specified value
     *
     * @param value new value
     *
     * @returns modified Uint8Array
     */
    public fill(value: number, start?: int, end?: int): Uint8Array {
        this.fill(Uint8Array.doubleToInt(value), start, end)
        return this
    }

    private final native fillInternal(value: int, start: int, end: int): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: int): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Uint8Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: FixedArray<int>, insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: FixedArray<int>): size of arr is greater than Uint8Array.length")
        }
        for (let i = 0; i < arr.length; i++) {
            this.setUnsafeClamp(insertPos + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Uint8Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: FixedArray<number>, insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: FixedArray<int>): size of arr is greater than Uint8Array.length")
        }
        for (let i = 0; i < arr.length; i++) {
            this.setUnsafe(insertPos + i, Uint8Array.doubleToInt(arr[i]))
        }
    }

    /**
     * Copies all elements of arr to the current Uint8Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: FixedArray<int>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Uint8Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: FixedArray<number>): void {
        this.set(arr, 0)
    }

    private native final set(array: Array<int>): void;

    public native set(array: Uint8Array): void
    private native final set(array: Int8Array): void

    public native set(array: Uint8Array, offset: int): void

    /**
     * Copies elements from an ArrayLike object to the Uint8Array.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<number>, offset: int = 0): void {
        const insertPos = offset
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; ++i) {
            this.setUnsafe(insertPos + i, Uint8Array.doubleToInt(array[i]))
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint8Array
     */
    public static of(...items: FixedArray<short>): Uint8Array {
        let res = new Uint8Array(items.length.toInt())
        res.ofShort(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint8Array
     */
    public static of(...items: FixedArray<int>): Uint8Array {
        let res = new Uint8Array(items.length.toInt())
        res.ofInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint8Array
     */
    public static of(...items: FixedArray<number>): Uint8Array {
        let res = new Uint8Array(items.length.toInt())
        res.ofNumber(items)
        return res
    }

    private final native ofInt(items: FixedArray<int>): void
    private final native ofNumber(items: FixedArray<number>): void
    private final native ofShort(items: FixedArray<short>): void

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint8Array
     */
    public static of(): Uint8Array {
        return new Uint8Array(0)
    }

    /**
     * Creates an array from an object of FixedArray<int>.
     *
     * @param arr An instance of the FixedArray type to convert to an array.
     *
     * @returns new Uint8Array
     */
    public static from(arr: FixedArray<int>): Uint8Array {
        let result = new Uint8Array(arr.length)
        result.ofInt(arr)
        return result
    }

    /**
     * Creates an array from a set of type std.core.Set<int>.
     *
     * @param set A set object to convert to an array.
     *
     * @returns new Uint8Array
     */
    public static from(set: Set<int>): Uint8Array {
        const length = set.size;
        const result = new Uint8Array(length)
        let iter = set.$_iterator()
        for (let i:int = 0; i < length; ++i) {
            const x = iter.next()
            if (x.done) {
                throw new AssertionError('Wrong Length')
            }
            result.setUnsafeClamp(i, x.value!.toInt())
        }
        return result
    }

    /**
     * Creates an array from an array of the same type.
     *
     * @param arr An array to convert to a new array.
     *
     * @returns new Uint8Array
     */
    public static from(arr: Uint8Array): Uint8Array {
        let result = new Uint8Array(arr.length)
        result.set(arr)
        return result
    }
    /**
     * Creates an array from an array of the same up to the signess type.
     *
     * @param arr An array to convert to a new array.
     *
     * @returns new Uint8Array
     */
    public static from(arr: Int8Array): Uint8Array {
        let result = new Uint8Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an object of std.core.Array<int>.
     *
     * @param arr An instance of the std.core.Array type to convert to an array.
     *
     * @returns new Uint8Array
     */
    public static from(arr: Array<int>): Uint8Array {
        let result = new Uint8Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @returns new Uint8Array
     */
    public static from(arr: ArrayLike<number>): Uint8Array {
        return Uint8Array.from<number>(
            arr,
            (x: number, _k: number): number => x
        );
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Uint8Array
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number): Uint8Array {
        let res = new Uint8Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new int[1]
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            const mapped = mapfn(x as T, idx[0].toDouble())
            res.setUnsafe(idx[0], Uint8Array.doubleToInt(mapped))
            idx[0] += 1
        })
        return res
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Uint8Array
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Uint8Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE (templin.konstantin): This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Uint8Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Uint8Array(result.buffer, 0, i)
                }
                const mapped = (mapfn)!(x.value!, i)
                result.setUnsafe(i, Uint8Array.doubleToInt(mapped))
            }
            return result
        }

        // NOTE (templin.konstantin): Create builtin array as buffer
        let temp = new Uint8Array(6)
        let index : FixedArray<int> = new int[1]
        index[0] = 0

        iteratorForEach<number>(arrayLike.$_iterator(), (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE (templin.konstantin): Progressive reallocation
                const curLength = temp.buffer.getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, temp.buffer.at(i))
                }
                temp = new Uint8Array(tb)
            }
            const mapped = (mapfn)!(x, index[0])
            temp.setUnsafe(index[0], Uint8Array.doubleToInt(mapped))
            index[0]++
        })

        return new Uint8Array(temp.buffer, 0, index[0])
    }

    /**
     * Determines whether Uint8Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint8Array, false otherwise
     */
    public includes(searchElement: int, fromIndex: int): boolean {
        return this.indexOf(searchElement.toInt(), fromIndex) != -1
    }

    /**
     * Determines whether Uint8Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint8Array, false otherwise
     */
    public includes(searchElement: int): boolean {
        return this.indexOf(searchElement.toInt(), 0) != -1
    }

    /**
     * Determines whether Uint8Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint8Array, false otherwise
     */
    public includes(searchElement: number, fromIndex?: int): boolean {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in Uint8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int): int {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Uint8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int, fromIndex: int): int {
        return this.indexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the first occurrence of a value in Uint8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex?: int): int {
            return this.indexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native indexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native indexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Converts all elements of an array to strings and joins them using the specified separator.
     *
     * @param separator - separates one element of an array from the next in the resulting String.
     *
     * @returns joined representation
     */
    private final native joinInternal(separator: String): string;

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param separator A string used to separate one element of an array from the next in the
     * resulting String. If omitted, the array elements are separated with a comma
     *
     * @returns joined representation
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.joinInternal(",")
        }
        return this.joinInternal(separator)
    }

    /**
     * Returns an list of keys in Uint8Array
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<int> {
        return new Uint8ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int, fromIndex: int): int {
        return this.lastIndexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: int | undefined): int {
            return this.lastIndexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native lastIndexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native lastIndexOfImpl(searchElement: number, fromIndex: int): int

   /**
    * Creates a new Uint8Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Uint8Array from data
    */
    public of(...data: FixedArray<number>): Uint8Array {
        throw new Error("Uint8Array.of: not implemented")
    }

    /**
     * Creates a new Uint8Array using reversed data from the current one
     *
     * @returns a new Uint8Array using reversed data from the current one
     */
    public native reverse(): Uint8Array

    /**
     * Creates a slice of current Uint8Array using range [begin, end]
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint8Array with elements of current Uint8Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: int, end?: int): Uint8Array {
        return this.sliceFromTo(begin ?? 0, end ?? this.lengthInt)
    }

    private sliceFromTo(begin: int, end: int): Uint8Array {
        const relStart = normalizeIndex(begin, this.lengthInt)
        const relEnd = normalizeIndex(end, this.lengthInt)
        let buf: ArrayBuffer = this.buffer.slice(relStart * this.BYTES_PER_ELEMENT + this.byteOffsetInt, relEnd * this.BYTES_PER_ELEMENT + this.byteOffsetInt)
        return new Uint8Array(buf)
    }

    /**
     * Creates a slice of current Uint8Array using range [begin, this.lengthInt].
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint8Array with elements of current Uint8Array[begin, this.lengthInt]
     */
    public slice(begin: int): Uint8Array {
        return this.sliceFromTo(begin, this.lengthInt)
    }


    /**
     * Sorts in-place by numeric value in ascending order.
     *
     * @returns sorted Uint8Array
     */
    public native sort(): this;

    /**
     * Sorts in-place
     *
     * @param compareFn comparator _  used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Uint8Array
     */
    public sort(compareFn?: (a: number, b: number) => number): this {
        if (compareFn == undefined) {
            this.sort()
            return this
        }

        let cmp = (l: int, r: int): number => {
            return compareFn!(l, r)
        }
        const MAX_SHORT_LENGTH = 24
        if (this.lengthInt > MAX_SHORT_LENGTH) {
            let arr: FixedArray<int> = new int[this.lengthInt]
            for (let i = 0; i < this.lengthInt; ++i) {
                arr[i] = this.getUnsafe(i)
            }
            arr = mergeSort(arr, cmp)
            for (let i = 0; i < arr.length; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let buffer: FixedArray<Int> = new Int[this.lengthInt]
            for (let i = 0; i < this.lengthInt; ++i) {
                buffer[i] = this.getUnsafe(i)
            }
            arr_sort_stable(buffer, 0, buffer.length as int, cmp)
            for (let i = 0; i < buffer.length; ++i) {
                this.setUnsafe(i, buffer[i])
            }
        }
        return this
    }

    /**
     * Creates a Uint8Array with the same underlying Buffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint8Array with the same underlying Buffer
     */
    public subarray(begin?: int, end?: int): Uint8Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin ?? 0, len)
        const relEnd = normalizeIndex(end ?? this.lengthInt, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Uint8Array(this.buffer, relStart * Uint8Array.BYTES_PER_ELEMENT + this.byteOffsetInt, count)
    }

    /**
     * Converts Uint8Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Uint8Array.toLocaleString: not implemented")
    }

    /**
     * Converts Uint8Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Uint8Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append((this.getUnsafe(i).toDouble()).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append((this.getUnsafe(this.lengthInt - 1).toDouble()).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Uint8Array {
        let newArray = new Uint8Array(this.lengthInt)
        if (this.lengthInt > 0) {
            Uint8Array.reverseCopyBuffer(newArray.buffer, this.buffer, this.byteOffset, this.lengthInt);
        }
        return newArray
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Uint8Array {
        return new Uint8Array(this).sort()
    }

    /**
     * Returns a string representation of the Uint8Array
     *
     * @returns a string representation of the Uint8Array
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<Number> {
         return new Uint8ArrayIterator(this)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint8Array with replaced value on index
     */
    public with(index: int, value: int): Uint8Array {
        let res = new Uint8Array(this)
        res.setUnsafeClamp(index, value)
        return res
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint8Array with replaced value on index
     */
    public with(index: int, value: number): Uint8Array {
        let res = new Uint8Array(this)
        res.setUnsafeClamp(index, value.toInt())
        return res
    }

    /// === with element lambda functions ===

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: int, array: Uint8Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Uint8Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Uint8Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = this.$_get(0).toDouble()
        for (let i = 1; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Uint8Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Uint8Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = this.$_get(this.lengthInt - 1).toDouble()
        for (let i = this.lengthInt - 2; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Creates a new Uint8Array using fn(arr[i]) over all elements of current Uint8Array.
     *
     * @param fn a function to apply for each element of current Uint8Array
     *
     * @returns a new Uint8Array where for each element from current Uint8Array fn was applied
     */
    public map(fn: (val: number, index: int, array: Uint8Array) => number): Uint8Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Uint8Array.BYTES_PER_ELEMENT)
        let res = new Uint8Array(resBuf)
        for (let i = 0; i < this.lengthInt; i++) {
            const fnRes = fn(this.getUnsafe(i).toDouble(), i, this)
            res.setUnsafeClamp(i, fnRes.toInt())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: int, array: Uint8Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (!predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Creates a new Uint8Array from current Uint8Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8Array with elements from current Uint8Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: int, array: Uint8Array) => boolean): Uint8Array {
        let markers : FixedArray<boolean> = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; i++) {
            markers[i] = fn(this.getUnsafe(i).toDouble(), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let res = new Uint8Array(resLen)
        for (let i = 0, j = 0; i < this.lengthInt; i++) {
            if (markers[i]) {
                res.setUnsafe(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: int, array: Uint8Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; i++) {
            let val = this.getUnsafe(i).toDouble()
            if (predicate(val, i, this)) {
                return val
            }
        }
        return undefined
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns int
     */
    public findIndex(predicate: (value: number, index: int, obj: Uint8Array) => boolean): int {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int, array: Uint8Array) => boolean): number {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            let val = this.getUnsafe(i).toDouble()
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint8Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds an index of the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int, array: Uint8Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            if (fn(this.getUnsafe(i).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Performs the specified action for each element in Uint8Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: int, array: Uint8Array) => void): void {
        for (let i = 0; i < this.lengthInt; i++) {
            callbackfn(this.getUnsafe(i).toDouble(), i, this)
        }
    }

    /**
     * Returns the object itself
     *
     * @returns Uint8Array
     */
    public valueOf(): Uint8Array {
        return this
    }

    /** Byte offset within the underlying Buffer */
    public get byteOffset(): int {
        return this.byteOffsetInt
    }

    /** Number of bytes used */
    public get byteLength(): int {
        return this.byteLengthInt
    }

    /** Number of int stored in Uint8Array */
    public get length(): int {
        return this.lengthInt
    }

    /** String \"Uint8Array\" */
    public readonly name = "Uint8Array"

    private static native reverseCopyBuffer(dstBuf: ArrayBuffer, srcBuf: ArrayBuffer, startPos: int, length: int): void

    private static clamp(val: int): int {
        return val
    }

    private setUnsafeClamp(insertPos: int, val: int): void {
        this.setUnsafe(insertPos, val)
    }

    private final native getUnsafe(index: int): int

    private setUnsafe(index: int, val: int): void {
        const BPE = Uint8Array.BYTES_PER_ELEMENT.toInt()
        let byteIndex = index * BPE + this.byteOffsetInt
        let buf = this.buffer
        buf.set(byteIndex, val.toByte())
    }
}


class Uint16ArrayIteratorKeys implements IterableIterator<int> {
    private length: int = 0
    private idx: int = 0

    constructor(parent: Uint16Array) {
        this.length = parent.length
    }

    public override $_iterator(): IterableIterator<int> {
        return this
    }

    override next(): IteratorResult<int> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(false, this.idx++)
    }
}

class Uint16ArrayIterator implements IterableIterator<Number> {
    private parent: Uint16Array
    private idx: int = 0

    constructor(parent: Uint16Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Uint16ArrayIteratorEntries implements IterableIterator<[int, Number]> {
    private parent: Uint16Array
    private idx: int = 0

    constructor(parent: Uint16Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[int, Number]> {
        return this
    }

    override next(): IteratorResult<[int, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<[int, Number]>()
        }
        return new IteratorResult<[int, Number]>(
            false,
            [this.idx, new Number(this.parent[this.idx++])]
        )
    }
}

/**
 * JS Uint16Array API-compatible class
 */
export final class Uint16Array implements Iterable<Number>, ArrayLike<Number> {
    public static readonly BYTES_PER_ELEMENT: int = 2
    public readonly BYTES_PER_ELEMENT: int = Uint16Array.BYTES_PER_ELEMENT

    /** Underlying Buffer */
    public readonly buffer: ArrayBuffer

    private readonly byteOffsetInt: int
    private readonly byteLengthInt: int
    protected readonly lengthInt: int

    /**
     * Creates an empty Uint16Array.
     */
    public constructor() {
        this(0)
    }

    /**
     * Creates an Uint16Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        this(length.toDouble())
    }

    /**
     * Creates an Uint16Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        if (length < 0 || length > (Int.MAX_VALUE / Uint16Array.BYTES_PER_ELEMENT)) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length.toInt()
        this.byteLengthInt = this.lengthInt * Uint16Array.BYTES_PER_ELEMENT
        this.byteOffsetInt = 0
        this.buffer = new ArrayBuffer(this.byteLengthInt)
    }

    /**
     * Creates an Uint16Array from FixedArray<int>
     */
    public constructor(numbers: FixedArray<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafeClamp(i, numbers[i].toInt())
        }
    }

    /**
     * Creates an Uint16Array from FixedArray<number>
     */
    public constructor(numbers: FixedArray<number>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, Uint16Array.doubleToInt(numbers[i]))
        }
    }

    /**
     * Creates a copy of Uint16Array.
     *
     * @param other data initializer
     */
    public constructor(other: Uint16Array) {
        this.buffer = other.buffer.slice(other.byteOffset, other.byteOffset + other.byteLength) as ArrayBuffer
        this.byteLengthInt = other.byteLength
        this.lengthInt = other.length
        this.byteOffsetInt = 0
    }

    /**
     * Creates an Uint16Array with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<Number>) {
        const items: Object = elements as Object
        if (items instanceof ArrayLike) {
            const arr = reflect.internals.Types.identity_cast<Number>(items as ArrayLike<Number>)
            this.byteLengthInt = arr.length * Uint16Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLengthInt)
            this.byteOffsetInt = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafeClamp(i, Uint16Array.doubleToInt(arr.$_get(i)));
            }
        } else {
            let x = Uint16Array.from(elements)
            this.byteLengthInt = x.byteLengthInt
            this.lengthInt = x.lengthInt
            this.buffer = x.buffer
            this.byteOffsetInt = x.byteOffsetInt
        }
    }
    private static native doubleToInt(d: double): Int;

    /**
     * Creates an Uint16Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Uint16Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Uint16Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Uint16Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Uint16Array
     */
    public constructor(buf: ArrayBuffer, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.toInt()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int = buf.getByteLength() - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteOffset % Uint16Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 2 as Uint16Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.toInt()
            if (intLength > intByteLength / Uint16Array.BYTES_PER_ELEMENT) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / Uint16Array.BYTES_PER_ELEMENT
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / Uint16Array.BYTES_PER_ELEMENT) {
            intByteLength = intLength * Uint16Array.BYTES_PER_ELEMENT
        }
        this.byteLengthInt = intByteLength
        this.byteOffsetInt = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Uint16Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Uint16Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBuffer) {
        if (buf instanceof ArrayBuffer) {
            this.byteLengthInt = (buf as ArrayBuffer).getByteLength()
            if (this.byteLengthInt % Uint16Array.BYTES_PER_ELEMENT.toInt() != 0) {
               throw new RangeError("ArrayBuffer.byteLength should be multiple of int as Uint16Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLengthInt / Uint16Array.BYTES_PER_ELEMENT
            this.buffer = buf as ArrayBuffer
            this.byteOffsetInt = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLengthInt = arr.length * Uint16Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLengthInt)
            this.byteOffsetInt = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, Uint16Array.doubleToInt(arr[i]))
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns iterator over all elements
     */
    public override $_iterator(): IterableIterator<Number> {
         return this.values()
    }

    /**
     * Returns an instance of primitive type at passed index if index is correct.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public native $_get(i: int): number

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public native $_set(index: int, val: int): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: number): void {
        this.$_set(index, Uint16Array.doubleToInt(val))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: int): Uint16Array {
        let arrayLength: int = this.lengthInt;
        target = normalizeIndex(target, arrayLength);
        start = normalizeIndex(start, arrayLength);
        end = normalizeIndex(asIntOrDefault(end, arrayLength), arrayLength);
        let count: int = end - start;
        if (count > (arrayLength - target)) {
            count = arrayLength - target;
        }
        if (count <= 0) {
            return this;
        }

        this.copyWithinImpl(target, start, count)
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param insert insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    private native copyWithinImpl(target: int, start: int, end: int): void

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Uint16Array.
     *
     * @param insert insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): Uint16Array {
        this.copyWithinImpl(target, 0, this.lengthInt)
        return this
    }

    /**
     * Returns an array of key, value pairs for every entry in the Uint16Array
     *
     * @returns key, value pairs for every entry in the array
     */
    public entries(): IterableIterator<[int, Number]> {
        return new Uint16ArrayIteratorEntries(this)
    }

    /**
     * Fills the Uint16Array with specified value
     *
     * @param value new value
     *
     * @returns modified Uint16Array
     */
    public fill(value: int, start?: int, end?: int): Uint16Array {
        const k = normalizeIndex(start ?? 0, this.lengthInt)
        const finalPos = normalizeIndex(end ?? this.lengthInt, this.lengthInt)
        this.fillInternal(value, k, finalPos)
        return this
    }

    /**
     * Fills the Uint16Array with specified value
     *
     * @param value new value
     *
     * @returns modified Uint16Array
     */
    public fill(value: number, start?: int, end?: int): Uint16Array {
        this.fill(Uint16Array.doubleToInt(value), start, end)
        return this
    }

    private final native fillInternal(value: int, start: int, end: int): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: int): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Uint16Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: FixedArray<int>, insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: FixedArray<int>): size of arr is greater than Uint16Array.length")
        }
        for (let i = 0; i < arr.length; i++) {
            this.setUnsafeClamp(insertPos + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Uint16Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: FixedArray<number>, insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: FixedArray<int>): size of arr is greater than Uint16Array.length")
        }
        for (let i = 0; i < arr.length; i++) {
            this.setUnsafe(insertPos + i, Uint16Array.doubleToInt(arr[i]))
        }
    }

    /**
     * Copies all elements of arr to the current Uint16Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: FixedArray<int>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Uint16Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: FixedArray<number>): void {
        this.set(arr, 0)
    }

    private native final set(array: Array<int>): void;

    public native set(array: Uint16Array): void
    private native final set(array: Int16Array): void

    public native set(array: Uint16Array, offset: int): void

    /**
     * Copies elements from an ArrayLike object to the Uint16Array.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<number>, offset: int = 0): void {
        const insertPos = offset
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; ++i) {
            this.setUnsafe(insertPos + i, Uint16Array.doubleToInt(array[i]))
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint16Array
     */
    public static of(...items: FixedArray<int>): Uint16Array {
        let res = new Uint16Array(items.length.toInt())
        res.ofInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint16Array
     */
    public static of(...items: FixedArray<number>): Uint16Array {
        let res = new Uint16Array(items.length.toInt())
        res.ofNumber(items)
        return res
    }

    private final native ofInt(items: FixedArray<int>): void
    private final native ofNumber(items: FixedArray<number>): void

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint16Array
     */
    public static of(): Uint16Array {
        return new Uint16Array(0)
    }

    /**
     * Creates an array from an object of FixedArray<int>.
     *
     * @param arr An instance of the FixedArray type to convert to an array.
     *
     * @returns new Uint16Array
     */
    public static from(arr: FixedArray<int>): Uint16Array {
        let result = new Uint16Array(arr.length)
        result.ofInt(arr)
        return result
    }

    /**
     * Creates an array from a set of type std.core.Set<int>.
     *
     * @param set A set object to convert to an array.
     *
     * @returns new Uint16Array
     */
    public static from(set: Set<int>): Uint16Array {
        const length = set.size;
        const result = new Uint16Array(length)
        let iter = set.$_iterator()
        for (let i:int = 0; i < length; ++i) {
            const x = iter.next()
            if (x.done) {
                throw new AssertionError('Wrong Length')
            }
            result.setUnsafeClamp(i, x.value!.toInt())
        }
        return result
    }

    /**
     * Creates an array from an array of the same type.
     *
     * @param arr An array to convert to a new array.
     *
     * @returns new Uint16Array
     */
    public static from(arr: Uint16Array): Uint16Array {
        let result = new Uint16Array(arr.length)
        result.set(arr)
        return result
    }
    /**
     * Creates an array from an array of the same up to the signess type.
     *
     * @param arr An array to convert to a new array.
     *
     * @returns new Uint16Array
     */
    public static from(arr: Int16Array): Uint16Array {
        let result = new Uint16Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an object of std.core.Array<int>.
     *
     * @param arr An instance of the std.core.Array type to convert to an array.
     *
     * @returns new Uint16Array
     */
    public static from(arr: Array<int>): Uint16Array {
        let result = new Uint16Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @returns new Uint16Array
     */
    public static from(arr: ArrayLike<number>): Uint16Array {
        return Uint16Array.from<number>(
            arr,
            (x: number, _k: number): number => x
        );
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Uint16Array
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number): Uint16Array {
        let res = new Uint16Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new int[1]
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            const mapped = mapfn(x as T, idx[0].toDouble())
            res.setUnsafe(idx[0], Uint16Array.doubleToInt(mapped))
            idx[0] += 1
        })
        return res
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Uint16Array
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Uint16Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE (templin.konstantin): This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Uint16Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Uint16Array(result.buffer, 0, i)
                }
                const mapped = (mapfn)!(x.value!, i)
                result.setUnsafe(i, Uint16Array.doubleToInt(mapped))
            }
            return result
        }

        // NOTE (templin.konstantin): Create builtin array as buffer
        let temp = new Uint16Array(6)
        let index : FixedArray<int> = new int[1]
        index[0] = 0

        iteratorForEach<number>(arrayLike.$_iterator(), (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE (templin.konstantin): Progressive reallocation
                const curLength = temp.buffer.getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, temp.buffer.at(i))
                }
                temp = new Uint16Array(tb)
            }
            const mapped = (mapfn)!(x, index[0])
            temp.setUnsafe(index[0], Uint16Array.doubleToInt(mapped))
            index[0]++
        })

        return new Uint16Array(temp.buffer, 0, index[0])
    }

    /**
     * Determines whether Uint16Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint16Array, false otherwise
     */
    public includes(searchElement: int, fromIndex: int): boolean {
        return this.indexOf(searchElement.toInt(), fromIndex) != -1
    }

    /**
     * Determines whether Uint16Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint16Array, false otherwise
     */
    public includes(searchElement: int): boolean {
        return this.indexOf(searchElement.toInt(), 0) != -1
    }

    /**
     * Determines whether Uint16Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint16Array, false otherwise
     */
    public includes(searchElement: number, fromIndex?: int): boolean {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in Uint16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int): int {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Uint16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int, fromIndex: int): int {
        return this.indexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the first occurrence of a value in Uint16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex?: int): int {
            return this.indexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native indexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native indexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Converts all elements of an array to strings and joins them using the specified separator.
     *
     * @param separator - separates one element of an array from the next in the resulting String.
     *
     * @returns joined representation
     */
    private final native joinInternal(separator: String): string;

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param separator A string used to separate one element of an array from the next in the
     * resulting String. If omitted, the array elements are separated with a comma
     *
     * @returns joined representation
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.joinInternal(",")
        }
        return this.joinInternal(separator)
    }

    /**
     * Returns an list of keys in Uint16Array
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<int> {
        return new Uint16ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int, fromIndex: int): int {
        return this.lastIndexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: int | undefined): int {
            return this.lastIndexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native lastIndexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native lastIndexOfImpl(searchElement: number, fromIndex: int): int

   /**
    * Creates a new Uint16Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Uint16Array from data
    */
    public of(...data: FixedArray<number>): Uint16Array {
        throw new Error("Uint16Array.of: not implemented")
    }

    /**
     * Creates a new Uint16Array using reversed data from the current one
     *
     * @returns a new Uint16Array using reversed data from the current one
     */
    public native reverse(): Uint16Array

    /**
     * Creates a slice of current Uint16Array using range [begin, end]
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint16Array with elements of current Uint16Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: int, end?: int): Uint16Array {
        return this.sliceFromTo(begin ?? 0, end ?? this.lengthInt)
    }

    private sliceFromTo(begin: int, end: int): Uint16Array {
        const relStart = normalizeIndex(begin, this.lengthInt)
        const relEnd = normalizeIndex(end, this.lengthInt)
        let buf: ArrayBuffer = this.buffer.slice(relStart * this.BYTES_PER_ELEMENT + this.byteOffsetInt, relEnd * this.BYTES_PER_ELEMENT + this.byteOffsetInt)
        return new Uint16Array(buf)
    }

    /**
     * Creates a slice of current Uint16Array using range [begin, this.lengthInt].
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint16Array with elements of current Uint16Array[begin, this.lengthInt]
     */
    public slice(begin: int): Uint16Array {
        return this.sliceFromTo(begin, this.lengthInt)
    }


    /**
     * Sorts in-place by numeric value in ascending order.
     *
     * @returns sorted Uint16Array
     */
    public native sort(): this;

    /**
     * Sorts in-place
     *
     * @param compareFn comparator _  used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Uint16Array
     */
    public sort(compareFn?: (a: number, b: number) => number): this {
        if (compareFn == undefined) {
            this.sort()
            return this
        }

        let cmp = (l: int, r: int): number => {
            return compareFn!(l, r)
        }
        const MAX_SHORT_LENGTH = 24
        if (this.lengthInt > MAX_SHORT_LENGTH) {
            let arr: FixedArray<int> = new int[this.lengthInt]
            for (let i = 0; i < this.lengthInt; ++i) {
                arr[i] = this.getUnsafe(i)
            }
            arr = mergeSort(arr, cmp)
            for (let i = 0; i < arr.length; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let buffer: FixedArray<Int> = new Int[this.lengthInt]
            for (let i = 0; i < this.lengthInt; ++i) {
                buffer[i] = this.getUnsafe(i)
            }
            arr_sort_stable(buffer, 0, buffer.length as int, cmp)
            for (let i = 0; i < buffer.length; ++i) {
                this.setUnsafe(i, buffer[i])
            }
        }
        return this
    }

    /**
     * Creates a Uint16Array with the same underlying Buffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint16Array with the same underlying Buffer
     */
    public subarray(begin?: int, end?: int): Uint16Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin ?? 0, len)
        const relEnd = normalizeIndex(end ?? this.lengthInt, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Uint16Array(this.buffer, relStart * Uint16Array.BYTES_PER_ELEMENT + this.byteOffsetInt, count)
    }

    /**
     * Converts Uint16Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Uint16Array.toLocaleString: not implemented")
    }

    /**
     * Converts Uint16Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Uint16Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append((this.getUnsafe(i).toDouble()).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append((this.getUnsafe(this.lengthInt - 1).toDouble()).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Uint16Array {
        let newArray = new Uint16Array(this.lengthInt)
        if (this.lengthInt > 0) {
            Uint16Array.reverseCopyBuffer(newArray.buffer, this.buffer, this.byteOffset, this.lengthInt);
        }
        return newArray
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Uint16Array {
        return new Uint16Array(this).sort()
    }

    /**
     * Returns a string representation of the Uint16Array
     *
     * @returns a string representation of the Uint16Array
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<Number> {
         return new Uint16ArrayIterator(this)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint16Array with replaced value on index
     */
    public with(index: int, value: int): Uint16Array {
        let res = new Uint16Array(this)
        res.setUnsafeClamp(index, value)
        return res
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint16Array with replaced value on index
     */
    public with(index: int, value: number): Uint16Array {
        let res = new Uint16Array(this)
        res.setUnsafeClamp(index, value.toInt())
        return res
    }

    /// === with element lambda functions ===

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: int, array: Uint16Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Uint16Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Uint16Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = this.$_get(0).toDouble()
        for (let i = 1; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Uint16Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Uint16Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = this.$_get(this.lengthInt - 1).toDouble()
        for (let i = this.lengthInt - 2; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Creates a new Uint16Array using fn(arr[i]) over all elements of current Uint16Array.
     *
     * @param fn a function to apply for each element of current Uint16Array
     *
     * @returns a new Uint16Array where for each element from current Uint16Array fn was applied
     */
    public map(fn: (val: number, index: int, array: Uint16Array) => number): Uint16Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Uint16Array.BYTES_PER_ELEMENT)
        let res = new Uint16Array(resBuf)
        for (let i = 0; i < this.lengthInt; i++) {
            const fnRes = fn(this.getUnsafe(i).toDouble(), i, this)
            res.setUnsafeClamp(i, fnRes.toInt())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: int, array: Uint16Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (!predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Creates a new Uint16Array from current Uint16Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint16Array with elements from current Uint16Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: int, array: Uint16Array) => boolean): Uint16Array {
        let markers : FixedArray<boolean> = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; i++) {
            markers[i] = fn(this.getUnsafe(i).toDouble(), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let res = new Uint16Array(resLen)
        for (let i = 0, j = 0; i < this.lengthInt; i++) {
            if (markers[i]) {
                res.setUnsafe(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: int, array: Uint16Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; i++) {
            let val = this.getUnsafe(i).toDouble()
            if (predicate(val, i, this)) {
                return val
            }
        }
        return undefined
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns int
     */
    public findIndex(predicate: (value: number, index: int, obj: Uint16Array) => boolean): int {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int, array: Uint16Array) => boolean): number {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            let val = this.getUnsafe(i).toDouble()
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint16Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds an index of the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int, array: Uint16Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            if (fn(this.getUnsafe(i).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Performs the specified action for each element in Uint16Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: int, array: Uint16Array) => void): void {
        for (let i = 0; i < this.lengthInt; i++) {
            callbackfn(this.getUnsafe(i).toDouble(), i, this)
        }
    }

    /**
     * Returns the object itself
     *
     * @returns Uint16Array
     */
    public valueOf(): Uint16Array {
        return this
    }

    /** Byte offset within the underlying Buffer */
    public get byteOffset(): int {
        return this.byteOffsetInt
    }

    /** Number of bytes used */
    public get byteLength(): int {
        return this.byteLengthInt
    }

    /** Number of int stored in Uint16Array */
    public get length(): int {
        return this.lengthInt
    }

    /** String \"Uint16Array\" */
    public readonly name = "Uint16Array"

    private static native reverseCopyBuffer(dstBuf: ArrayBuffer, srcBuf: ArrayBuffer, startPos: int, length: int): void

    private static clamp(val: int): int {
        return val
    }

    private setUnsafeClamp(insertPos: int, val: int): void {
        this.setUnsafe(insertPos, val)
    }

    private final native getUnsafe(index: int): int

    private setUnsafe(index: int, val: int): void {
        const BPE = Uint16Array.BYTES_PER_ELEMENT.toInt()
        let byteIndex = index * BPE + this.byteOffsetInt
        let buf = this.buffer
        if (IS_LITTLE_ENDIAN) {
            for (let i = 0; i < BPE; ++i) {
                buf.set(byteIndex++, (val & 0xff).toByte())
                val = val >> 8
            }
        } else {
            byteIndex = byteIndex + BPE - 1
            for (let i = 0; i < BPE; i++) {
                buf.set(byteIndex--, (val & 0xff).toByte())
                val = val >> 8
            }
        }
    }
}


class Uint32ArrayIteratorKeys implements IterableIterator<int> {
    private length: int = 0
    private idx: int = 0

    constructor(parent: Uint32Array) {
        this.length = parent.length
    }

    public override $_iterator(): IterableIterator<int> {
        return this
    }

    override next(): IteratorResult<int> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(false, this.idx++)
    }
}

class Uint32ArrayIterator implements IterableIterator<Number> {
    private parent: Uint32Array
    private idx: int = 0

    constructor(parent: Uint32Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Uint32ArrayIteratorEntries implements IterableIterator<[int, Number]> {
    private parent: Uint32Array
    private idx: int = 0

    constructor(parent: Uint32Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[int, Number]> {
        return this
    }

    override next(): IteratorResult<[int, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<[int, Number]>()
        }
        return new IteratorResult<[int, Number]>(
            false,
            [this.idx, new Number(this.parent[this.idx++])]
        )
    }
}

/**
 * JS Uint32Array API-compatible class
 */
export final class Uint32Array implements Iterable<Number>, ArrayLike<Number> {
    public static readonly BYTES_PER_ELEMENT: int = 4
    public readonly BYTES_PER_ELEMENT: int = Uint32Array.BYTES_PER_ELEMENT

    /** Underlying Buffer */
    public readonly buffer: ArrayBuffer

    private readonly byteOffsetInt: int
    private readonly byteLengthInt: int
    protected readonly lengthInt: int

    /**
     * Creates an empty Uint32Array.
     */
    public constructor() {
        this(0)
    }

    /**
     * Creates an Uint32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        this(length.toDouble())
    }

    /**
     * Creates an Uint32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        if (length < 0 || length > (Int.MAX_VALUE / Uint32Array.BYTES_PER_ELEMENT)) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length.toInt()
        this.byteLengthInt = this.lengthInt * Uint32Array.BYTES_PER_ELEMENT
        this.byteOffsetInt = 0
        this.buffer = new ArrayBuffer(this.byteLengthInt)
    }

    /**
     * Creates an Uint32Array from FixedArray<int>
     */
    public constructor(numbers: FixedArray<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafeClamp(i, numbers[i].toLong())
        }
    }

    /**
     * Creates an Uint32Array from FixedArray<number>
     */
    public constructor(numbers: FixedArray<number>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, Uint32Array.doubleToInt(numbers[i]))
        }
    }

    /**
     * Creates a copy of Uint32Array.
     *
     * @param other data initializer
     */
    public constructor(other: Uint32Array) {
        this.buffer = other.buffer.slice(other.byteOffset, other.byteOffset + other.byteLength) as ArrayBuffer
        this.byteLengthInt = other.byteLength
        this.lengthInt = other.length
        this.byteOffsetInt = 0
    }

    /**
     * Creates an Uint32Array with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<Number>) {
        const items: Object = elements as Object
        if (items instanceof ArrayLike) {
            const arr = reflect.internals.Types.identity_cast<Number>(items as ArrayLike<Number>)
            this.byteLengthInt = arr.length * Uint32Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLengthInt)
            this.byteOffsetInt = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafeClamp(i, Uint32Array.doubleToInt(arr.$_get(i)));
            }
        } else {
            let x = Uint32Array.from(elements)
            this.byteLengthInt = x.byteLengthInt
            this.lengthInt = x.lengthInt
            this.buffer = x.buffer
            this.byteOffsetInt = x.byteOffsetInt
        }
    }
    private static native doubleToInt(d: double): Long;

    /**
     * Creates an Uint32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type long in newly created Uint32Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Uint32Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Uint32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type long in newly created Uint32Array
     */
    public constructor(buf: ArrayBuffer, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.toInt()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int = buf.getByteLength() - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteOffset % Uint32Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 4 as Uint32Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.toInt()
            if (intLength > intByteLength / Uint32Array.BYTES_PER_ELEMENT) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / Uint32Array.BYTES_PER_ELEMENT
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / Uint32Array.BYTES_PER_ELEMENT) {
            intByteLength = intLength * Uint32Array.BYTES_PER_ELEMENT
        }
        this.byteLengthInt = intByteLength
        this.byteOffsetInt = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Uint32Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Uint32Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBuffer) {
        if (buf instanceof ArrayBuffer) {
            this.byteLengthInt = (buf as ArrayBuffer).getByteLength()
            if (this.byteLengthInt % Uint32Array.BYTES_PER_ELEMENT.toInt() != 0) {
               throw new RangeError("ArrayBuffer.byteLength should be multiple of long as Uint32Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLengthInt / Uint32Array.BYTES_PER_ELEMENT
            this.buffer = buf as ArrayBuffer
            this.byteOffsetInt = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLengthInt = arr.length * Uint32Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLengthInt)
            this.byteOffsetInt = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, Uint32Array.doubleToInt(arr[i]))
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns iterator over all elements
     */
    public override $_iterator(): IterableIterator<Number> {
         return this.values()
    }

    /**
     * Returns an instance of primitive type at passed index if index is correct.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public native $_get(i: int): number

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public native $_set(index: int, val: int): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public native $_set(index: int, val: long): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: number): void {
        this.$_set(index, Uint32Array.doubleToInt(val))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: int): Uint32Array {
        let arrayLength: int = this.lengthInt;
        target = normalizeIndex(target, arrayLength);
        start = normalizeIndex(start, arrayLength);
        end = normalizeIndex(asIntOrDefault(end, arrayLength), arrayLength);
        let count: int = end - start;
        if (count > (arrayLength - target)) {
            count = arrayLength - target;
        }
        if (count <= 0) {
            return this;
        }

        this.copyWithinImpl(target, start, count)
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param insert insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    private native copyWithinImpl(target: int, start: int, end: int): void

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Uint32Array.
     *
     * @param insert insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): Uint32Array {
        this.copyWithinImpl(target, 0, this.lengthInt)
        return this
    }

    /**
     * Returns an array of key, value pairs for every entry in the Uint32Array
     *
     * @returns key, value pairs for every entry in the array
     */
    public entries(): IterableIterator<[int, Number]> {
        return new Uint32ArrayIteratorEntries(this)
    }

    /**
     * Fills the Uint32Array with specified value
     *
     * @param value new value
     *
     * @returns modified Uint32Array
     */
    public fill(value: long, start?: int, end?: int): Uint32Array {
        const k = normalizeIndex(start ?? 0, this.lengthInt)
        const finalPos = normalizeIndex(end ?? this.lengthInt, this.lengthInt)
        this.fillInternal(value, k, finalPos)
        return this
    }

    /**
     * Fills the Uint32Array with specified value
     *
     * @param value new value
     *
     * @returns modified Uint32Array
     */
    public fill(value: number, start?: int, end?: int): Uint32Array {
        this.fill(Uint32Array.doubleToInt(value), start, end)
        return this
    }

    private final native fillInternal(value: long, start: int, end: int): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: long): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Uint32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: FixedArray<long>, insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: FixedArray<long>): size of arr is greater than Uint32Array.length")
        }
        for (let i = 0; i < arr.length; i++) {
            this.setUnsafeClamp(insertPos + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Uint32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: FixedArray<number>, insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: FixedArray<long>): size of arr is greater than Uint32Array.length")
        }
        for (let i = 0; i < arr.length; i++) {
            this.setUnsafe(insertPos + i, Uint32Array.doubleToInt(arr[i]))
        }
    }

    /**
     * Copies all elements of arr to the current Uint32Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: FixedArray<long>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Uint32Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: FixedArray<number>): void {
        this.set(arr, 0)
    }

    private native final set(array: Array<int>): void;

    public native set(array: Uint32Array): void
    private native final set(array: Int32Array): void

    public native set(array: Uint32Array, offset: int): void

    /**
     * Copies elements from an ArrayLike object to the Uint32Array.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<number>, offset: int = 0): void {
        const insertPos = offset
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; ++i) {
            this.setUnsafe(insertPos + i, Uint32Array.doubleToInt(array[i]))
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint32Array
     */
    public static of(...items: FixedArray<int>): Uint32Array {
        let res = new Uint32Array(items.length.toInt())
        res.ofInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint32Array
     */
    public static of(...items: FixedArray<long>): Uint32Array {
        let res = new Uint32Array(items.length.toInt())
        res.ofLong(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint32Array
     */
    public static of(...items: FixedArray<number>): Uint32Array {
        let res = new Uint32Array(items.length.toInt())
        res.ofNumber(items)
        return res
    }

    private final native ofInt(items: FixedArray<int>): void
    private final native ofNumber(items: FixedArray<number>): void
    private final native ofLong(items: FixedArray<long>): void

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Uint32Array
     */
    public static of(): Uint32Array {
        return new Uint32Array(0)
    }

    /**
     * Creates an array from an object of FixedArray<int>.
     *
     * @param arr An instance of the FixedArray type to convert to an array.
     *
     * @returns new Uint32Array
     */
    public static from(arr: FixedArray<int>): Uint32Array {
        let result = new Uint32Array(arr.length)
        result.ofInt(arr)
        return result
    }

    /**
     * Creates an array from a set of type std.core.Set<int>.
     *
     * @param set A set object to convert to an array.
     *
     * @returns new Uint32Array
     */
    public static from(set: Set<int>): Uint32Array {
        const length = set.size;
        const result = new Uint32Array(length)
        let iter = set.$_iterator()
        for (let i:int = 0; i < length; ++i) {
            const x = iter.next()
            if (x.done) {
                throw new AssertionError('Wrong Length')
            }
            result.setUnsafeClamp(i, x.value!.toLong())
        }
        return result
    }

    /**
     * Creates an array from an array of the same type.
     *
     * @param arr An array to convert to a new array.
     *
     * @returns new Uint32Array
     */
    public static from(arr: Uint32Array): Uint32Array {
        let result = new Uint32Array(arr.length)
        result.set(arr)
        return result
    }
    /**
     * Creates an array from an array of the same up to the signess type.
     *
     * @param arr An array to convert to a new array.
     *
     * @returns new Uint32Array
     */
    public static from(arr: Int32Array): Uint32Array {
        let result = new Uint32Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an object of std.core.Array<int>.
     *
     * @param arr An instance of the std.core.Array type to convert to an array.
     *
     * @returns new Uint32Array
     */
    public static from(arr: Array<int>): Uint32Array {
        let result = new Uint32Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @returns new Uint32Array
     */
    public static from(arr: ArrayLike<number>): Uint32Array {
        return Uint32Array.from<number>(
            arr,
            (x: number, _k: number): number => x
        );
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Uint32Array
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number): Uint32Array {
        let res = new Uint32Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new int[1]
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            const mapped = mapfn(x as T, idx[0].toDouble())
            res.setUnsafe(idx[0], Uint32Array.doubleToInt(mapped))
            idx[0] += 1
        })
        return res
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Uint32Array
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Uint32Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE (templin.konstantin): This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Uint32Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Uint32Array(result.buffer, 0, i)
                }
                const mapped = (mapfn)!(x.value!, i)
                result.setUnsafe(i, Uint32Array.doubleToInt(mapped))
            }
            return result
        }

        // NOTE (templin.konstantin): Create builtin array as buffer
        let temp = new Uint32Array(6)
        let index : FixedArray<int> = new int[1]
        index[0] = 0

        iteratorForEach<number>(arrayLike.$_iterator(), (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE (templin.konstantin): Progressive reallocation
                const curLength = temp.buffer.getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, temp.buffer.at(i))
                }
                temp = new Uint32Array(tb)
            }
            const mapped = (mapfn)!(x, index[0])
            temp.setUnsafe(index[0], Uint32Array.doubleToInt(mapped))
            index[0]++
        })

        return new Uint32Array(temp.buffer, 0, index[0])
    }

    /**
     * Determines whether Uint32Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint32Array, false otherwise
     */
    public includes(searchElement: long, fromIndex: int): boolean {
        return this.indexOf(searchElement.toInt(), fromIndex) != -1
    }

    /**
     * Determines whether Uint32Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint32Array, false otherwise
     */
    public includes(searchElement: long): boolean {
        return this.indexOf(searchElement.toInt(), 0) != -1
    }

    /**
     * Determines whether Uint32Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Uint32Array, false otherwise
     */
    public includes(searchElement: number, fromIndex?: int): boolean {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in Uint32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int): int {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Uint32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int, fromIndex: int): int {
        return this.indexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the first occurrence of a value in Uint32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex?: int): int {
            return this.indexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native indexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native indexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Converts all elements of an array to strings and joins them using the specified separator.
     *
     * @param separator - separates one element of an array from the next in the resulting String.
     *
     * @returns joined representation
     */
    private final native joinInternal(separator: String): string;

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param separator A string used to separate one element of an array from the next in the
     * resulting String. If omitted, the array elements are separated with a comma
     *
     * @returns joined representation
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.joinInternal(",")
        }
        return this.joinInternal(separator)
    }

    /**
     * Returns an list of keys in Uint32Array
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<int> {
        return new Uint32ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int, fromIndex: int): int {
        return this.lastIndexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the last occurrence of a value in Uint32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: int | undefined): int {
            return this.lastIndexOfImpl(searchElement, fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native lastIndexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native lastIndexOfImpl(searchElement: number, fromIndex: int): int

   /**
    * Creates a new Uint32Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Uint32Array from data
    */
    public of(...data: FixedArray<number>): Uint32Array {
        throw new Error("Uint32Array.of: not implemented")
    }

    /**
     * Creates a new Uint32Array using reversed data from the current one
     *
     * @returns a new Uint32Array using reversed data from the current one
     */
    public native reverse(): Uint32Array

    /**
     * Creates a slice of current Uint32Array using range [begin, end]
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint32Array with elements of current Uint32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: int, end?: int): Uint32Array {
        return this.sliceFromTo(begin ?? 0, end ?? this.lengthInt)
    }

    private sliceFromTo(begin: int, end: int): Uint32Array {
        const relStart = normalizeIndex(begin, this.lengthInt)
        const relEnd = normalizeIndex(end, this.lengthInt)
        let buf: ArrayBuffer = this.buffer.slice(relStart * this.BYTES_PER_ELEMENT + this.byteOffsetInt, relEnd * this.BYTES_PER_ELEMENT + this.byteOffsetInt)
        return new Uint32Array(buf)
    }

    /**
     * Creates a slice of current Uint32Array using range [begin, this.lengthInt].
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint32Array with elements of current Uint32Array[begin, this.lengthInt]
     */
    public slice(begin: int): Uint32Array {
        return this.sliceFromTo(begin, this.lengthInt)
    }


    /**
     * Sorts in-place by numeric value in ascending order.
     *
     * @returns sorted Uint32Array
     */
    public native sort(): this;

    /**
     * Sorts in-place
     *
     * @param compareFn comparator _  used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Uint32Array
     */
    public sort(compareFn?: (a: number, b: number) => number): this {
        if (compareFn == undefined) {
            this.sort()
            return this
        }

        let cmp = (l: long, r: long): number => {
            return compareFn!(l, r)
        }
        const MAX_SHORT_LENGTH = 24
        if (this.lengthInt > MAX_SHORT_LENGTH) {
            let arr: FixedArray<long> = new long[this.lengthInt]
            for (let i = 0; i < this.lengthInt; ++i) {
                arr[i] = this.getUnsafe(i)
            }
            arr = mergeSort(arr, cmp)
            for (let i = 0; i < arr.length; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let buffer: FixedArray<Long> = new Long[this.lengthInt]
            for (let i = 0; i < this.lengthInt; ++i) {
                buffer[i] = this.getUnsafe(i)
            }
            arr_sort_stable(buffer, 0, buffer.length as int, cmp)
            for (let i = 0; i < buffer.length; ++i) {
                this.setUnsafe(i, buffer[i])
            }
        }
        return this
    }

    /**
     * Creates a Uint32Array with the same underlying Buffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint32Array with the same underlying Buffer
     */
    public subarray(begin?: int, end?: int): Uint32Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin ?? 0, len)
        const relEnd = normalizeIndex(end ?? this.lengthInt, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Uint32Array(this.buffer, relStart * Uint32Array.BYTES_PER_ELEMENT + this.byteOffsetInt, count)
    }

    /**
     * Converts Uint32Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Uint32Array.toLocaleString: not implemented")
    }

    /**
     * Converts Uint32Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Uint32Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append((this.getUnsafe(i).toDouble()).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append((this.getUnsafe(this.lengthInt - 1).toDouble()).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Uint32Array {
        let newArray = new Uint32Array(this.lengthInt)
        if (this.lengthInt > 0) {
            Uint32Array.reverseCopyBuffer(newArray.buffer, this.buffer, this.byteOffset, this.lengthInt);
        }
        return newArray
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Uint32Array {
        return new Uint32Array(this).sort()
    }

    /**
     * Returns a string representation of the Uint32Array
     *
     * @returns a string representation of the Uint32Array
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<Number> {
         return new Uint32ArrayIterator(this)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint32Array with replaced value on index
     */
    public with(index: int, value: long): Uint32Array {
        let res = new Uint32Array(this)
        res.setUnsafeClamp(index, value)
        return res
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint32Array with replaced value on index
     */
    public with(index: int, value: number): Uint32Array {
        let res = new Uint32Array(this)
        res.setUnsafeClamp(index, value.toLong())
        return res
    }

    /// === with element lambda functions ===

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: int, array: Uint32Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Uint32Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Uint32Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = this.$_get(0).toDouble()
        for (let i = 1; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: int, array: Uint32Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: int, array: Uint32Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = this.$_get(this.lengthInt - 1).toDouble()
        for (let i = this.lengthInt - 2; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i).toDouble(), i, this)
        }
        return accumulatedValue
    }

    /**
     * Creates a new Uint32Array using fn(arr[i]) over all elements of current Uint32Array.
     *
     * @param fn a function to apply for each element of current Uint32Array
     *
     * @returns a new Uint32Array where for each element from current Uint32Array fn was applied
     */
    public map(fn: (val: number, index: int, array: Uint32Array) => number): Uint32Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Uint32Array.BYTES_PER_ELEMENT)
        let res = new Uint32Array(resBuf)
        for (let i = 0; i < this.lengthInt; i++) {
            const fnRes = fn(this.getUnsafe(i).toDouble(), i, this)
            res.setUnsafeClamp(i, fnRes.toLong())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: int, array: Uint32Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (!predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Creates a new Uint32Array from current Uint32Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint32Array with elements from current Uint32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: int, array: Uint32Array) => boolean): Uint32Array {
        let markers : FixedArray<boolean> = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; i++) {
            markers[i] = fn(this.getUnsafe(i).toDouble(), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let res = new Uint32Array(resLen)
        for (let i = 0, j = 0; i < this.lengthInt; i++) {
            if (markers[i]) {
                res.setUnsafe(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: int, array: Uint32Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; i++) {
            let val = this.getUnsafe(i).toDouble()
            if (predicate(val, i, this)) {
                return val
            }
        }
        return undefined
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns int
     */
    public findIndex(predicate: (value: number, index: int, obj: Uint32Array) => boolean): int {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate(this.getUnsafe(i).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int, array: Uint32Array) => boolean): number {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            let val = this.getUnsafe(i).toDouble()
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint32Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds an index of the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int, array: Uint32Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            if (fn(this.getUnsafe(i).toDouble(), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Performs the specified action for each element in Uint32Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: int, array: Uint32Array) => void): void {
        for (let i = 0; i < this.lengthInt; i++) {
            callbackfn(this.getUnsafe(i).toDouble(), i, this)
        }
    }

    /**
     * Returns the object itself
     *
     * @returns Uint32Array
     */
    public valueOf(): Uint32Array {
        return this
    }

    /** Byte offset within the underlying Buffer */
    public get byteOffset(): int {
        return this.byteOffsetInt
    }

    /** Number of bytes used */
    public get byteLength(): int {
        return this.byteLengthInt
    }

    /** Number of long stored in Uint32Array */
    public get length(): int {
        return this.lengthInt
    }

    /** String \"Uint32Array\" */
    public readonly name = "Uint32Array"

    private static native reverseCopyBuffer(dstBuf: ArrayBuffer, srcBuf: ArrayBuffer, startPos: int, length: int): void

    private static clamp(val: long): long {
        return val
    }

    private setUnsafeClamp(insertPos: int, val: long): void {
        this.setUnsafe(insertPos, val)
    }

    private final native getUnsafe(index: int): long

    private setUnsafe(index: int, val: long): void {
        const BPE = Uint32Array.BYTES_PER_ELEMENT.toInt()
        let byteIndex = index * BPE + this.byteOffsetInt
        let buf = this.buffer
        if (IS_LITTLE_ENDIAN) {
            for (let i = 0; i < BPE; ++i) {
                buf.set(byteIndex++, (val & 0xff).toByte())
                val = val >> 8
            }
        } else {
            byteIndex = byteIndex + BPE - 1
            for (let i = 0; i < BPE; i++) {
                buf.set(byteIndex--, (val & 0xff).toByte())
                val = val >> 8
            }
        }
    }
}


class BigUint64ArrayIteratorKeys implements IterableIterator<int> {
    private length: int = 0
    private idx: int = 0

    constructor(parent: BigUint64Array) {
        this.length = parent.length
    }

    public override $_iterator(): IterableIterator<int> {
        return this
    }

    override next(): IteratorResult<int> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(false, this.idx++)
    }
}

class BigUint64ArrayIterator implements IterableIterator<BigInt> {
    private parent: BigUint64Array
    private idx: int = 0

    constructor(parent: BigUint64Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<BigInt> {
        return this
    }

    override next(): IteratorResult<BigInt> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<BigInt>()
        }
        return new IteratorResult<BigInt>(false, new BigInt(this.parent[this.idx++]))
    }
}

class BigUint64ArrayIteratorEntries implements IterableIterator<[int, BigInt]> {
    private parent: BigUint64Array
    private idx: int = 0

    constructor(parent: BigUint64Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[int, BigInt]> {
        return this
    }

    override next(): IteratorResult<[int, BigInt]> {
        if (this.idx < 0 || this.idx >= this.parent.length) {
            return new IteratorResult<[int, BigInt]>()
        }
        return new IteratorResult<[int, BigInt]>(
            false,
            [this.idx, new BigInt(this.parent[this.idx++])] as [int, BigInt]
        )
    }
}

/**
 * JS BigUint64Array API-compatible class
 */
export final class BigUint64Array implements Iterable<BigInt>, ArrayLike<BigInt> {
    public static readonly BYTES_PER_ELEMENT: int = 8
    public readonly BYTES_PER_ELEMENT: int = BigUint64Array.BYTES_PER_ELEMENT

    /** Underlying Buffer */
    public readonly buffer: ArrayBuffer

    private readonly byteOffsetInt: int
    private readonly byteLengthInt: int
    private static readonly unsignedLongMax: bigint = 18446744073709551615n;
    protected readonly lengthInt: int

    /**
     * Creates an empty BigUint64Array.
     */
    public constructor() {
        this(0)
    }

    /**
     * Creates an BigUint64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        this(length.toDouble())
    }

    /**
     * Creates an BigUint64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        if (length < 0 || length > (Int.MAX_VALUE / BigUint64Array.BYTES_PER_ELEMENT)) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length.toInt()
        this.byteLengthInt = this.lengthInt * BigUint64Array.BYTES_PER_ELEMENT
        this.byteOffsetInt = 0
        this.buffer = new ArrayBuffer(this.byteLengthInt)
    }

    /**
     * Creates an BigUint64Array from FixedArray<int>
     */
    public constructor(numbers: FixedArray<int>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafeClamp(i, new BigInt(numbers[i]).getULong())
        }
    }

    /**
     * Creates an BigUint64Array from FixedArray<number>
     */
    public constructor(numbers: FixedArray<number>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, new BigInt(numbers[i]).getULong())
        }
    }

    /**
     * Creates an BigUint64Array from FixedArray<bigint>
     */
    public constructor(numbers: FixedArray<bigint>) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i].getULong())
        }
    }

    /**
     * Creates a copy of BigUint64Array.
     *
     * @param other data initializer
     */
    public constructor(other: BigUint64Array) {
        this.buffer = other.buffer.slice(other.byteOffset, other.byteOffset + other.byteLength) as ArrayBuffer
        this.byteLengthInt = other.byteLength
        this.lengthInt = other.length
        this.byteOffsetInt = 0
    }

    /**
     * Creates an BigUint64Array with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<BigInt>) {
        const items: Object = elements as Object
        if (items instanceof ArrayLike) {
            const arr = reflect.internals.Types.identity_cast<BigInt>(items as ArrayLike<BigInt>)
            this.byteLengthInt = arr.length * BigUint64Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLengthInt)
            this.byteOffsetInt = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafeClamp(i, arr.$_get(i).getULong())
            }
        } else {
            let x = BigUint64Array.from(elements)
            this.byteLengthInt = x.byteLengthInt
            this.lengthInt = x.lengthInt
            this.buffer = x.buffer
            this.byteOffsetInt = x.byteOffsetInt
        }
    }

    /**
     * Creates an BigUint64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type long in newly created BigUint64Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an BigUint64Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an BigUint64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type long in newly created BigUint64Array
     */
    public constructor(buf: ArrayBuffer, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.toInt()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int = buf.getByteLength() - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteOffset % BigUint64Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 8 as BigUint64Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.toInt()
            if (intLength > intByteLength / BigUint64Array.BYTES_PER_ELEMENT) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / BigUint64Array.BYTES_PER_ELEMENT
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / BigUint64Array.BYTES_PER_ELEMENT) {
            intByteLength = intLength * BigUint64Array.BYTES_PER_ELEMENT
        }
        this.byteLengthInt = intByteLength
        this.byteOffsetInt = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an BigUint64Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an BigUint64Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBuffer) {
        if (buf instanceof ArrayBuffer) {
            this.byteLengthInt = (buf as ArrayBuffer).getByteLength()
            if (this.byteLengthInt % BigUint64Array.BYTES_PER_ELEMENT.toInt() != 0) {
               throw new RangeError("ArrayBuffer.byteLength should be multiple of long as BigUint64Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLengthInt / BigUint64Array.BYTES_PER_ELEMENT
            this.buffer = buf as ArrayBuffer
            this.byteOffsetInt = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.ets
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLengthInt = arr.length * BigUint64Array.BYTES_PER_ELEMENT
            this.lengthInt = arr.length
            this.buffer = new ArrayBuffer(this.byteLengthInt)
            this.byteOffsetInt = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, new BigInt(arr[i]).getULong())
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns iterator over all elements
     */
    public override $_iterator(): IterableIterator<BigInt> {
         return this.values()
    }

    /**
     * Returns an instance of primitive type at passed index if index is correct.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): BigInt | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return BigInt.fromULong(this.getUnsafe(k))
    }

    /**
     * Returns an instance of BigInt at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public $_get(i: int): BigInt {
        return BigInt.fromULong(this.getLong(i))
    }
    private native getLong(i: int): long

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public native $_set(index: int, val: int): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public native $_set(index: int, val: long): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: BigInt): void {
        this.$_set(index, val.getULong())
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: int): BigUint64Array {
        let arrayLength: int = this.lengthInt;
        target = normalizeIndex(target, arrayLength);
        start = normalizeIndex(start, arrayLength);
        end = normalizeIndex(asIntOrDefault(end, arrayLength), arrayLength);
        let count: int = end - start;
        if (count > (arrayLength - target)) {
            count = arrayLength - target;
        }
        if (count <= 0) {
            return this;
        }

        this.copyWithinImpl(target, start, count)
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param insert insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    private native copyWithinImpl(target: int, start: int, end: int): void

    /**
     * Makes a copy of internal elements to targetPos from begin to end of BigUint64Array.
     *
     * @param insert insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): BigUint64Array {
        this.copyWithinImpl(target, 0, this.lengthInt)
        return this
    }

    /**
     * Returns an array of key, value pairs for every entry in the BigUint64Array
     *
     * @returns key, value pairs for every entry in the array
     */
    public entries(): IterableIterator<[int, BigInt]> {
        return new BigUint64ArrayIteratorEntries(this)
    }

    /**
     * Fills the BigUint64Array with specified value
     *
     * @param value new value
     *
     * @returns modified BigUint64Array
     */
    public fill(value: long, start?: int, end?: int): BigUint64Array {
        const k = normalizeIndex(start ?? 0, this.lengthInt)
        const finalPos = normalizeIndex(end ?? this.lengthInt, this.lengthInt)
        this.fillInternal(value, k, finalPos)
        return this
    }

    /**
     * Fills the BigUint64Array with specified value
     *
     * @param value new value
     *
     * @returns modified BigUint64Array
     */
    public fill(value: BigInt, start?: int, end?: int): BigUint64Array {
        this.fill(value.getULong(), start, end)
        return this
    }

    private final native fillInternal(value: long, start: int, end: int): void

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: long): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public set(insertPos: int, val: BigInt): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current BigUint64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: FixedArray<long>, insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: FixedArray<long>): size of arr is greater than BigUint64Array.length")
        }
        for (let i = 0; i < arr.length; i++) {
            this.setUnsafeClamp(insertPos + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current BigUint64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: FixedArray<BigInt>, insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.lengthInt) {
            throw new RangeError("set(insertPos: int, arr: FixedArray<long>): size of arr is greater than BigUint64Array.length")
        }
        for (let i = 0; i < arr.length; i++) {
            this.setUnsafe(insertPos + i, arr[i].getULong())
        }
    }

    /**
     * Copies all elements of arr to the current BigUint64Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: FixedArray<long>): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current BigUint64Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: FixedArray<BigInt>): void {
        this.set(arr, 0)
    }

    private native final set(array: Array<BigInt>): void;

    public native set(array: BigUint64Array): void

    public native set(array: BigUint64Array, offset: int): void

    /**
     * Copies elements from an ArrayLike object to the BigUint64Array.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<BigInt>, offset: int = 0): void {
        const insertPos = offset
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length; ++i) {
            this.setUnsafe(insertPos + i, array[i].getULong())
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new BigUint64Array
     */
    public static of(...items: FixedArray<int>): BigUint64Array {
        let res = new BigUint64Array(items.length.toInt())
        res.ofInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new BigUint64Array
     */
    public static of(...items: FixedArray<long>): BigUint64Array {
        let res = new BigUint64Array(items.length.toInt())
        res.ofLong(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new BigUint64Array
     */
    public static of(...items: FixedArray<bigint>): BigUint64Array {
        let res = new BigUint64Array(items.length.toInt())
        res.ofBigInt(items)
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new BigUint64Array
     */
    public static of(...items: FixedArray<number>): BigUint64Array {
        let res = new BigUint64Array(items.length.toInt())
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafeClamp(i, (new BigInt(items[i])).getULong())
        }
        return res
    }

    private final native ofInt(items: FixedArray<int>): void
    private final native ofNumber(items: FixedArray<number>): void
    private final native ofLong(items: FixedArray<long>): void
    private final native ofBigInt(items: FixedArray<Object>): void

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new BigUint64Array
     */
    public static of(): BigUint64Array {
        return new BigUint64Array(0)
    }

    /**
     * Creates an array from an object of FixedArray<BigInt>.
     *
     * @param arr An instance of the FixedArray type to convert to an array.
     *
     * @returns new BigUint64Array
     */
    public static from(arr: FixedArray<BigInt>): BigUint64Array {
        let result = new BigUint64Array(arr.length)
        result.ofBigInt(arr)
        return result
    }

    /**
     * Creates an array from a set of type std.core.Set<BigInt>.
     *
     * @param set A set object to convert to an array.
     *
     * @returns new BigUint64Array
     */
    public static from(set: Set<BigInt>): BigUint64Array {
        const length = set.size;
        const result = new BigUint64Array(length)
        let iter = set.$_iterator()
        for (let i:int = 0; i < length; ++i) {
            const x = iter.next()
            if (x.done) {
                throw new AssertionError('Wrong Length')
            }
            result.setUnsafeClamp(i, x.value!.getULong())
        }
        return result
    }

    /**
     * Creates an array from an array of the same type.
     *
     * @param arr An array to convert to a new array.
     *
     * @returns new BigUint64Array
     */
    public static from(arr: BigUint64Array): BigUint64Array {
        let result = new BigUint64Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an object of std.core.Array<BigInt>.
     *
     * @param arr An instance of the std.core.Array type to convert to an array.
     *
     * @returns new BigUint64Array
     */
    public static from(arr: Array<BigInt>): BigUint64Array {
        let result = new BigUint64Array(arr.length)
        result.set(arr)
        return result
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @returns new BigUint64Array
     */
    public static from(arr: ArrayLike<BigInt>): BigUint64Array {
        throw new Error("BigUint64Array.from: not implemented");
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new BigUint64Array
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => BigInt): BigUint64Array {
        let res = new BigUint64Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx : FixedArray<int> = new int[1]
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            const mapped = mapfn(x as T, idx[0].toDouble())
            res.setUnsafe(idx[0], mapped.getULong())
            idx[0] += 1
        })
        return res
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new BigUint64Array
     */
    public static from(arrayLike: Iterable<BigInt>, mapfn?: (v: BigInt, k: number) => BigInt): BigUint64Array {
        if (mapfn == undefined) {
            mapfn = (v: BigInt, k: number): BigInt => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE (templin.konstantin): This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new BigUint64Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new BigUint64Array(result.buffer, 0, i)
                }
                const mapped = (mapfn)!(x.value!, i)
                result.setUnsafe(i, mapped.getULong())
            }
            return result
        }

        // NOTE (templin.konstantin): Create builtin array as buffer
        let temp = new BigUint64Array(6)
        let index : FixedArray<int> = new int[1]
        index[0] = 0

        iteratorForEach<BigInt>(arrayLike.$_iterator(), (x: BigInt): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE (templin.konstantin): Progressive reallocation
                const curLength = temp.buffer.getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, temp.buffer.at(i))
                }
                temp = new BigUint64Array(tb)
            }
            const mapped = (mapfn)!(x, index[0])
            temp.setUnsafe(index[0], mapped.getULong())
            index[0]++
        })

        return new BigUint64Array(temp.buffer, 0, index[0])
    }

    /**
     * Determines whether BigUint64Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in BigUint64Array, false otherwise
     */
    public includes(searchElement: long, fromIndex: int): boolean {
        if (searchElement < 0) {
            return false;
        }
        return this.indexOf(searchElement.toInt(), fromIndex) != -1
    }

    /**
     * Determines whether BigUint64Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in BigUint64Array, false otherwise
     */
    public includes(searchElement: long): boolean {
        if (searchElement < 0) {
            return false;
        }
        return this.indexOf(searchElement.toInt(), 0) != -1
    }

    /**
     * Determines whether BigUint64Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in BigUint64Array, false otherwise
     */
    public includes(searchElement: BigInt, fromIndex?: int): boolean {
        if (searchElement < 0 || searchElement > BigUint64Array.unsignedLongMax) {
            return false;
        }
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in BigUint64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int): int {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in BigUint64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int, fromIndex: int): int {
        return this.indexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the first occurrence of a value in BigUint64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: BigInt, fromIndex?: int): int {
            return this.indexOfImpl(searchElement.getLong(), fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native indexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native indexOfImpl(searchElement: number, fromIndex: int): int

    /**
     * Converts all elements of an array to strings and joins them using the specified separator.
     *
     * @param separator - separates one element of an array from the next in the resulting String.
     *
     * @returns joined representation
     */
    private final native joinInternal(separator: String): string;

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param separator A string used to separate one element of an array from the next in the
     * resulting String. If omitted, the array elements are separated with a comma
     *
     * @returns joined representation
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.joinInternal(",")
        }
        return this.joinInternal(separator)
    }

    /**
     * Returns an list of keys in BigUint64Array
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<int> {
        return new BigUint64ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in BigUint64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in BigUint64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: BigInt): int {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in BigUint64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int, fromIndex: int): int {
        return this.lastIndexOfImpl(searchElement.toLong(), fromIndex)
    }

    /**
     * Returns the index of the last occurrence of a value in BigUint64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is omitted, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: BigInt, fromIndex: int | undefined): int {
            return this.lastIndexOfImpl(searchElement.getLong(), fromIndex ?? 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native lastIndexOfImpl(searchElement: long, fromIndex: int): int

    /**
     * Returns the index of the first occurrence of a value in Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    private final native lastIndexOfImpl(searchElement: number, fromIndex: int): int

   /**
    * Creates a new BigUint64Array using initializer
    *
    * @param data initializer
    *
    * @returns a new BigUint64Array from data
    */
    public of(...data: FixedArray<BigInt>): BigUint64Array {
        throw new Error("BigUint64Array.of: not implemented")
    }

    /**
     * Creates a new BigUint64Array using reversed data from the current one
     *
     * @returns a new BigUint64Array using reversed data from the current one
     */
    public native reverse(): BigUint64Array

    /**
     * Creates a slice of current BigUint64Array using range [begin, end]
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new BigUint64Array with elements of current BigUint64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: int, end?: int): BigUint64Array {
        return this.sliceFromTo(begin ?? 0, end ?? this.lengthInt)
    }

    private sliceFromTo(begin: int, end: int): BigUint64Array {
        const relStart = normalizeIndex(begin, this.lengthInt)
        const relEnd = normalizeIndex(end, this.lengthInt)
        let buf: ArrayBuffer = this.buffer.slice(relStart * this.BYTES_PER_ELEMENT + this.byteOffsetInt, relEnd * this.BYTES_PER_ELEMENT + this.byteOffsetInt)
        return new BigUint64Array(buf)
    }

    /**
     * Creates a slice of current BigUint64Array using range [begin, this.lengthInt].
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new BigUint64Array with elements of current BigUint64Array[begin, this.lengthInt]
     */
    public slice(begin: int): BigUint64Array {
        return this.sliceFromTo(begin, this.lengthInt)
    }


    /**
     * Sorts in-place by numeric value in ascending order.
     *
     * @returns sorted BigUint64Array
     */
    public native sort(): this;

    /**
     * Sorts in-place
     *
     * @param compareFn comparator _  used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted BigUint64Array
     */
    public sort(compareFn?: (a: BigInt, b: BigInt) => number | BigInt): this {
        if (compareFn == undefined) {
            this.sort()
            return this
        }

        let cmp = (l: long, r: long): number => {
            const result = compareFn!(BigInt.fromULong(l), BigInt.fromULong(r))
            if (result instanceof BigInt) {
                const val = result as BigInt
                return val == 0n ? 0 : val > 0n ? 1 : -1
            } else {
                return result as number
            }
        }
        const MAX_SHORT_LENGTH = 24
        if (this.lengthInt > MAX_SHORT_LENGTH) {
            let arr: FixedArray<long> = new long[this.lengthInt]
            for (let i = 0; i < this.lengthInt; ++i) {
                arr[i] = this.getUnsafe(i)
            }
            arr = mergeSort(arr, cmp)
            for (let i = 0; i < arr.length; ++i) {
                this.setUnsafe(i, arr[i])
            }
        } else {
            let buffer: FixedArray<Long> = new Long[this.lengthInt]
            for (let i = 0; i < this.lengthInt; ++i) {
                buffer[i] = this.getUnsafe(i)
            }
            arr_sort_stable(buffer, 0, buffer.length as int, cmp)
            for (let i = 0; i < buffer.length; ++i) {
                this.setUnsafe(i, buffer[i])
            }
        }
        return this
    }

    /**
     * Creates a BigUint64Array with the same underlying Buffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new BigUint64Array with the same underlying Buffer
     */
    public subarray(begin?: int, end?: int): BigUint64Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin ?? 0, len)
        const relEnd = normalizeIndex(end ?? this.lengthInt, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new BigUint64Array(this.buffer, relStart * BigUint64Array.BYTES_PER_ELEMENT + this.byteOffsetInt, count)
    }

    /**
     * Converts BigUint64Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("BigUint64Array.toLocaleString: not implemented")
    }

    /**
     * Converts BigUint64Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts BigUint64Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(new BigInt(this.getUnsafe(i)).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append(new BigInt(this.getUnsafe(this.lengthInt - 1)).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): BigUint64Array {
        let newArray = new BigUint64Array(this.lengthInt)
        if (this.lengthInt > 0) {
            BigUint64Array.reverseCopyBuffer(newArray.buffer, this.buffer, this.byteOffset, this.lengthInt);
        }
        return newArray
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): BigUint64Array {
        return new BigUint64Array(this).sort()
    }

    /**
     * Returns a string representation of the BigUint64Array
     *
     * @returns a string representation of the BigUint64Array
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<BigInt> {
         return new BigUint64ArrayIterator(this)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an BigUint64Array with replaced value on index
     */
    public with(index: int, value: long): BigUint64Array {
        let res = new BigUint64Array(this)
        res.setUnsafeClamp(index, value)
        return res
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an BigUint64Array with replaced value on index
     */
    public with(index: int, value: BigInt): BigUint64Array {
        let res = new BigUint64Array(this)
        res.setUnsafeClamp(index, value.getULong())
        return res
    }

    /// === with element lambda functions ===

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: BigInt, index: int, array: BigUint64Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate(new BigInt(this.getUnsafe(i)), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = BigInt>(
                callbackfn: (previousValue: U, currentValue: BigInt, currentIndex: int, array: BigUint64Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: BigInt, currentValue: BigInt, currentIndex: int, array: BigUint64Array) => BigInt): BigInt {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = new BigInt(this.$_get(0))
        for (let i = 1; i < this.lengthInt; i++) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = BigInt>(
                callbackfn: (previousValue: U, currentValue: BigInt, currentIndex: int, array: BigUint64Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: BigInt, currentValue: BigInt, currentIndex: int, array: BigUint64Array) => BigInt): BigInt {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: BigInt = new BigInt(this.$_get(this.lengthInt - 1))
        for (let i = this.lengthInt - 2; i >= 0; i--) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i, this)
        }
        return accumulatedValue
    }

    /**
     * Creates a new BigUint64Array using fn(arr[i]) over all elements of current BigUint64Array.
     *
     * @param fn a function to apply for each element of current BigUint64Array
     *
     * @returns a new BigUint64Array where for each element from current BigUint64Array fn was applied
     */
    public map(fn: (val: BigInt, index: int, array: BigUint64Array) => BigInt): BigUint64Array {
        let resBuf = new ArrayBuffer(this.lengthInt * BigUint64Array.BYTES_PER_ELEMENT)
        let res = new BigUint64Array(resBuf)
        for (let i = 0; i < this.lengthInt; i++) {
            const fnRes = fn(new BigInt(this.getUnsafe(i)), i, this)
            res.setUnsafeClamp(i, fnRes.getULong())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: BigInt, index: int, array: BigUint64Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; i++) {
            if (!predicate(new BigInt(this.getUnsafe(i)), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Creates a new BigUint64Array from current BigUint64Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigUint64Array with elements from current BigUint64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt, index: int, array: BigUint64Array) => boolean): BigUint64Array {
        let markers : FixedArray<boolean> = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; i++) {
            markers[i] = fn(new BigInt(this.getUnsafe(i)), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let res = new BigUint64Array(resLen)
        for (let i = 0, j = 0; i < this.lengthInt; i++) {
            if (markers[i]) {
                res.setUnsafe(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns BigInt | undefined
     */
    public find(predicate: (value: BigInt, index: int, array: BigUint64Array) => boolean): BigInt | undefined {
        for (let i = 0; i < this.lengthInt; i++) {
            let val = new BigInt(this.getUnsafe(i))
            if (predicate(val, i, this)) {
                return val
            }
        }
        return undefined
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns int
     */
    public findIndex(predicate: (value: BigInt, index: int, obj: BigUint64Array) => boolean): int {
        for (let i = 0; i < this.lengthInt; i++) {
            if (predicate(new BigInt(this.getUnsafe(i)), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt, index: int, array: BigUint64Array) => boolean): BigInt {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            let val = new BigInt(this.getUnsafe(i))
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("BigUint64Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds an index of the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt, index: int, array: BigUint64Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; i--) {
            if (fn(new BigInt(this.getUnsafe(i)), i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Performs the specified action for each element in BigUint64Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: BigInt, index: int, array: BigUint64Array) => void): void {
        for (let i = 0; i < this.lengthInt; i++) {
            callbackfn(new BigInt(this.getUnsafe(i)), i, this)
        }
    }

    /**
     * Returns the object itself
     *
     * @returns BigUint64Array
     */
    public valueOf(): BigUint64Array {
        return this
    }

    /** Byte offset within the underlying Buffer */
    public get byteOffset(): int {
        return this.byteOffsetInt
    }

    /** Number of bytes used */
    public get byteLength(): int {
        return this.byteLengthInt
    }

    /** Number of long stored in BigUint64Array */
    public get length(): int {
        return this.lengthInt
    }

    /** String \"BigUint64Array\" */
    public readonly name = "BigUint64Array"

    private static native reverseCopyBuffer(dstBuf: ArrayBuffer, srcBuf: ArrayBuffer, startPos: int, length: int): void

    private static clamp(val: long): long {
        return val
    }

    private setUnsafeClamp(insertPos: int, val: long): void {
        this.setUnsafe(insertPos, val)
    }

    private final native getUnsafe(index: int): long

    private setUnsafe(index: int, val: long): void {
        const BPE = BigUint64Array.BYTES_PER_ELEMENT.toInt()
        let byteIndex = index * BPE + this.byteOffsetInt
        let buf = this.buffer
        if (IS_LITTLE_ENDIAN) {
            for (let i = 0; i < BPE; ++i) {
                buf.set(byteIndex++, (val & 0xff).toByte())
                val = val >> 8
            }
        } else {
            byteIndex = byteIndex + BPE - 1
            for (let i = 0; i < BPE; i++) {
                buf.set(byteIndex--, (val & 0xff).toByte())
                val = val >> 8
            }
        }
    }
}
