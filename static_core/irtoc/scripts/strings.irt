#!/usr/bin/env ruby

# Copyright (c) 2021-2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

include_relative 'common.irt'
include_relative 'string_helpers.irt'

GenerateStringEqualsUnrolled(compressed=true)
GenerateStringEqualsUnrolled(compressed=false)
GenerateStringEquals(lang='', dynamic=false, compressed=true, :FastPath)
GenerateStringEquals(lang='', dynamic=false, compressed=true, :NativePlus)
GenerateStringEquals(lang='', dynamic=false, compressed=false, :FastPath)
GenerateCreateStringFromStringTlab(string_compression_enabled=true)
GenerateCreateStringFromStringTlab(string_compression_enabled=false)
GenerateCreateStringFromCharArrayTlab(string_compression_enabled=true)
GenerateCreateStringFromCharArrayTlab(string_compression_enabled=false)
GenerateCreateStringFromZeroBasedCharArrayTlab(string_compression_enabled=true)
GenerateCreateStringFromZeroBasedCharArrayTlab(string_compression_enabled=false)
GenerateSubstringFromStringTlab(string_compression_enabled=true)
GenerateSubstringFromStringTlab(string_compression_enabled=false)
GenerateStringGetCharsTlab(string_compression_enabled=true)
GenerateStringGetCharsTlab(string_compression_enabled=false)
GenerateStringHashCode(string_compression_enabled=true, :FastPath)
GenerateStringHashCode(string_compression_enabled=true, :NativePlus)
GenerateStringHashCode(string_compression_enabled=false, :FastPath)

def GenerateStringCompareTo(cgmode)
  suffix = (cgmode == :NativePlus ? 'NativePlus': '')
  function("StringCompareTo#{suffix}",
           params: {str1_orig: 'ref', str2_orig: 'ref'},
           regmap: $full_regmap,
           regalloc_set: $panda_mask,
           mode: [cgmode]) {

    # Arm32 is not supported
    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).void.Terminator
      next
    end

    if cgmode == :NativePlus
        str1 := try_use_cached_flat_str(str1_orig)
        str2 := try_use_cached_flat_str(str2_orig)
    else
        check_not_tree_string_type(str1_orig) if defines.DEBUG
        check_not_tree_string_type(str2_orig) if defines.DEBUG
        # it still can be slice
        check_string_type(str1_orig)
        check_string_type(str2_orig)
        str1 := str1_orig
        str2 := str2_orig
    end

    Return(macroStringCompareTo(str1, str2)).i32

Label(:SlowPathEntrypoint)
    if cgmode == :NativePlus
        Return(Call(str1_orig, str2_orig).Method('CoreStringCompareTo').i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_COMPARE_TO_SLOW_PATH")
      Intrinsic(:SLOW_PATH_ENTRY, str1_orig, str2_orig).AddImm(entrypoint).MethodAsImm("StringCompareToUsualBridge").Terminator.i32
      Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
    end
  }
end

GenerateStringCompareTo(:FastPath)
GenerateStringCompareTo(:NativePlus)

function(:StringFlatCheck,
          params: {str: 'ref'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).void.Terminator
      next
    end

    If(str, 0).EQ {
      Return(str).ref
    }

    baseClass := LoadI(str).ref
    stringType := LoadI(baseClass).Imm(Constants::STRING_TYPE_OFFSET).u64
    If(stringType, Constants::STRING_TYPE_TREE).EQ {
        stringCache := LoadI(%tr).Imm(Constants::THREAD_FLATTENED_STRING_CACHE_OFFSET).ref
        If(stringCache, 0).EQ {
            Goto(:SlowPathEntrypoint)
        }

        # cannot cast directly from ref to uint
        strPtr := Cast(str).ptr
        strUint := Bitcast(strPtr).word
        strShifted := ShrI(strUint).Imm(FlattenedStringCacheConstants::ADDRESS_SHIFT).word
        strMasked := AndI(strShifted).Imm(FlattenedStringCacheConstants::ADDRESS_MASK).word
        strIndex := Mul(strMasked, FlattenedStringCacheConstants::ENTRY_SIZE).word
        key := LoadArray(stringCache, strIndex).SetNeedBarrier(true).ref
        If(key, str).NE {
            Goto(:SlowPathEntrypoint)
        }
        strIndex := AddI(strIndex).Imm(FlattenedStringCacheConstants::VALUE_OFFSET).ref_uint
        strCached := LoadArray(stringCache, strIndex).SetNeedBarrier(true).ref

        Return(strCached).ref
    }
    Return(str).ref

Label(:SlowPathEntrypoint)
    ep_offset = get_entrypoint_offset("STRING_FLAT_CHECK_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str).AddImm(ep_offset).MethodAsImm("StringFlatCheckOddSavedBridge").Terminator.ref
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}

include_plugin 'ets_string'
