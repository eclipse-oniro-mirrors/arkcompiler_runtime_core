#!/usr/bin/env ruby

# Copyright (c) 2021-2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

include_relative 'common.irt'
include_relative 'string_helpers.irt'

GenerateStringEquals(lang='', dynamic=false, compressed=true, :FastPath)
GenerateStringEquals(lang='', dynamic=false, compressed=true, :NativePlus)
GenerateStringEquals(lang='', dynamic=false, compressed=false, :FastPath)
GenerateCreateStringFromStringTlab(string_compression_enabled=true)
GenerateCreateStringFromStringTlab(string_compression_enabled=false)
GenerateCreateStringFromCharArrayTlab(string_compression_enabled=true)
GenerateCreateStringFromCharArrayTlab(string_compression_enabled=false)
GenerateCreateStringFromZeroBasedCharArrayTlab(string_compression_enabled=true)
GenerateCreateStringFromZeroBasedCharArrayTlab(string_compression_enabled=false)
GenerateSubstringFromStringTlab(string_compression_enabled=true)
GenerateSubstringFromStringTlab(string_compression_enabled=false)
GenerateStringGetCharsTlab(string_compression_enabled=true)
GenerateStringGetCharsTlab(string_compression_enabled=false)
GenerateStringHashCode(string_compression_enabled=true, :FastPath)
GenerateStringHashCode(string_compression_enabled=true, :NativePlus)
GenerateStringHashCode(string_compression_enabled=false, :FastPath)

available_regs = $panda_mask
function(:StringConcat2Tlab,
          params: {str1_orig: 'ref', str2_orig: 'ref'},
          regmap: $full_regmap,
          regalloc_set: available_regs,
          mode: [:FastPath]) {

    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).void.Terminator
      next
    end
    
    str1 := try_use_cached_flat_str(str1_orig)
    str2 := try_use_cached_flat_str(str2_orig)

    klass := load_class(str1)
    length1 := LoadI(str1).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length2 := LoadI(str2).Imm(Constants::STRING_LENGTH_OFFSET).u32

    # any of the strings is uncompressed (resulted string is uncompressed)
    has_uncompressed := AndI(Or(length1, length2).u32).Imm(1).u32

    count1 := ShrI(length1).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count2 := ShrI(length2).Imm(Constants::STRING_LENGTH_SHIFT).u32

    size := Add(count1, count2).u32
    data_size := Shl(size, has_uncompressed).u32
    length := Or(ShlI(size).Imm(Constants::STRING_LENGTH_SHIFT).u32, has_uncompressed).u32
    new_str := allocate_string_tlab(klass, data_size)

    StoreI(new_str, length).Imm(Constants::STRING_LENGTH_OFFSET).u32
    StoreI(new_str, Cast(0).u32).Imm(Constants::STRING_HASHCODE_OFFSET).u32

    src_str_data1 := AddI(str1).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data1 := AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr

    # has no uncompressed then everyting is compressed, data is stored as bytes
    If(has_uncompressed, 0).EQ.b {
      copy_u8_chars(src_str_data1, dst_str_data1, count1)

      offset := count1

      src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset).ptr
      copy_u8_chars(src_str_data2, dst_str_data2, count2)
      Goto(:EndCopy)
    }

    If(AndI(length1).Imm(1).u32, 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data1, dst_str_data1, count1)
    } Else {
      copy_u16_chars(src_str_data1, dst_str_data1, count1)
    }

    offset := ShlI(count1).Imm(1).u32
    src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset).ptr

    If(AndI(length2).Imm(1).u32, 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data2, dst_str_data2, count2)
    } Else {
      copy_u16_chars(src_str_data2, dst_str_data2, count2)
    }

    Label(:EndCopy)

    # String is supposed to be a constant object, so all its data should be visible by all threads
    Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
    Return(new_str).ptr

Label(:SlowPathEntrypoint)
    ep_offset = get_entrypoint_offset("STRING_CONCAT2_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str1_orig, str2_orig).AddImm(ep_offset).MethodAsImm("StringConcat2UsualBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}

available_regs = $panda_mask
function(:StringConcat3Tlab,
         params: {str1_orig: 'ref', str2_orig: 'ref', str3_orig: 'ref'},
         regmap: $full_regmap,
         regalloc_set: available_regs,
         mode: [:FastPath]) {

    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).void.Terminator
      next
    end

    str1 := try_use_cached_flat_str(str1_orig)
    str2 := try_use_cached_flat_str(str2_orig)
    str3 := try_use_cached_flat_str(str3_orig)

    klass := load_class(str1)
    length1 := LoadI(str1).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length2 := LoadI(str2).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length3 := LoadI(str3).Imm(Constants::STRING_LENGTH_OFFSET).u32

    has_uncompressed := AndI(Or(length3, Or(length1, length2).u32).u32).Imm(1).u32

    count1 := ShrI(length1).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count2 := ShrI(length2).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count3 := ShrI(length3).Imm(Constants::STRING_LENGTH_SHIFT).u32

    size := Add(count1, Add(count2, count3).u32).u32
    data_size := Shl(size, has_uncompressed).u32
    length := Or(ShlI(size).Imm(Constants::STRING_LENGTH_SHIFT).u32, has_uncompressed).u32
    new_str := allocate_string_tlab(klass, data_size)

    StoreI(new_str, length).Imm(Constants::STRING_LENGTH_OFFSET).u32
    StoreI(new_str, Cast(0).u32).Imm(Constants::STRING_HASHCODE_OFFSET).u32

    src_str_data1 := AddI(str1).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data1 := AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr

    offset1 := ShlI(count1).Imm(1).u32
    offset2 := Add(offset1, ShlI(count2).Imm(1).u32).u32

    # everything is compressed
    If(has_uncompressed, 0).EQ.b {
      copy_u8_chars(src_str_data1, dst_str_data1, count1)

      offset1_ := ShrI(offset1).Imm(1).u32

      src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset1_).ptr
      copy_u8_chars(src_str_data2, dst_str_data2, count2)

      offset2_ := ShrI(offset2).Imm(1).u32

      src_str_data3 := AddI(str3).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data3 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset2_).ptr
      copy_u8_chars(src_str_data3, dst_str_data3, count3)
      Goto(:EndCopy)
    }

    If(AndI(length1).Imm(1).u32, 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data1, dst_str_data1, count1)
    } Else {
      copy_u16_chars(src_str_data1, dst_str_data1, count1)
    }

    src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset1).ptr

    If(AndI(length2).Imm(1).u32, 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data2, dst_str_data2, count2)
    } Else {
      copy_u16_chars(src_str_data2, dst_str_data2, count2)
    }

    src_str_data3 := AddI(str3).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data3 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset2).ptr

    If(AndI(length3).Imm(1).u32, 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data3, dst_str_data3, count3)
    } Else {
      copy_u16_chars(src_str_data3, dst_str_data3, count3)
    }

Label(:EndCopy)
    # String is supposed to be a constant object, so all its data should be visible by all threads
    Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
    Return(new_str).ptr

Label(:SlowPathEntrypoint)
    ep_offset = get_entrypoint_offset("STRING_CONCAT3_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str1_orig, str2_orig, str3_orig).AddImm(ep_offset).MethodAsImm("StringConcat3OddSavedBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}

available_regs = $panda_mask
function(:StringConcat4Tlab,
         params: {str1_orig: 'ref', str2_orig: 'ref', str3_orig: 'ref', str4_orig: 'ref'},
         regmap: $full_regmap,
         regalloc_set: available_regs,
         mode: [:FastPath]) {
    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).void.Terminator
      next
    end

    str1 := try_use_cached_flat_str(str1_orig)
    str2 := try_use_cached_flat_str(str2_orig)
    str3 := try_use_cached_flat_str(str3_orig)
    str4 := try_use_cached_flat_str(str4_orig)

    klass := load_class(str1)
    length1 := LoadI(str1).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length2 := LoadI(str2).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length3 := LoadI(str3).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length4 := LoadI(str4).Imm(Constants::STRING_LENGTH_OFFSET).u32

    # any of the strings is uncompressed (resulted string is uncompressed)
    has_uncompressed := Or(length3, Or(length1, length2).u32).u32
    has_uncompressed := AndI(Or(length4, has_uncompressed).u32).Imm(1).u32

    count1 := ShrI(length1).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count2 := ShrI(length2).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count3 := ShrI(length3).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count4 := ShrI(length4).Imm(Constants::STRING_LENGTH_SHIFT).u32

    size := Add(count1, Add(count2, Add(count3, count4).u32).u32).u32
    data_size := Shl(size, has_uncompressed).u32
    length := Or(ShlI(size).Imm(Constants::STRING_LENGTH_SHIFT).u32, has_uncompressed).u32
    new_str := allocate_string_tlab(klass, data_size)

    StoreI(new_str, length).Imm(Constants::STRING_LENGTH_OFFSET).u32
    StoreI(new_str, Cast(0).u32).Imm(Constants::STRING_HASHCODE_OFFSET).u32

    src_str_data1 := AddI(str1).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data1 := AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr

    offset1 := ShlI(count1).Imm(1).u32
    offset2 := Add(offset1, ShlI(count2).Imm(1).u32).u32
    offset3 := Add(offset2, ShlI(count3).Imm(1).u32).u32

    # has no uncompressed then everything is compressed, data is stored as bytes
    If(has_uncompressed, 0).EQ.b {
      copy_u8_chars(src_str_data1, dst_str_data1, count1)

      offset1_ := ShrI(offset1).Imm(1).u32

      src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset1_).ptr
      copy_u8_chars(src_str_data2, dst_str_data2, count2)

      offset2_ := ShrI(offset2).Imm(1).u32

      src_str_data3 := AddI(str3).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data3 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset2_).ptr
      copy_u8_chars(src_str_data3, dst_str_data3, count3)

      offset3_ := ShrI(offset3).Imm(1).u32

      src_str_data4 := AddI(str4).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data4 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset3_).ptr
      copy_u8_chars(src_str_data4, dst_str_data4, count4)
      Goto(:EndCopy)
    }

    If(AndI(length1).Imm(1).u32, 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data1, dst_str_data1, count1)
    } Else {
      copy_u16_chars(src_str_data1, dst_str_data1, count1)
    }

    src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset1).ptr

    If(AndI(length2).Imm(1).u32, 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data2, dst_str_data2, count2)
    } Else {
      copy_u16_chars(src_str_data2, dst_str_data2, count2)
    }

    src_str_data3 := AddI(str3).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data3 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset2).ptr

    If(AndI(length3).Imm(1).u32, 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data3, dst_str_data3, count3)
    } Else {
      copy_u16_chars(src_str_data3, dst_str_data3, count3)
    }

    src_str_data4 := AddI(str4).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data4 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset3).ptr

    If(AndI(length4).Imm(1).u32, 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data4, dst_str_data4, count4)
    } Else {
      copy_u16_chars(src_str_data4, dst_str_data4, count4)
    }
Label(:EndCopy)
    # String is supposed to be a constant object, so all its data should be visible by all threads
    Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
    Return(new_str).ptr

Label(:SlowPathEntrypoint)
    ep_offset = get_entrypoint_offset("STRING_CONCAT4_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str1_orig, str2_orig, str3_orig, str4_orig).AddImm(ep_offset).MethodAsImm("StringConcat4UsualBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}

def GenerateStringCompareTo(cgmode)
  suffix = (cgmode == :NativePlus ? 'NativePlus': '')
  function("StringCompareTo#{suffix}",
           params: {str1_orig: 'ref', str2_orig: 'ref'},
           regmap: $full_regmap,
           regalloc_set: $panda_mask,
           mode: [cgmode]) {

    # Arm32 is not supported
    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).void.Terminator
      next
    end

    str1 := try_use_cached_flat_str(str1_orig)
    str2 := try_use_cached_flat_str(str2_orig)

    Return(macroStringCompareTo(str1, str2)).i32

Label(:SlowPathEntrypoint)
    if cgmode == :NativePlus
        Return(Call(str1_orig, str2_orig).Method('CoreStringCompareTo').i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_COMPARE_TO_SLOW_PATH")
      Intrinsic(:SLOW_PATH_ENTRY, str1_orig, str2_orig).AddImm(entrypoint).MethodAsImm("StringCompareToUsualBridge").Terminator.i32
      Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
    end
  }
end

GenerateStringCompareTo(:FastPath)
GenerateStringCompareTo(:NativePlus)

include_plugin 'ets_string'
