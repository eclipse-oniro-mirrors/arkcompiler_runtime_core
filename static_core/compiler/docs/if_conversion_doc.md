# IfConversion
## Overview

`IfConversion` tries to perform the following optimizations:
1. Remove branches in executable code by creating linear sections with predicate instructions (`Select`-family IR);
2. Fine-tune `Select`-family IRs generated by the previous step.

## Rationality

### Branch prediction

Hardware executes the program speculatively. It tries to predict the branch conditional (true or false) and starts executing instructions after the branch speculatively before executing the branch itself. If the prediction is incorrect (named branch misprediction), the pipeline stops and the state is restored. As result, several dozen cycles are lost.

`IfConversion` attempts to reduce branch misprediction by merging if-branches to selecting instructions if possible.
For example, `y = (c1 op c2) ? x1 : x2` can be optimized from if-branch plus two basic blocks (representing `y = x1` and `y = x2` respectively)
to a single IR instruction `y = Select(x1, x2, c1, c2, op)` which can be mapped to assembly instruction(s) without branching in most mainstream architectures
(`cmove` in x64, `csel` in Aarch64, etc.).

### Aarch64 selecting instructions

Aarch64 provides the following variations of selecting instructions besides `csel Xd, Xn, Xm, cond`:
* `csinc Xd, Xn, Xm, cond` (**C**onditional **S**elect **Inc**rement): If cond is true, then `Xd <- Xn`, otherwise `Xd <- Xm + 1`;
* `csinv Xd, Xn, Xm cond` (**C**onditional **S**elect **Inv**ert): If cond is true, then `Xd <- Xn`, otherwise `Xd <- ~Xm` where `~Xm` is bitwise inverse of `Xm`;
* `csneg Xd, Xn, Xm cond` (**C**onditional **S**elect **Neg**ate): If cond is true, then `Xd <- Xn`, otherwise `Xd <- -Xm` where `-Xm` is arithmetic negation of `Xm`.

## Dependence

*  Dead Code Elimination(DCE)
*  Remove Empty Blocks
*  Remove Linear blocks
*  Reverse Post Order(RPO)

## Algorithm step 1: if-branch removal

Optimization makes a pass through the blocks by post order traversal.
Two patterns are checked for each block: `Triangle` and `Diamond`.

### Triangle

The pattern:

```
      [BB]        
       |  \       
       |  [JBB]   
       |  /       
      [PBB]       
```
`BB` -- basic block the recognition starts from  
`JBB`(Join BB) -- true or false successor of `BB`, which will be joined to BB  
`PBB`(Phi BB) -- false or true successor of `BB`, which contain PHI instruction for BB and JBB

### Diamond

```
      [BB]
     /    \
   [JBB] [JBB 2]
     \    /
      [PBB]
```

`BB` -- basic block the recognition starts from  
`JBB`(Join BB), `JBB 2` -- true and false successors of BB, which will be joined to `BB `  
`PBB`(Phi BB) -- the successor of `JBB` and `JBB 2`, which contain PHI instruction for `JBB` and `JBB 2`  


### Conditions to check

1. `JBB`(and `JBB 2` for Diamond) must have only one predecessor and one successor
2. `PBB` must have 2 or more predecessors
3. `JBB`(and `JBB 2` for Diamond) is the predecessor of the PBB
4. `JBB`(and `JBB 2` for Diamond) doesn't contain instruction with `no_ifcvt` property(for example memory instruction, call instruction, instruction with a call to runtime)
5. The number of instructions in `JBB`(and `JBB 2` for Diamond) less than the limit(set by the option `--compiler-if-conversion-limit=N` with the default value 2)
6. The number of Phi instruction in `PBB`, which have different inputs from corresponding predecessor blocks, should also be less than the limit(each of them would be converted into Select)
7. `PBB` doesn't contain float Phi with different inputs for `JBB` and `BB`(`JBB 2` for Diamond)


### Transformation

1. `If` instructions removed from `BB`(the necessary information, such as the CC, is saved)
2. Edges `BB` -> `JBB` and `JBB` -> `PBB` are removed  
3. All instruction from `JBB` are copied to `BB`  
4. Select instructions are constructed at the end of `BB`(`JBB 2` for Diamond)   
5. All Phi instructions in `PBB` are edited:
   a. If `PBB` has other predecessors, we check if inputs from `JBB` and `BB`(`JBB 2` for Diamond) are equal, then input from `JBB` is removed. Otherwise, it is also removed, but input from `BB`(`JBB 2` for Diamond) is changed to corresponding Select instruction.
   b. If `PBB` doesn't have other predecessors, all Phi inputs are copied to Select instructions and Phi instruction is deleted. 
6. For Diamond `BB` and `JBB 2` are merged
7. If `PBB` doesn't have other predecessors, `BB` and `PBB` are merged
8. Loop information is fixed

### Pseudocode

TODO

### Examples

**Triangle**:  

Before:

```
BB 2  preds: [bb 0]
    3.b    Compare B u64              v0, v1 -> (v4)
    4.     IfImm NE b                 v3, 0x0
succs: [bb 3, bb 4]

BB 3  preds: [bb 2]
    5.u64  Mul                        v0, v2 -> (v6p)
succs: [bb 4]

BB 4  preds: [bb 2, bb 3]
   6p.u64  Phi                        v0(bb2), v5(bb3) -> (v7)
    7.u64  Return                     v6p
succs: [bb 1]
```
After:

```
BB 2  preds: [bb 0]
    3.b    Compare B u64              v0, v1 -> (v8)
    5.u64  Mul                        v0, v2 -> (v8)
    8.u64  SelectImm NE b             v5, v0, v3, 0x0 -> (v7)
    7.u64  Return                     v8
succs: [bb 1]
```

**Diamond**: 

Before:

```
BB 2  preds: [bb 0]
    3.b    Compare EQ u32             v1, v2 -> (v4)          
    4.     IfImm NE b                 v3, 0x0
succs: [bb 3, bb 4]

BB 4  preds: [bb 2]
    5.u32  Add                        v0, v1 -> (v8p)
succs: [bb 5]

BB 3  preds: [bb 2]
    7.u32  Sub                        v0, v1 -> (v8p)
succs: [bb 5]

BB 5  preds: [bb 4, bb 3]
   8p.u32  Phi                        v5(bb4), v7(bb3) -> (v9)
    9.u32  Return                     v8p
succs: [bb 1]
```

After:

```
BB 2  preds: [bb 0]
    3.b    Compare EQ u32             v1, v2 -> (v10)
    7.u32  Sub                        v0, v1 -> (v10)
    5.u32  Add                        v0, v1 -> (v10)
   10.u32  SelectImm NE b             v7, v5, v3, 0x0 -> (v9)
    9.u32  Return                     v10
succs: [bb 1]
```

## Algorithm step 2: fine-tuning Select-family IRs

1. Adds new IR `y = SelectTransform v1, v2, x1, x2, transform, cond`:
  * `transform` is one of `INC, INV, NEG`, corresponding to `csinc, csinv, csneg` respectively;
  * If `cond(x1, x2)` is true, then `y <- v1`, otherwise `y <- transform(v2)`.
2. Performs transformations by the following patterns.

### Pattern 1.1: Candidate with increment

Cases are similar when `v2 = SubI u, 1` or `v1 = SubI u, 1`.

```
v2 = AddI u, 1
y = Select v1, v2, x1, x2, cond
=>
y = SelectTransform v1, u, x1, x2, INC, cond

v1 = AddI u, 1
y = Select v1, v2, x1, x2, cond
=>
y = SelectTransform v2, u, x1, x2, INC, inverse(cond)
```

### Pattern 1.2: Candidate with inverse

```
v2 = Not u
y = Select v1, v2, x1, x2, cond
=>
y = SelectTransform v1, u, x1, x2, INV, cond

v1 = Not u
y = Select v1, v2, x1, x2, cond
=>
y = SelectTransform v2, u, x1, x2, INV, inverse(cond)
```

### Pattern 1.3: Candidate with negation

```
v2 = Neg u
y = Select v1, v2, x1, x2, cond
=>
y = SelectTransform v1, u, x1, x2, NEG, cond

v1 = Neg u
y = Select v1, v2, x1, x2, cond
=>
y = SelectTransform v2, u, x1, x2, NEG, inverse(cond)
```

### Pattern 2.1: Candidates with AddI/SubI whose immediates are differed by 1

Cases are similar with `SubI`.

```
v1 = AddI u, imm
v2 = AddI u, imm + 1
y = Select v1, v2, x1, x2, cond
=>
v1 = AddI u, imm
y = SelectTransform v1, v1, x1, x2, INC, cond

v1 = AddI u, imm + 1
v2 = AddI u, imm
y = Select v1, v2, x1, x2, cond
=>
v1 = AddI u, imm
y = SelectTransform v1, v1, x1, x2, INC, inverse(cond)
```

### Pattern 2.2: Candidates derived from the same operation

`SomeOp` can be one of:
* Arithmetic unary operation: `Neg, Not` etc.
* Arithmetic binary operation whose second operand (either immediate or virtual register) is fixed: `AddI u, imm; Add u, t` etc.

```
v1 = SomeOp u1
v2 = SomeOp u2
y = Select v1, v2, x1, x2, cond
=>
x = Select u1, u2, x1, x2, cond
y = SomeOp x
```

This pattern can be applied multiple times:
```
u1 = SomeOpA t1
u2 = SomeOpA t2
v1 = SomeOpB u1
v2 = SomeOpB u2
y = Select v1, v2, x1, x2, cond
=>
w = Select t1, t2, x1, x2, cond
x = SomeOpA w
y = SomeOpB x
```

## Links

Source code:   
[if_conversion.cpp](../optimizer/optimizations/if_conversion.cpp)    
[if_conversion.h](../optimizer/optimizations/if_conversion.h)  

Tests:  
[if_conversion_test.cpp](../tests/if_conversion_test.cpp)
