{#
/*
 * Copyright (c) 2025-2026 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#}

{%- if max_loop_count is not defined -%}
    {%- set max_loop_count = 10_000_000_000 -%}
{%- endif -%}
{%- if s2ms is not defined -%}
    {%- set s2ms = 1_000 -%}
{%- endif -%}

// map ets numerical types to number
type long = number;
type int = number;
type short = number;
type float = number;
type double = number;
type byte = number;

const MAX_LOOP_COUNT: int = {{max_loop_count}};
const NS2MS: int = 1_000_000;
const FROM_US: int = 1_000;
const S2MS: int = {{s2ms}};

class VmbLauncher {

    static WI: int = {{wi}};
    static MI: int = {{mi}};
    static IT: int = {{it}};
    static WT: int = {{wt}};
    static FI: int = {{fi}};
    static loopCount1: long = 0;
    static totalOps: long = 0;
    static totalNs: long = 0;
    static iter: int = 0;

    static log(msg: string): void {
    {%- if print_func == 'console' -%}
        console.info(msg);
    {%- elif print_func == 'hilog' -%}
        hilog.info(0, "VMB", msg);
    {%- else -%}
        print(msg);
    {%- endif -%}
    }

    static now_ns(): long {
        return ArkTools.timeInUs() * FROM_US as long;
    }

    static tune(bench: {{state_name}}): void {
        let iterMs: number = 1 * S2MS;
        let loopMs: number = 0;
        let loopNs: number = 0;
        let loopCount: number = 1;
        while (loopMs < iterMs && loopCount < MAX_LOOP_COUNT) {
            loopCount = loopCount * 2;
            let start: number = VmbLauncher.now_ns();
            for (let i: number = 0; i < loopCount; i++) {
                {{method_call}}
            }
            loopNs = VmbLauncher.now_ns() - start;
            loopMs = loopNs / NS2MS;
            
        }
        VmbLauncher.loopCount1 = loopCount * iterMs / loopMs >> 0;
        if (VmbLauncher.loopCount1 === 0) {
            VmbLauncher.loopCount1++;
        }
        VmbLauncher.log('Tuning: ' + loopCount + ' ops, ' +
                        loopNs / loopCount + ' ns/op => ' +
                        VmbLauncher.loopCount1 + ' reps');
    }

    static runIters(phase: String, count: int, time: int, bench: {{state_name}}): void {
        let iterMs: long = time * S2MS;
        VmbLauncher.totalOps = 0;
        VmbLauncher.totalNs = 0;
        for (let k: int = 0; k < count; k++) {
            let ops: long = 0;
            let elapsedMs: long = 0;
            let elapsedNs: long = 0;
            {% if gc > 0 %}
                VmbLauncher.log("Force GC");
                ArkTools.forceFullGC();
                // No sleep in TS: sleep({{gc}})
            {% else %}
                // No force GC
            {% endif %}
            let start: long = VmbLauncher.now_ns();
            while (elapsedMs < iterMs) {
                for (let i: long = 0; i < VmbLauncher.loopCount1; i++) {
                    {{method_call}}
                }
                elapsedNs = VmbLauncher.now_ns() - start;
                elapsedMs = elapsedNs / NS2MS;
                ops += VmbLauncher.loopCount1;
            }
            VmbLauncher.totalOps += ops;
            VmbLauncher.totalNs += elapsedNs;
            VmbLauncher.log(phase + " " + VmbLauncher.iter + ":" + ops + " ops, " + 1.0*elapsedNs/ops + " ns/op");
            VmbLauncher.iter++
        }
    }

    static main(): void {
        let bench: {{state_name}} = new {{state_name}}();
        VmbLauncher.log("Startup execution started: " + VmbLauncher.now_ns());
        {{state_params}}
        {{state_setup}}
    {%- if fi > 0 -%}
        // Fast Iterations mode
        VmbLauncher.log('Fast starting {{bench_name}} @ {{fixture}}...');
        let start = VmbLauncher.now_ns();
        for (let i = 0; i < VmbLauncher.FI; i++) {
            {{method_call}}
        }
        let elapsed = VmbLauncher.now_ns() - start;
        if (elapsed <= 0) {
            elapsed = 1;  // 0 is invalid result
        }
        VmbLauncher.log("Benchmark result: {{bench_name}} " + 1.0*elapsed/VmbLauncher.FI);
    {%- else -%}
        // Normal mode
        VmbLauncher.log('Starting {{bench_name}} @ {{fixture}}...');
        VmbLauncher.tune(bench);
        if (VmbLauncher.WI > 0) {
            VmbLauncher.iter = 1;
            // Re-entering runIters in warmup loop to allow profiler complete the method.
            // Possible deoptimizations and recompilations is done in warmup instead of measure phase.
            for (let wi: int = 0; wi < VmbLauncher.WI; ++wi) {
                VmbLauncher.runIters("Warmup", 1, VmbLauncher.WT, bench);
            }
        }
        VmbLauncher.iter = 1;
        VmbLauncher.runIters("Iter", VmbLauncher.MI, VmbLauncher.IT, bench);
        VmbLauncher.log("Benchmark result: {{bench_name}} " + 1.0*VmbLauncher.totalNs/VmbLauncher.totalOps);
    {%- endif -%}
        Consumer.consume_Object(bench);
    }

}
