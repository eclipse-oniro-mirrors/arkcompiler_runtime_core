/*
 * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!

static std::vector<uint8_t> &operator<<(std::vector<uint8_t> &out, Opcode op)
{
    if (static_cast<unsigned>(op) >= <%= Panda.instructions.select(&:prefix).map(&:opcode_idx).min %>) {
        out.push_back(static_cast<uint8_t>(op));
        out.push_back(static_cast<uint8_t>(static_cast<unsigned>(op) >> 8));
    } else {
        out.push_back(static_cast<uint8_t>(op));
    }
    return out;
}

% def get_min(width, is_signed)
%   if width < 8
%       if is_signed
%           return '%d' % ((1 << (width - 1)) - (1 << width))
%       else
%           return '%d' % ((1 << (width - 1)))
%       end
%   else
%       if is_signed
%           return 'std::numeric_limits<int%d_t>::min()' % width
%       else
%           return '%s + 1' % get_max(width / 2, false)
%       end
%   end
% end
%
% def get_max(width, is_signed)
%   if width < 8
%       if is_signed
%           return '%d' % ((1 << (width - 1)) - 1)
%       else
%           return '%d' % ((1 << width) - 1)
%       end
%   else
%       if is_signed
%           return 'std::numeric_limits<int%d_t>::max()' % width
%       else
%           return 'std::numeric_limits<uint%d_t>::max()' % width
%       end
%   end
% end
%
% Panda::instructions.group_by(&:mnemonic).each do |mnemonic, group|
%   emitter_name = group.first.emitter_name
%   formats = group.map(&:format)
%
%   if emitter_name == "Jmp"
%       next
%   end
%
%   i = group.first
%
%   if i.operands.empty?
HWTEST(BytecodeEmitter, <%= emitter_name %>, testing::ext::TestSize.Level0) {
    TestNoneFormat(Opcode::<%= i.opcode.upcase %>, [](BytecodeEmitter* emitter){
        emitter-><%= emitter_name %>();
    });
}
%   end
% end
